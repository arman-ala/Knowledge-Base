# Linux File Permissions

2025-10-15 09:21
Status: #DONE 
Tags: [[Linux]]

---
# Linux File Permissions: Configuration and Management for Enterprise Environments

## Introduction
File permissions in Linux are fundamental to system security and access control, ensuring that users, groups, and others interact with files and directories appropriately. This mechanism prevents unauthorized access while allowing fine-grained control. In enterprise settings, proper permission management is essential for compliance, data integrity, and operational efficiency. This article delves into viewing, understanding, and modifying permissions, with a focus on commands like `ls`, `chmod`, `chown`, and `chgrp`, tailored for LPIC certification and DevOps practices.

## Viewing Permissions with ls -l
To inspect file permissions, use the `ls` command with the `-l` flag for a long listing format:
```bash
ls -l
```
This displays detailed information, including permissions, ownership, group, size, modification time, and filename. Focus on the first column, which shows the permission string, such as:
```
drwxr----- 1 dorsa platoon 4096 file_or_dir
```
Here, the output indicates a directory (denoted by `d`) owned by user `dorsa` and group `platoon`. Assume `platoon` includes users like `soheil` and `arman` for illustrative purposes.

## Understanding Permission Bits
The permission string consists of 10 characters. The first character indicates the file type:
- `d`: Directory
- `-`: Regular file
- `l`: Symbolic link
- And others like `c` (character device), `b` (block device), etc.

The remaining nine characters represent permissions divided into three sets of three:
- First triplet: Owner (user) permissions
- Second triplet: Group permissions
- Third triplet: Others (world) permissions

Each triplet follows the order `rwx`:
- `r`: Read permission (value 4) – Allows viewing file contents or listing directory contents.
- `w`: Write permission (value 2) – Allows modifying file contents or adding/removing files in a directory.
- `x`: Execute permission (value 1) – Allows running a file as a program or traversing a directory.

A dash `-` means the permission is absent. For the example `drwxr-----`:
- Owner (`dorsa`): `rwx` (full access: read, write, execute)
- Group (`platoon`): `r--` (read only)
- Others: `---` (no access)

## Numeric Representation of Permissions
Permissions can be represented numerically in octal format by summing the values in each triplet:
- `r` = 4, `w` = 2, `x` = 1
- Full access: 7 (4+2+1)
- Read and execute: 5 (4+1)
- Read only: 4
- No access: 0

For `rwxr-----`:
- Owner: 7
- Group: 4
- Others: 0
Thus, the mode is 740.

## Verbal Description for LPIC Exams
In LPIC exams, when asked about permissions for a user or group, avoid numeric shorthand. Instead, describe explicitly:
- For group `platoon` in the example: "Platoon members can read, cannot write nor execute."
This ensures clarity and demonstrates understanding of access levels.

## Logical Progression of Permissions
Permissions typically decrease or remain equal from left to right (owner ≥ group ≥ others) for security reasons. Granting more access to others than to the group or owner is illogical and a potential misconfiguration. Always review with this principle to avoid unintended exposure.

Note that "others" excludes the owner and group members; it applies to all other system users.

## Important Notes on Permissions
Several key principles govern permission enforcement:
1. **Owner Access Limitations**: Contrary to the notion that owners can always write to their files regardless of permissions, Linux enforces permission bits strictly for all users, including the owner. If a file has mode 000 (no permissions), the owner cannot read, write, or execute it directly. However, ownership allows the owner to change permissions (via `chmod`) if they have write access to the containing directory. For example, an owner could first run `chmod 600 file` to grant themselves read/write access, then modify the file. Attempts to force actions like reading or executing without appropriate bits will fail. In editors like vi, if permissions deny write access, `:w!` (force write) will not succeed unless permissions allow it—any successful override in experiments likely involved prior access or root privileges.
   
   To clarify forcing read or execute: No, users (including owners) cannot bypass without the bits set. For reading, tools like `cat` will fail with "Permission denied." For execution, the shell will refuse. Always chmod first if needed.

2. **Root Privileges**: The root user (UID 0) bypasses all permission checks, allowing full access to any file or directory. This is a kernel-level exception for administrative purposes.

## Commands for Managing Permissions and Ownership
Permissions and ownership are managed with `chmod` (change mode), `chown` (change owner), and `chgrp` (change group). These commands operate on the permission bits, user, and group fields in the `ls -l` output, respectively. Note that `mv` (move) can rename or relocate files but does not directly alter permissions or ownership—it may inherit directory permissions during moves.

![[2.12. commands.png]]

### chmod Command
`chmod` modifies file modes using three methods: octal (numeric), symbolic, and reference. Always run with caution, as incorrect changes can lock out access.

#### Octal Method
Specifies absolute permissions numerically (e.g., 755). Useful for setting exact modes quickly.

Examples:
1. Set full owner access, read/execute for group and others on a script:
   ```bash:disable-run
   chmod 755 script.sh
   ```
   - Owner: rwx (7), Group: rx (5), Others: rx (5). Ideal for executable scripts in shared environments, ensuring the owner can modify while others can only run or read.

2. Restrict a configuration file to owner-only read/write:
   ```bash
   chmod 600 config.conf
   ```
   - Owner: rw- (6), Group: --- (0), Others: --- (0). Prevents accidental modifications by others, suitable for sensitive configs like SSH keys.

3. Make a directory traversable by all but writable only by owner:
   ```bash
   chmod 755 /path/to/dir
   ```
   - Owner: rwx (7), Group: r-x (5), Others: r-x (5). The `x` bit on directories allows traversal, while `w` is restricted to the owner, balancing security and usability.

4. Set read-only for all on a log file:
   ```bash
   chmod 444 logfile.log
   ```
   - All: r-- (4). Prevents modifications, ideal for audit logs where data integrity is critical post-write.

5. Grant group write access to a shared document:
   ```bash
   chmod 664 document.txt
   ```
   - Owner: rw- (6), Group: rw- (6), Others: r-- (4). Enables team collaboration while limiting others to read-only, a common pattern for shared docs.

#### Symbolic Method
Uses symbols like `u` (user/owner), `g` (group), `o` (others), `a` (all), with `+` (add), `-` (remove), `=` (set exactly), and `rwx`.

Examples:
1. Add execute permission for owner on a binary:
   ```bash
   chmod u+x binary
   ```
   - Adds `x` to the owner’s permissions, leaving group and others unchanged. Useful for enabling a freshly compiled binary without altering others’ access.

2. Remove write for group and others on a sensitive file:
   ```bash
   chmod go-w secure.file
   ```
   - Removes `w` from group and others, enhancing security for files like private keys, while retaining the owner’s write access.

3. Set exact read/write for all on a temp file:
   ```bash
   chmod a=rw temp.txt
   ```
   - Sets rw- for user, group, and others, removing any `x`. Suitable for temporary files where execution isn’t needed but collaboration is.

4. Add read and execute for others on a public directory:
   ```bash
   chmod o+rx public_dir
   ```
   - Adds `r` and `x` to others, allowing public access to list and traverse without write privileges, common for web roots.

5. Revoke all group permissions on a private key:
   ```bash
   chmod g= private.key
   ```
   - Sets group to ---, isolating the file to the owner, critical for sensitive data like SSL certificates.

![[2.12. chmod symbolic form.png]]

#### Reference Method
Copies permissions from a reference file using `--reference`.

Examples:
1. Match permissions of a template config to a new one:
   ```bash
   chmod --reference=template.conf new.conf
   ```
   - Copies the exact mode (e.g., 644) from `template.conf`, ensuring consistency for configuration files across systems.

2. Apply directory permissions to subfiles:
   ```bash
   chmod --reference=/parent/dir file_inside
   ```
   - If `/parent/dir` is 755, `file_inside` becomes 755. Useful with `-R` for recursive alignment in project directories.

3. Sync permissions between backup and original:
   ```bash
   chmod --reference=original.txt backup.txt
   ```
   - Ensures identical access (e.g., 600) for redundancy, critical in backup strategies.

4. Reference a secure file for a new script:
   ```bash
   chmod --reference=secure_script new_script.sh
   ```
   - Copies a mode like 700, restricting to owner execution, mirroring security settings.

5. Align group-shared files:
   ```bash
   chmod --reference=group_file1 group_file2
   ```
   - Maintains uniform permissions (e.g., 664) within team directories, simplifying access control.

### chown Command
`chown` changes file owner and optionally group (format: `user:group`). Below are 10 detailed examples:

1. Change owner to `dorsa` for a log file:
   ```bash
   chown dorsa logfile.log
   ```
   - Transfers ownership to `dorsa`, leaving the group unchanged. Useful for reassigning logs to a new admin.

2. Set both owner and group for a script:
   ```bash
   chown dorsa:platoon script.sh
   ```
   - Assigns `dorsa` as owner and `platoon` as group. Ensures proper team access for shared scripts.

3. Recursively change owner on a directory:
   ```bash
   chown -R dorsa /path/to/dir
   ```
   - Applies `dorsa` ownership to all files and subdirs. Ideal for migrating entire project ownership.

4. Change owner using a reference file:
   ```bash
   chown --reference=template.conf config.conf
   ```
   - Copies ownership from `template.conf` (e.g., `user1:group1`). Streamlines setup consistency.

5. Change owner only if current matches a condition:
   ```bash
   chown --from=root:user2 dorsa file.txt
   ```
   - Changes to `dorsa` only if owned by `root` and group `user2`. Prevents unintended overwrites.

6. Verbose output for ownership change:
   ```bash
   chown -v dorsa:platoon file.txt
   ```
   - Displays confirmation (e.g., "changed ownership of file.txt"). Helpful for auditing.

7. Change owner without dereferencing symlinks:
   ```bash
   chown -h dorsa symlink
   ```
   - Modifies the symlink itself, not its target. Useful for managing link metadata.

8. Recursively with symlink traversal:
   ```bash
   chown -R -H dorsa /linked/dir
   ```
   - Traverses symlinked directories, applying `dorsa` ownership. Ensures comprehensive updates.

9. Silent change with no errors:
   ```bash
   chown -f dorsa file.txt
   ```
   - Suppresses errors if `dorsa` doesn’t exist. Good for bulk operations with potential failures.

10. Preserve root protection:
    ```bash
    chown --preserve-root -R dorsa /
    ```
    - Fails on `/` to prevent accidental system-wide changes. A safety net for recursive ops.
11.  Change group:
```bash
chown :newGroup f1
```
	
### chgrp Command
`chgrp` changes only the group. Below are 10 detailed examples:

1. Change group to `platoon` for a document:
   ```bash
   chgrp platoon document.txt
   ```
   - Assigns `platoon` as the group, keeping the owner intact. Facilitates team access.
   -  **equivalent to `chmod :platoon document.txt`** 

2. Recursively update group on a directory:
   ```bash
   chgrp -R platoon /team/dir
   ```
   - Applies `platoon` to all contents. Useful for setting up shared project spaces.

3. Change group using a reference file:
   ```bash
   chgrp --reference=template.conf config.conf
   ```
   - Copies the group from `template.conf` (e.g., `platoon`). Ensures alignment.

4. Verbose group change output:
   ```bash
   chgrp -v platoon file.txt
   ```
   - Outputs "changed group of file.txt to platoon." Aids in verification.

5. Change group only if current matches:
   ```bash
   chgrp --from=:user2 platoon file.txt
   ```
   - Sets `platoon` only if current group is `user2`. Prevents unintended shifts.

6. Modify symlink group directly:
   ```bash
   chgrp -h platoon symlink
   ```
   - Changes the group of the symlink, not its target. Useful for link-specific control.

7. Recursively with symlink traversal:
   ```bash
   chgrp -R -H platoon /linked/dir
   ```
   - Applies `platoon` to symlinked dirs. Ensures consistent group settings.

8. Silent group change:
   ```bash
   chgrp -f platoon file.txt
   ```
   - Suppresses errors if `platoon` is invalid. Handy for batch processing.

9. Preserve root safety:
   ```bash
   chgrp --preserve-root -R platoon /
   ```
   - Prevents changes to `/`. A critical safeguard in recursive ops.

10. Conditional group change with owner check:
    ```bash
    chgrp --from=dorsa:user2 platoon file.txt
    ```
    - Changes to `platoon` only if owned by `dorsa` and group `user2`. Adds precision.

## Tables for Command Flags

### Table 1: chmod Command Flags
| Flag                  | Description                                                                                          |
| --------------------- | ---------------------------------------------------------------------------------------------------- |
| -c, --changes         | Like verbose but report only when a change is made.                                                  |
| -f, --silent, --quiet | Suppress most error messages.                                                                        |
| -v, --verbose         | Output a diagnostic for every file processed.                                                        |
| --dereference         | Affect the referent of each symbolic link, rather than the symbolic link itself.                     |
| -h, --no-dereference  | Affect each symbolic link, rather than the referent.                                                 |
| --no-preserve-root    | Do not treat '/' specially (the default).                                                            |
| --preserve-root       | Fail to operate recursively on '/'.                                                                  |
| --reference=RFILE     | Use RFILE's mode instead of specifying MODE values. RFILE is always dereferenced if a symbolic link. |
| -R, --recursive       | Change files and directories recursively.                                                            |
| -H                    | If a command line argument is a symbolic link to a directory, traverse it (modifies -R).             |
| -L                    | Traverse every symbolic link to a directory encountered (modifies -R).                               |
| -P                    | Do not traverse any symbolic links (modifies -R).                                                    |
| --help                | Display this help and exit.                                                                          |
| --version             | Output version information and exit.                                                                 |

### Table 2: chown Command Flags
| Flag                               | Description                                                                                                                 |
| ---------------------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| -c, --changes                      | Like verbose but report only when a change is made.                                                                         |
| -f, --silent, --quiet              | Suppress most error messages.                                                                                               |
| -v, --verbose                      | Output a diagnostic for every file processed.                                                                               |
| --dereference                      | Affect the referent of each symbolic link (this is the default), rather than the symbolic link itself.                      |
| -h, --no-dereference               | Affect symbolic links instead of any referenced file (useful only on systems that can change the ownership of a symlink).   |
| --from=CURRENT_OWNER:CURRENT_GROUP | Change the ownership of each file only if its current owner and/or group match those specified here. Either may be omitted. |
| --no-preserve-root                 | Do not treat '/' specially (the default).                                                                                   |
| --preserve-root                    | Fail to operate recursively on '/'.                                                                                         |
| --reference=RFILE                  | Use RFILE's ownership rather than specifying values. RFILE is always dereferenced if a symbolic link.                       |
| -R, --recursive                    | Operate on files and directories recursively.                                                                               |
| -H                                 | If a command line argument is a symbolic link to a directory, traverse it (modifies -R).                                    |
| -L                                 | Traverse every symbolic link to a directory encountered (modifies -R).                                                      |
| -P                                 | Do not traverse any symbolic links (modifies -R).                                                                           |
| --help                             | Display this help and exit.                                                                                                 |
| --version                          | Output version information and exit.                                                                                        |

### Table 3: chgrp Command Flags
| Flag                               | Description                                                                                                                 |
| ---------------------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| -c, --changes                      | Like verbose but report only when a change is made.                                                                         |
| -f, --silent, --quiet              | Suppress most error messages.                                                                                               |
| -v, --verbose                      | Output a diagnostic for every file processed.                                                                               |
| --dereference                      | Affect the referent of each symbolic link (this is the default), rather than the symbolic link itself.                      |
| -h, --no-dereference               | Affect symbolic links instead of any referenced file (useful only on systems that can change the ownership of a symlink).   |
| --from=CURRENT_OWNER:CURRENT_GROUP | Change the ownership of each file only if its current owner and/or group match those specified here. Either may be omitted. |
| --no-preserve-root                 | Do not treat '/' specially (the default).                                                                                   |
| --preserve-root                    | Fail to operate recursively on '/'.                                                                                         |
| --reference=RFILE                  | Use RFILE's ownership rather than specifying values. RFILE is always dereferenced if a symbolic link.                       |
| -R, --recursive                    | Operate on files and directories recursively.                                                                               |
| -H                                 | If a command line argument is a symbolic link to a directory, traverse it (modifies -R).                                    |
| -L                                 | Traverse every symbolic link to a directory encountered (modifies -R).                                                      |
| -P                                 | Do not traverse any symbolic links (modifies -R).                                                                           |
| --help                             | Display this help and exit.                                                                                                 |
| --version                          | Output version information and exit.                                                                                        |

### Table 4: Common Permission Modes
| Octal | Symbolic  | Description                                                             |
| ----- | --------- | ----------------------------------------------------------------------- |
| 777   | rwxrwxrwx | Full access for all – risky, avoid in production.                       |
| 755   | rwxr-xr-x | Owner full, others read/execute – standard for executables/directories. |
| 644   | rw-r--r-- | Owner read/write, others read – common for files.                       |
| 600   | rw------- | Owner only read/write – for sensitive data.                             |
| 700   | rwx------ | Owner only full – for private scripts.                                  |
| 400   | r-------- | Read-only for owner – immutable configs.                                |
| 000   | --------- | No access – temporary lockdown.                                         |

## Best Practices and Tips
- **Principle of Least Privilege**: Grant minimal permissions needed. Start restrictive and add as required.
- **Recursive Caution**: Use `-R` with care; preview changes with `-v` or test on copies.
- **Symbolic Links**: Default dereferences; use `-h` to modify links themselves.
- **Auditing**: Combine with `find` for bulk checks: `find /dir -perm -u+w` lists owner-writable files.
- **Umasks**: Set default creation modes via `umask` (e.g., 022 for 755 dirs). In ~/.bashrc: `umask 022`.
- **ACLs for Advanced Control**: For finer granularity beyond basic permissions, use `setfacl` and `getfacl`.
- **Backup Before Changes**: Always `cp -p` (preserve modes) files before altering.
- **Troubleshooting**: If "Permission denied," check with `ls -l` and `id` for your user/group. Use `strace` for deep debugging.
- **Enterprise Tip**: In DevOps, automate with Ansible/Puppet modules for consistent permissions across fleets.

## Troubleshooting Common Issues
- **Access Denied**: Verify bits match action (e.g., `x` for dirs). Check parent directory permissions.
- **Ownership Mismatch**: Use `chown -R` for dirs, but specify `--from` to target specifics.
- **Symlink Errors**: Use `-H/-L/-P` appropriately to handle traversal.

## Conclusion
Mastering Linux permissions ensures secure, efficient systems. Through detailed understanding of viewing, interpreting, and modifying them, administrators can mitigate risks and optimize access in enterprise environments. The methods and examples provided offer practical guidance for LPIC preparation and real-world DevOps tasks.

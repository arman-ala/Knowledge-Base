# 3.10. Group Module

2025-08-13 21:00
Status: #DONE 
Tags: [[Ansible]]

---
## Understanding the Ansible Group Module: A Comprehensive Guide

In the domain of DevOps automation, Ansible provides robust tools for managing system resources, including user groups on remote hosts. The `ansible.builtin.group` module is designed to add or remove groups, offering precise control over group properties such as GID and system status. This document delivers a detailed examination of the module, informed by its official documentation and the provided resource, which includes examples of creating groups with specific configurations. It commences with a simplified overview for foundational understanding, followed by an in-depth analysis of its parameters, including all possible values, best practices, and illustrative examples with expected outputs.

#### Simplified Explanation: Breaking It Down Simply

Consider the `group` module as a group manager for your remote servers: it can create a new team (group) like "developers" or disband one if no longer needed. You specify the group’s name, decide if it’s a system group (for special system tasks), assign a group ID (GID) if desired, and choose whether to keep or remove it. For instance, creating a "docker" group with GID 1750 is as easy as telling Ansible to set it up, and it ensures the group exists without duplicates. It’s a straightforward way to organize user permissions across your infrastructure, ensuring consistency and security.

#### In-Depth Analysis: Precise and Comprehensive Coverage

The `ansible.builtin.group` module, an integral part of `ansible-core`, facilitates the management of groups on POSIX platforms by interacting with system commands such as `groupadd`, `groupdel`, and `groupmod`. It supports adding (`state: present`) or removing (`state: absent`) groups, with options to set GIDs, designate system groups, and handle local group commands in centralized authentication environments. The module requires the aforementioned commands on the target host and fully supports `check_mode` for dry-run predictions, though it lacks `diff_mode` support. It is tailored for POSIX systems, with no native Windows equivalent (use `ansible.windows.win_group` instead).

The module’s functionality has evolved with recent additions. Since Ansible 2.15, the `force` parameter allows deletion of groups even if they are a user’s primary group on supporting platforms. Since Ansible 2.18, `gid_min` and `gid_max` enable customization of GID ranges, overriding `/etc/login.defs` on Linux, provided `local` is not set to `true`. These enhancements provide greater flexibility in diverse system configurations.

Below, each parameter is analyzed in detail, encompassing its purpose, type, default value, all possible values, requirements, and interactions. Best practices, tips, and tricks are incorporated, with examples derived from documentation and expanded with reasoning about expected outcomes.

- **force**: Determines whether to delete a group even if it is a user’s primary group. Type: boolean. Default: false. Possible values: true (force deletion), false (prevent deletion if primary). Required: No. Notes: Applicable only on platforms with a `--force` flag (e.g., Linux with recent `groupdel`); added in Ansible 2.15.

  Best practice: Use true cautiously to avoid breaking user configurations. Tip: Check platform support with `man groupdel`; trick: Combine with `state: absent` and test in check mode.

  Example: Force delete.
  ```yaml
  - name: Force remove group
    ansible.builtin.group:
      name: oldgroup
      state: absent
      force: yes
  ```
  Expected output: Deletes `oldgroup` even if primary (`changed: true`); fails on unsupported platforms; return: `state: absent`, no `gid` if removed.

- **gid**: Specifies the group ID for the group. Type: integer. Default: None (system assigns). Possible values: Any valid GID (e.g., 1000–60000, system GIDs typically <1000). Required: No. Notes: Must be unique unless `non_unique` is true.

  Best practice: Assign specific GIDs for consistency across systems. Tip: Reserve low GIDs for system groups; trick: Use `gid_min`/`gid_max` to enforce range.

  Example from resource: Set GID.
  ```yaml
  - name: Ensure group with GID
    ansible.builtin.group:
      name: docker
      state: present
      gid: 1750
  ```
  Expected output: Creates/updates `docker` with GID 1750 (`changed: true` if new/different); return: `gid: 1750`, `name: docker`, `system: false`.

- **gid_max**: Sets the maximum GID for group creation. Type: integer. Default: None (uses `/etc/login.defs`). Possible values: Any integer (e.g., 60000). Required: No. Notes: Supported on Linux only; ignored if `local: true`; added in Ansible 2.18.

  Best practice: Align with organizational GID policies. Tip: Check current max with `getent group`; trick: Use with `gid_min` for range enforcement.

  Example: Set GID max.
  ```yaml
  - name: Create group with GID max
    ansible.builtin.group:
      name: testgroup
      state: present
      gid_max: 50000
  ```
  Expected output: Creates `testgroup` with GID ≤ 50000 (`changed: true`); fails if GID exceeds; return: `gid` within range.

- **gid_min**: Sets the minimum GID for group creation. Type: integer. Default: None (uses `/etc/login.defs`). Possible values: Any integer (e.g., 1000). Required: No. Notes: Supported on Linux only; ignored if `local: true`; added in Ansible 2.18.

  Best practice: Avoid overlapping with system GIDs (<1000). Tip: Test range with `groupadd -g`; trick: Combine with `gid_max`.

  Example: Set GID min.
  ```yaml
  - name: Create group with GID min
    ansible.builtin.group:
      name: testgroup
      state: present
      gid_min: 2000
  ```
  Expected output: Creates `testgroup` with GID ≥ 2000 (`changed: true`); return: `gid` within range.

- **local**: Forces use of local group commands (e.g., `lgroupadd`) in centralized authentication environments. Type: boolean. Default: false. Possible values: true (use local commands), false (use system commands). Required: No. Notes: Requires local commands; fails if absent.

  Best practice: Use true in LDAP/NIS setups for local groups. Tip: Verify command availability; trick: Test with `which lgroupadd`.

  Example: Use local commands.
  ```yaml
  - name: Create local group
    ansible.builtin.group:
      name: localgroup
      state: present
      local: yes
  ```
  Expected output: Uses `lgroupadd` if available (`changed: true`); fails if commands missing; return: `name: localgroup`.

- **name**: The name of the group to manage. Type: string. Default: None. Possible values: Any valid group name (e.g., `developers`, `admins`). Required: Yes. Notes: Must comply with system naming rules (e.g., no `/`).

  Best practice: Use descriptive, unique names. Tip: Avoid spaces; trick: Use variables (e.g., `{{ group_name }}`).

  Example from resource: Basic create.
  ```yaml
  - name: Ensure group exists
    ansible.builtin.group:
      name: somegroup
      state: present
  ```
  Expected output: Ensures `somegroup` exists (`changed: true` if created); return: `name: somegroup`, `state: present`.

- **non_unique**: Allows non-unique GIDs. Type: boolean. Default: false. Possible values: true (allow duplicates), false (require unique). Required: No. Notes: Requires `gid`; unsupported on macOS or BusyBox; added in 2.8.

  Best practice: Use only when necessary (e.g., legacy systems). Tip: Check with `getent group`; trick: Test impact on users.

  Example: Non-unique GID.
  ```yaml
  - name: Create with non-unique GID
    ansible.builtin.group:
      name: dupgroup
      state: present
      gid: 1000
      non_unique: yes
  ```
  Expected output: Creates `dupgroup` with GID 1000 even if used (`changed: true`); fails on unsupported platforms.

- **state**: Defines the group’s desired presence. Type: string. Default: present. Possible values: present (create/update), absent (remove). Required: No.

  Best practice: Use absent for cleanup tasks. Tip: Combine with `force` for removal; trick: Use check mode to preview.

  Example from resource: Present state.
  Expected output: Ensures group exists.

- **system**: Designates the group as a system group. Type: boolean. Default: false. Possible values: true (system group), false (user group). Required: No. Notes: System groups typically have lower GIDs.

  Best practice: Set true for system services. Tip: Check GID range; trick: Use with `gid` for specific IDs.

  Example: System group.
  ```yaml
  - name: Create system group
    ansible.builtin.group:
      name: sysgroup
      state: present
      system: yes
  ```
  Expected output: Creates `sysgroup` as system group (`changed: true`); return: `system: true`, `gid` < 1000.

### Practical Examples and Expected Outcomes

1. **Basic Group Creation**:
   ```yaml
   - name: Create group
     ansible.builtin.group:
       name: developers
       state: present
   ```
   Outcome: Ensures `developers` exists (`changed: true` if new); return: `name: developers`, `state: present`, `gid` assigned by system.

2. **Remove Group with Force**:
   ```yaml
   - name: Remove group forcefully
     ansible.builtin.group:
       name: oldgroup
       state: absent
       force: yes
   ```
   Outcome: Deletes `oldgroup` even if primary (`changed: true`); return: `state: absent`.

3. **System Group with GID**:
   ```yaml
   - name: Create system group
     ansible.builtin.group:
       name: syslog
       state: present
       system: yes
       gid: 101
   ```
   Outcome: Creates `syslog` as system group with GID 101 (`changed: true`); return: `system: true`, `gid: 101`.

### Best Practices and Considerations

- **Idempotency**: Leverages `state` for idempotent operations; use check mode to preview changes.
- **Security**: Assign specific GIDs to prevent conflicts; use `system` for service isolation.
- **Compatibility**: Verify command availability (`groupadd` et al.) and platform support (e.g., `non_unique`).
- **Troubleshooting**: Use `-v` for verbose output; check `/etc/group` post-execution.

## Additional Examples for the Ansible Group Module

#### Example 1: Creating a Group with GID Range Constraints
```yaml
- name: Create group within specific GID range
  ansible.builtin.group:
    name: appgroup
    state: present
    gid_min: 2000
    gid_max: 2999
```
**Explanation**: This example creates a group named `appgroup` with a GID constrained between 2000 and 2999. The module will automatically select an available GID within this range. This is useful for maintaining consistent GID assignments across systems while avoiding conflicts with system groups. Output shows `changed: true` if the group was created, with the assigned GID in the return values (e.g., `gid: 2045`).

#### Example 2: Creating a System Group with Non-Unique GID
```yaml
- name: Create system group with non-unique GID
  ansible.builtin.group:
    name: sharedgroup
    state: present
    system: yes
    gid: 995
    non_unique: yes
```
**Explanation**: This example creates a system group named `sharedgroup` with GID 995, allowing non-unique GIDs. This is useful in environments where multiple groups need to share the same GID for compatibility reasons. The `system: yes` parameter ensures it's treated as a system group. Output shows `changed: true` if the group was created, with `system: true` and `gid: 995` in the return values.

#### Example 3: Removing a Group Only If It Exists
```yaml
- name: Check if group exists
  ansible.builtin.getent:
    database: group
    key: tempgroup
  register: group_check
  ignore_errors: yes

- name: Remove group if it exists
  ansible.builtin.group:
    name: tempgroup
    state: absent
  when: group_check is successful
```
**Explanation**: This example first checks if a group named `tempgroup` exists using the `getent` module, then removes it only if it exists. This approach is useful for cleanup tasks where you want to avoid errors when the group doesn't exist. Output shows `changed: true` only if the group existed and was removed, otherwise the task is skipped.

#### Example 4: Creating Multiple Groups with Variables
```yaml
- name: Define groups
  ansible.builtin.set_fact:
    groups_to_create:
      - name: webadmins
        gid: 4001
        system: no
      - name: dbadmins
        gid: 4002
        system: no
      - name: servicegroup
        gid: 150
        system: yes

- name: Create groups
  ansible.builtin.group:
    name: "{{ item.name }}"
    state: present
    gid: "{{ item.gid }}"
    system: "{{ item.system }}"
  loop: "{{ groups_to_create }}"
```
**Explanation**: This example demonstrates creating multiple groups using a loop with variable definitions. The groups are defined in a list with their respective properties, then created in a loop. This approach is useful for managing multiple groups consistently across systems. Output shows `changed: true` for each group that was created, with their respective properties in the return values.

#### Example 5: Creating a Local Group in LDAP Environment
```yaml
- name: Create local group in LDAP environment
  ansible.builtin.group:
    name: localusers
    state: present
    local: yes
    system: no
```
**Explanation**: This example creates a local group named `localusers` in an environment with centralized authentication (like LDAP). The `local: yes` parameter ensures the group is created locally rather than in the centralized directory. This is useful for maintaining local groups that shouldn't be managed by the central authentication system. Output shows `changed: true` if the group was created, with `local: true` in the return values.

#### Example 6: Force Removing a Group That Is a Primary Group
```yaml
- name: Force remove group even if primary
  ansible.builtin.group:
    name: oldteam
    state: absent
    force: yes
```
**Explanation**: This example forcefully removes a group named `oldteam` even if it is the primary group for some users. The `force: yes` parameter allows this removal on platforms that support it (like Linux with recent `groupdel`). This is useful for cleaning up old groups that might be primary groups for users who no longer need them. Output shows `changed: true` if the group was removed, with a warning if users were affected.

#### Example 7: Creating a Group with Conditional GID Assignment
```yaml
- name: Create group with conditional GID
  ansible.builtin.group:
    name: conditionalgroup
    state: present
    gid: "{{ 5000 if ansible_distribution == 'Ubuntu' else 5001 }}"
```
**Explanation**: This example creates a group named `conditionalgroup` with a GID that depends on the distribution of the target system. On Ubuntu systems, it uses GID 5000, while on other systems it uses GID 5001. This approach is useful for maintaining consistency across different operating systems with different GID requirements. Output shows `changed: true` if the group was created, with the appropriate GID based on the distribution.

#### Example 8: Creating a Group with Validation
```yaml
- name: Create group with validation
  ansible.builtin.group:
    name: validatedgroup
    state: present
    gid: 6000
  register: group_result

- name: Validate group creation
  ansible.builtin.assert:
    that:
      - group_result.gid == 6000
      - group_result.name == 'validatedgroup'
      - group_result.state == 'present'
  fail_msg: "Group creation validation failed"
```
**Explanation**: This example creates a group named `validatedgroup` with GID 6000, then validates that the creation was successful by checking the return values. The `assert` module verifies that the group was created with the correct properties. This approach is useful for critical group management tasks where you need to ensure the operation completed successfully. Output shows `changed: true` if the group was created, followed by validation success or failure.

#### Example 9: Creating a Group with Fallback GID
```yaml
- name: Try to create group with specific GID
  ansible.builtin.group:
    name: fallbackgroup
    state: present
    gid: 7000
  register: group_attempt
  ignore_errors: yes

- name: Create group with system-assigned GID
  ansible.builtin.group:
    name: fallbackgroup
    state: present
  when: group_attempt.failed
```
**Explanation**: This example first attempts to create a group named `fallbackgroup` with a specific GID (7000). If that fails (e.g., because the GID is already in use), it creates the group with a system-assigned GID. This approach is useful when you prefer a specific GID but can accept a system-assigned one if necessary. Output shows `changed: true` for whichever task succeeded, with the appropriate GID in the return values.

#### Example 10: Managing Groups Based on Host Role
```yaml
- name: Create groups based on host role
  ansible.builtin.group:
    name: "{{ item }}"
    state: present
  loop:
    - "{{ 'webgroup' if 'web' in group_names else 'nongroup' }}"
    - "{{ 'dbgroup' if 'database' in group_names else 'nongroup' }}"
```
**Explanation**: This example creates groups based on the role of the host. If the host is in the 'web' group, it creates 'webgroup'; if it's in the 'database' group, it creates 'dbgroup'. This approach is useful for dynamically managing groups based on the host's role in the infrastructure. Output shows `changed: true` for each group that was created based on the host's group membership.

### Summary Table of Arguments

| Argument Name | Type | Default Value | Possible Values | Required | Notes/Deprecations |
|---------------|------|---------------|-----------------|----------|--------------------|
| force | boolean | false | true, false | No | Added 2.15; platform-dependent |
| gid | integer | None | Any valid GID | No | Must be unique unless non_unique |
| gid_max | integer | None | Any integer | No | Added 2.18; Linux only |
| gid_min | integer | None | Any integer | No | Added 2.18; Linux only |
| local | boolean | false | true, false | No | Requires local commands |
| name | string | None | Any group name | Yes | - |
| non_unique | boolean | false | true, false | No | Added 2.8; requires gid |
| state | string | present | present, absent | No | - |
| system | boolean | false | true, false | No | - |


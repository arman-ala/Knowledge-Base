# 3.3. Shell Module

2025-08-12 19:23
Status: #DONE 
Tags: [[Ansible]]

---
## Exploring the Ansible Shell Module: A Comprehensive Guide

In the domain of DevOps automation, Ansible's flexibility in executing shell commands on remote hosts is a cornerstone of efficient configuration management. While the `command` module provides a straightforward way to run commands, it has limitations, particularly in handling shell-specific features like pipes, redirects, and environment variable expansions. The `shell` module addresses these gaps, offering a robust alternative for executing complex shell commands. This article delves into the `shell` module, providing a simplified explanation for foundational understanding and a detailed, precise analysis of its arguments, including all possible values, best practices, and illustrative examples. We also build upon the context of the `command` module to highlight key differences and use cases.

#### Simplified Explanation: Breaking It Down Simply

Think of the `shell` module as a more powerful version of the `command` module, like giving your remote workers a full toolbox instead of just a single tool. While the `command` module runs instructions exactly as written, the `shell` module lets you use advanced features like pipes (`|`), redirects (`>` or `<`), and environment variables (like `$PATH`) that you’d typically use in a terminal. It’s like telling your workers, “Run this command in a full terminal environment, where you can chain tasks or save output to a file.” For example, if you want to filter a list of files and save it to a text file, you might use:

```bash
ls /etc | grep conf > output.txt
```

The `shell` module makes this possible in Ansible, executing the command through a shell (like `/bin/sh`), which understands these special symbols. However, with great power comes responsibility—test carefully to avoid unintended side effects, and use it only when simpler modules (like `file` or `yum`) aren’t enough.

#### In-Depth Analysis: Precise and Comprehensive Coverage

The `shell` module, part of the `ansible.builtin` collection, executes commands through a shell interpreter (typically `/bin/sh` on Unix-like systems or `cmd.exe` on Windows when not using PowerShell). Unlike the `command` module, which runs commands directly without shell processing, the `shell` module supports shell metacharacters (`*`, `<`, `>`, `|`, `;`, `&`) and resolves environment variables via the shell, making it ideal for complex command chains or scripts requiring shell-specific behavior. However, this flexibility reduces inherent idempotency, requiring careful use of arguments like `creates` or `removes` to prevent unintended repeated executions.

The `shell` module shares many arguments with the `command` module, but its shell environment introduces nuances in their application. Below, we analyze each argument in detail, covering its purpose, type, default value, all possible values, requirements, and interactions. We include best practices, tips, and tricks, along with examples that demonstrate the module’s capabilities and expected outputs, particularly in comparison to the `command` module.

- **argv**: Allows passing the command as a list of strings, avoiding quoting issues in complex commands. Type: list (elements are strings). Default: None. Possible values: Any list of strings representing the command and arguments (e.g., `['ls', '-l', '|', 'grep', 'conf']`). Required: Yes, if `free_form` or `cmd` is not used; mutually exclusive with `free_form` and `cmd`. Notes: Useful for precise argument handling in shell pipelines.

  **Best Practice**: Use `argv` for commands with pipes or redirects to ensure accurate parsing. **Tip**: Split shell pipelines into list elements to mirror shell tokenization. **Trick**: Validate `argv` structure locally using `ansible -m debug` to avoid syntax errors.

  **Example**: Filter and redirect output.
  ```yaml
  - name: Filter configuration files and save to file
    ansible.builtin.shell:
      argv: ['ls', '/etc', '|', 'grep', 'conf', '>', '/tmp/output.txt']
  ```
  **Expected Output**: Creates `/tmp/output.txt` containing names of files in `/etc` matching “conf” (e.g., `httpd.conf`). The result’s `stdout` may be empty due to redirection, but `changed: true` indicates execution. Unlike `command`, this works because the shell processes the pipe and redirect.

- **chdir**: Changes the working directory before execution. Type: path (string). Default: None (uses the remote user’s default directory). Possible values: Any valid path (e.g., `/tmp`, `./subdir`). Required: No.

  **Best Practice**: Use absolute paths to ensure consistency. **Tip**: Combine with `creates` for tasks like compiling code in a specific directory. **Trick**: Verify path existence with the `stat` module to prevent errors.

  **Example**: Run a command in a specific directory.
  ```yaml
  - name: List files in /tmp and filter
    ansible.builtin.shell:
      cmd: 'ls | grep txt'
      chdir: '/tmp'
  ```
  **Expected Output**: Lists files in `/tmp` matching “txt” (e.g., `file1.txt` in `stdout_lines`). The `command` module would fail on the pipe (`|`) without shell processing.

- **cmd**: Specifies the command as a string, improving readability over free-form input. Type: string. Default: None. Possible values: Any valid shell command (e.g., `ls /etc | grep conf`). Required: No, but one of `cmd`, `free_form`, or `argv` is needed.

  **Best Practice**: Use `cmd` for clarity in playbooks. **Tip**: Test commands locally in a shell to ensure correct syntax. **Trick**: Use with `warn: false` to suppress warnings for non-idempotent commands.

  **Example**: Chain commands with a pipe.
  ```yaml
  - name: Count configuration files
    ansible.builtin.shell:
      cmd: 'ls /etc | wc -l'
  ```
  **Expected Output**: Returns the number of files in `/etc` (e.g., `stdout: "42"`). The `command` module would fail due to the pipe.

- **creates**: Skips execution if a specified file or glob pattern exists, enhancing idempotency. Type: path. Default: None. Possible values: Any path or glob (e.g., `/tmp/file`, `/tmp/*.log`). Required: No. Notes: Checked before `removes`.

  **Best Practice**: Use for tasks like script execution to prevent reruns. **Tip**: Glob patterns allow flexible matching. **Trick**: Pair with `register` for conditional logic in subsequent tasks.

  **Example**: Run a command only if a file doesn’t exist.
  ```yaml
  - name: Create a marker file
    ansible.builtin.shell:
      cmd: 'echo "done" > /tmp/marker'
      creates: '/tmp/marker'
  ```
  **Expected Output**: Creates `/tmp/marker` on first run (`changed: true`); skips subsequent runs (`changed: false`). This mirrors `command` behavior but supports shell redirection.

- **executable**: Specifies the shell to use for command execution. Type: path. Default: `/bin/sh` (or platform equivalent). Possible values: Any valid shell path (e.g., `/bin/bash`, `/bin/zsh`). Required: No.

  **Best Practice**: Explicitly set to `/bin/bash` for Bash-specific syntax. **Tip**: Verify shell availability on target hosts. **Trick**: Use with `ansible_facts` to detect system defaults.

  **Example**: Use Bash explicitly.
  ```yaml
  - name: Run Bash-specific command
    ansible.builtin.shell:
      cmd: 'source ./script.sh'
      executable: '/bin/bash'
  ```
  **Expected Output**: Executes `script.sh` using Bash, supporting Bash-specific features like `source`. The `command` module cannot handle `source`.

- **expand_argument_vars**: Controls whether shell variables (e.g., `$HOME`) are expanded. Type: boolean. Default: true. Possible values: `true` (expand via shell), `false` (treat literally). Required: No. Notes: Added in ansible-core 2.16. Unlike `command`, expansion occurs via the shell, not Python.

  **Best Practice**: Set to `false` for commands with untrusted input to avoid injection. **Tip**: Test variable expansions in a shell to confirm behavior. **Trick**: Use `ansible -m debug` to inspect resolved values.

  **Example**: Expand environment variable.
  ```yaml
  - name: Echo home directory
    ansible.builtin.shell:
      cmd: 'echo $HOME'
      expand_argument_vars: true
  ```
  **Expected Output**: Outputs the user’s home directory (e.g., `stdout: "/home/user"`). With `false`, outputs literal `$HOME`. The `command` module uses Python expansion, which may differ.

- **free_form**: Represents the command as a free-form string (not a named parameter). Type: string. Default: None. Possible values: Any shell command. Required: Yes, if `argv` or `cmd` is not used; mutually exclusive with `argv`.

  **Best Practice**: Use for simple commands; prefer `cmd` or `argv` for clarity. **Tip**: Avoid complex pipelines in free-form to reduce errors.

  **Example**: Free-form pipeline.
  ```yaml
  - name: Filter and save output
    ansible.builtin.shell: 'ls /etc | grep conf > /tmp/conf_files.txt'
  ```
  **Expected Output**: Creates `/tmp/conf_files.txt` with matching files. The `command` module would fail on `|` and `>`.

- **removes**: Executes only if a specified file or glob exists. Type: path. Default: None. Possible values: Any path or glob. Required: No. Notes: Checked after `creates`.

  **Best Practice**: Use for cleanup tasks conditional on file presence. **Tip**: Combine with `failed_when` for custom error conditions. **Trick**: Use globs for batch operations.

  **Example**: Remove a file conditionally.
  ```yaml
  - name: Delete temporary file
    ansible.builtin.shell:
      cmd: 'rm /tmp/marker'
      removes: '/tmp/marker'
  ```
  **Expected Output**: Deletes `/tmp/marker` if present (`changed: true`); skips otherwise (`changed: false`). Similar to `command` but supports shell syntax.

- **stdin**: Provides input to the command’s standard input. Type: string. Default: None. Possible values: Any string. Required: No.

  **Best Practice**: Use for commands requiring interactive input. **Tip**: Escape special characters if needed. **Trick**: Test stdin behavior locally first.

  **Example**: Pipe input that includes shell metacharacters.
  ```yaml
  - name: Process input with grep
    ansible.builtin.shell:
      cmd: 'grep conf'
      stdin: 'httpd.conf\nssh.conf'
  ```
  **Expected Output**: Outputs lines containing “conf” (e.g., `stdout_lines: ["httpd.conf", "ssh.conf"]`). The `command` module supports `stdin` but not shell pipelines.

- **stdin_add_newline**: Appends a newline to `stdin` data. Type: boolean. Default: true. Possible values: `true`, `false`. Required: No. Notes: Added in Ansible 2.8.

  **Best Practice**: Set `false` for binary or precise input. **Tip**: Ensure commands expect newline-terminated input.

  **Example**: Input without newline.
  ```yaml
  - name: Input to cat
    ansible.builtin.shell:
      cmd: 'cat'
      stdin: 'No newline'
      stdin_add_newline: false
  ```
  **Expected Output**: Outputs “No newline” without trailing newline, versus `true` adding one.

- **strip_empty_ends**: Removes empty lines from the end of `stdout`/`stderr`. Type: boolean. Default: true. Possible values: `true`, `false`. Required: No. Notes: Added in Ansible 2.8.

  **Best Practice**: Keep `true` for cleaner logs. **Tip**: Set `false` for debugging exact output.

  **Example**: Preserve trailing newlines.
  ```yaml
  - name: Echo with trailing newlines
    ansible.builtin.shell:
      cmd: 'echo "line1\n\n"'
      strip_empty_ends: false
  ```
  **Expected Output**: Includes trailing newlines in `stdout`, versus `true` stripping them.

## Additional Examples for the Ansible Shell Module

#### Example 1: Complex Pipeline with Environment Variables
```yaml
- name: Find large files and sort by size
  ansible.builtin.shell:
    cmd: 'find /var/log -type f -name "*.log" -exec du -h {} + | sort -hr'
    register: large_logs
```
**Explanation**: This demonstrates a complex pipeline using `find`, `du`, and `sort` with shell-specific features. The command finds all `.log` files in `/var/log`, gets their human-readable sizes, and sorts them in descending order. The shell module processes the pipe (`|`) and command substitution (`+`) correctly, which would fail with the command module. Output shows large log files sorted by size in `stdout_lines`.

#### Example 2: Using `executable` with Bash-Specific Syntax
```yaml
- name: Execute Bash script with process substitution
  ansible.builtin.shell:
    cmd: 'diff <(cat /etc/hosts) <(cat /etc/hosts.backup)'
    executable: '/bin/bash'
    register: diff_result
```
**Explanation**: This uses Bash-specific process substitution (`<()`) to compare two files. The `executable` parameter ensures Bash is used instead of the default `/bin/sh`, which doesn't support this feature. The output shows differences between the files or is empty if they match. This highlights the shell module's ability to handle advanced shell features when the appropriate shell is specified.

#### Example 3: Combining `chdir`, `creates`, and Shell Redirection
```yaml
- name: Generate configuration file only if missing
  ansible.builtin.shell:
    cmd: 'echo "[database]" > config.ini && echo "host=localhost" >> config.ini'
    chdir: '/opt/app'
    creates: '/opt/app/config.ini'
```
**Explanation**: This creates a configuration file in a specific directory only if it doesn't exist. The shell module processes the redirections (`>` and `>>`) and command chaining (`&&`) correctly. On first run, it creates the file with the specified content (`changed: true`); subsequent runs skip the task (`changed: false`). The `chdir` ensures the file is created in the correct directory.

#### Example 4: Using `stdin` with Shell Pipelines
```yaml
- name: Process input through multiple filters
  ansible.builtin.shell:
    cmd: 'grep "error" | cut -d":" -f2 | sort | uniq'
    stdin: |
      error: File not found
      info: Operation completed
      error: Permission denied
      error: File not found
  register: processed_errors
```
**Explanation**: This demonstrates passing multi-line input through a pipeline of shell commands. The input is filtered for "error" lines, extracts the second field using `cut`, sorts them, and removes duplicates. The shell module processes the entire pipeline correctly. Output shows unique error messages in `stdout_lines`, such as `[" Permission denied", " File not found"]`.

#### Example 5: Using `removes` with Glob Patterns for Cleanup
```yaml
- name: Clean up temporary files matching pattern
  ansible.builtin.shell:
    cmd: 'rm -f /tmp/temp_*.txt'
    removes: '/tmp/temp_*.txt'
```
**Explanation**: This uses a glob pattern with `removes` to delete temporary files only if they exist. The shell module processes the wildcard (`*`) correctly, removing all matching files. If no files match the pattern, the task is skipped entirely. This provides safe, conditional cleanup that handles multiple files efficiently.

#### Example 6: Controlling Variable Expansion with `expand_argument_vars`
```yaml
- name: Safely handle user input with variables
  ansible.builtin.shell:
    cmd: 'echo "Input: {{ user_input }}"'
    expand_argument_vars: false
  register: safe_output
```
**Explanation**: This demonstrates secure handling of user input by disabling variable expansion. With `expand_argument_vars: false`, any shell metacharacters or variables in `user_input` are treated literally, preventing command injection. For example, if `user_input` contains `$HOME`, it will be echoed as literal text rather than expanded to the actual home directory path.

#### Example 7: Using `strip_empty_ends` for Precise Output Control
```yaml
- name: Capture command output with trailing newlines
  ansible.builtin.shell:
    cmd: 'printf "Line 1\n\nLine 3\n"'
    strip_empty_ends: false
  register: formatted_output
```
**Explanation**: This demonstrates `strip_empty_ends: false` to preserve empty lines in the output. The `printf` command outputs three lines with an empty line in between. With `strip_empty_ends: false`, the registered output retains all empty lines exactly as produced by the command, which is important for format-sensitive tasks.

#### Example 8: Conditional Execution with Shell Features
```yaml
- name: Restart service if configuration changed
  ansible.builtin.shell:
    cmd: 'systemctl restart nginx && systemctl status nginx'
    when: config_changed|bool
  register: service_restart
```
**Explanation**: This shows conditional execution of a shell command with command chaining. The restart only occurs if the `config_changed` variable is true. The shell module processes the `&&` operator correctly, restarting the service and then checking its status. The output shows the service status after restart, demonstrating how shell operators can be used for sequential command execution.

#### Example 9: Using `argv` with Complex Shell Syntax
```yaml
- name: Execute complex command with precise argument handling
  ansible.builtin.shell:
    argv:
      - 'bash'
      - '-c'
      - 'for i in {1..5}; do echo "Count: $i"; done'
    register: count_output
```
**Explanation**: This uses `argv` to execute a Bash for-loop with precise argument handling. The command iterates from 1 to 5, printing each count. The `argv` parameter ensures the complex shell syntax is passed correctly to Bash. Output shows numbered lines in `stdout_lines`, demonstrating how `argv` can be used for complex shell commands that require careful argument handling.

#### Example 10: Combining Multiple Shell Features
```yaml
- name: Advanced file processing with multiple shell features
  ansible.builtin.shell:
    cmd: |
      if [ -f /tmp/data.csv ]; then
        head -10 /tmp/data.csv | tail -5 > /tmp/extracted_data.txt
        echo "Extraction complete" >&2
      else
        echo "Data file not found" >&2
        exit 1
      fi
    executable: '/bin/bash'
    register: extraction_result
```
**Explanation**: This combines multiple shell features: conditional logic (`if`), file existence check (`-f`), head/tail commands, redirection (`>`), and error output (`>&2`). The `executable` parameter ensures Bash is used for these features. The command extracts lines 6-10 from a CSV file if it exists, or exits with an error if not. Output shows the extraction result or error message, demonstrating the shell module's ability to handle complex shell scripts.

#### Key Differences from the `command` Module

The `command` module’s limitation, as noted, is that it does not process commands through a shell, rendering metacharacters like `*`, `<`, `>`, `|`, `;`, and `&` inoperative. Environment variables are resolved via Python, not the shell, unless `expand_argument_vars` is enabled, and unmatched variables remain unchanged. The `shell` module, by contrast, leverages the shell environment, enabling:

- **Shell Features**: Support for pipes, redirects, and wildcards, critical for complex workflows.
- **Environment Variable Resolution**: Variables like `$PATH` are expanded by the shell, aligning with terminal behavior.
- **Flexibility vs. Safety**: The `shell` module’s power increases the risk of unintended side effects, requiring careful validation.

**Best Practice**: Use the `command` module for simple, self-contained commands to maximize security and idempotency. Reserve the `shell` module for tasks requiring shell-specific features, and always prioritize specialized modules (e.g., `yum`, `file`) when available.

**Tip**: Use `register` to capture `shell` module outputs for further processing, and test in `--check` mode to simulate execution. **Trick**:26**: Combine `creates` and `removes` with `when` conditions to enforce idempotency in `shell` tasks.

#### Summary Table of Arguments

| Argument Name          | Type                  | Default Value | Possible Values                                                                 | Required | Notes/Deprecations |
|------------------------|-----------------------|---------------|---------------------------------------------------------------------------------|----------|--------------------|
| argv                   | list (elements=string)| None          | Any list of strings (e.g., `['ls', '|', 'grep', 'conf']`)                      | Yes (if no free_form/cmd) | Mutually exclusive with free_form/cmd |
| chdir                  | path (string)         | None          | Any valid path (e.g., `/tmp`, `./dir`)                                          | No       | Sets working directory |
| cmd                    | string                | None          | Any shell command (e.g., `ls /etc | grep conf`)                                 | No (but needed if no free_form/argv) | Alternative to free_form |
| creates                | path (string)         | None          | Any path or glob (e.g., `/file`, `*.log`)                                       | No       | Skips if exists; checked first |
| executable             | path (string)         | `/bin/sh`     | Any shell path (e.g., `/bin/bash`, `/bin/zsh`)                                  | No       | Specifies shell interpreter |
| expand_argument_vars   | boolean               | true          | `true`, `false`                                                                 | No       | Added in 2.16; shell-based var expansion |
| free_form              | string                | None          | Any shell command                                                               | Yes (if no argv/cmd) | Not a named param; free-form input |
| removes                | path (string)         | None          | Any path or glob                                                                | No       | Runs if exists; checked after creates |
| stdin                  | string                | None          | Any string data                                                                 | No       | Provides command input |
| stdin_add_newline      | boolean               | true          | `true`, `false`                                                                 | No       | Added in 2.8; appends newline to stdin |
| strip_empty_ends       | boolean               | true          | `true`, `false`                                                                 | No       | Added in 2.8; strips trailing empty lines |

This comprehensive exploration of the `shell` module equips DevOps practitioners with the knowledge to leverage its power effectively, balancing its flexibility with disciplined use to ensure robust automation workflows.
# 3.18.1. Container Lifecycle

2025-08-09 18:45
Status: #DONE 
Tags: [[Docker]]

---
## Exploring the Lifecycle of a Container: Starting with `docker stop`

Let’s dive into the lifecycle of a Docker container, focusing on the various states it can go through—like starting, stopping, pausing, restarting, unpausing, and removing. We’ll begin by examining the `docker stop` command, using examples to illustrate its behavior, and I’ll add some extra insights to help you understand how it works in different scenarios.

### Understanding `docker stop`

When a container is running, it behaves like a process on your system. The `docker stop` command is used to gracefully stop a running container, transitioning it to a stopped (or "down") state. Here’s the basic syntax:

```bash
docker stop [CONTAINER]
```

When you run this command, Docker sends a `SIGTERM` signal to the container’s main process (PID 1), giving it a chance to shut down cleanly. If the process doesn’t exit within a certain time, Docker follows up with a `SIGKILL` signal to forcefully terminate it.

#### Specifying a Timeout with the `-t` Flag
Some applications need more time to shut down gracefully (e.g., to save data or close connections). You can use the `-t` (or `--time`) flag to specify how long Docker should wait after sending the `SIGTERM` signal before sending a `SIGKILL`. The time is in seconds.

**Example**:
```bash
docker stop -t 20 [CONTAINER]
```
- This tells Docker to send a `SIGTERM` to the container’s main process.
- Docker then waits for 20 seconds. If the process hasn’t exited by then, Docker sends a `SIGKILL` to forcefully stop the container.

**Default Timeout**:  
If you don’t specify the `-t` flag, Docker uses a default timeout of 10 seconds. So, `docker stop [CONTAINER]` is equivalent to `docker stop -t 10 [CONTAINER]`.

### Example: Stopping the `centos_bash` Container

Let’s see this in action with a container. You ran the following command to start a container:

```bash
docker run -itd --name centos_bash centos:latest
```
- This starts a container named `centos_bash` using the `centos:latest` image.
- The `-itd` flags make it run interactively (`-i`), with a TTY (`-t`), and in detached mode (`-d`).
- The default command for `centos:latest` is `"/bin/bash"`, so the container’s main process is a Bash shell.

Now, you stop the container with:

```bash
docker stop -t 20 centos_bash
```

**What Happens**:  
- Docker sends a `SIGTERM` signal to the container’s main process (the `/bin/bash` process, PID 1).
- In this case, the Bash shell inside the container responds immediately to the `SIGTERM` signal and exits. Since `/bin/bash` is the container’s main process (its "mission"), the container stops as soon as the Bash process terminates.
- Because Bash exits quickly (usually within a fraction of a second), the container stops well before the 20-second timeout, and Docker doesn’t need to send a `SIGKILL`.

**Why It Stops Early**:  
The Bash shell is designed to handle `SIGTERM` by exiting immediately. Since the container’s sole purpose is to run this Bash process, the container transitions to the `Exited` state as soon as the process stops. You can verify this with:

```bash
docker ps -a
```
The `centos_bash` container will show a status like `Exited (0) X seconds ago`, where `0` is the exit code, indicating a normal exit.

### Stopping a Container Running `ping`: Exit Code 137

Now, let’s consider a different scenario where a container’s main process doesn’t exit cleanly with `SIGTERM`. Suppose you have a container running the `ping` command, similar to the `centos_ping` container from your earlier outputs:

```bash
docker run -d --name centos_ping centos:latest ping 8.8.8.8
```
- This container’s main process is `ping 8.8.8.8`, which continuously pings Google’s DNS server.

You stop it with:

```bash
docker stop centos_ping
```

**What Happens**:  
- Docker sends a `SIGTERM` signal to the `ping` process.
- The `ping` command doesn’t always exit gracefully on `SIGTERM` (it depends on the implementation and the system). If it doesn’t exit within the default 10-second timeout, Docker sends a `SIGKILL` to forcefully terminate the process.
- When a container is stopped with `SIGKILL`, it exits with code **137**. This exit code is a convention in Docker: it’s calculated as `128 + 9`, where `9` is the signal number for `SIGKILL`.

**Why Exit Code 137?**:  
- Exit code 137 indicates that the container was forcefully terminated by a `SIGKILL` signal. This is common for processes like `ping` that don’t handle `SIGTERM` gracefully or need more time to shut down than the timeout allows.
- You can check the exit code with:
  ```bash
  docker ps -a
  ```
  The `centos_ping` container might show a status like `Exited (137) X seconds ago`.

**Adjusting the Timeout**:  
If you want to give the `ping` process more time to exit cleanly, you can increase the timeout:

```bash
docker stop -t 30 centos_ping
```
This gives the `ping` process 30 seconds to respond to `SIGTERM` before Docker sends a `SIGKILL`. However, since `ping` typically doesn’t handle `SIGTERM` well, it’s likely to still exit with code 137 after the timeout.

### Additional Insights

#### Signal Handling in Containers
- **Process Behavior**: How a container responds to `docker stop` depends on how its main process handles signals. For example, `/bin/bash` exits immediately on `SIGTERM`, but other processes (like `ping` or a custom application) might ignore `SIGTERM` or need specific cleanup logic.
- **Custom Signal Handling**: If you’re running a custom application in a container, you can program it to handle `SIGTERM` gracefully (e.g., by saving state and exiting cleanly). This can prevent the need for a `SIGKILL` and ensure a clean shutdown with exit code 0.

#### Stopping Multiple Containers
You can stop multiple containers at once by passing multiple container names or IDs to `docker stop`:

```bash
docker stop centos_bash centos_ping
```
Docker will stop each container in parallel, sending `SIGTERM` to each main process and waiting for the default 10-second timeout (or your specified `-t` value) before sending `SIGKILL`.

#### Difference Between `docker stop` and `docker kill`
- **`docker stop`**: Attempts a graceful shutdown by sending `SIGTERM`, then `SIGKILL` after the timeout. It’s the preferred way to stop containers.
- **`docker kill`**: Immediately sends a `SIGKILL` (or another signal if specified with `--signal`), forcefully terminating the container without giving it a chance to shut down cleanly. Example: `docker kill centos_bash`.

**When to Use `docker kill`**:  
Use `docker kill` if a container is unresponsive to `docker stop` (e.g., the main process is stuck in a loop and ignores `SIGTERM`). However, this can lead to data loss or corruption if the process doesn’t get a chance to clean up.

#### Verifying the Container’s State
After stopping a container, it remains on your system in the `Exited` state. You can see it with:

```bash
docker ps -a
```
To restart it later, use:

```bash
docker start centos_bash
```
This will bring the container back to the `Up` state, running the same `/bin/bash` process.

#### Resource Cleanup
Stopping a container doesn’t remove it. If you want to free up space, you can remove stopped containers with:

```bash
docker rm centos_bash
```
Or remove all stopped containers with:

```bash
docker container prune
```

### Flags for docker stop

Now, let’s look at the flags for the docker stop command, which we discussed in detail earlier. This command has a few options to control how a container is stopped.

|Option|Description|
|---|---|
|-s, --signal|Specifies the signal to send to the container’s main process instead of the default SIGTERM. Example: docker stop --signal SIGINT centos_bash to send a SIGINT signal (similar to pressing Ctrl+C).|
|-t, --time|Sets the timeout (in seconds) to wait after sending the initial signal (default SIGTERM) before sending a SIGKILL. Default is 10 seconds. Example: docker stop -t 20 centos_bash waits 20 seconds before forcefully killing the container.|

**Additional Insight on docker stop Flags**:

- The --signal flag is useful if your application responds to a specific signal for graceful shutdown (e.g., SIGINT or SIGHUP). However, most applications are designed to handle SIGTERM, which is why it’s the default.
- The --time flag is critical for applications that need extra time to shut down cleanly. For example, a database container might need time to flush data to disk, so you might use docker stop -t 30 to give it 30 seconds before a SIGKILL is sent.

---

## Understanding `docker wait` and Its Flags

Let’s explore the `docker wait` command, its purpose, and how it can be used in managing Docker containers. Following that, I’ll provide tables detailing the flags for both `docker wait` and `docker stop`, as requested, to give you a clear overview of their options.

### What is `docker wait`?

The `docker wait` command is a utility in Docker that allows you to block (or wait) until a specified container stops, then retrieve its exit code. This is particularly useful in scripts or automation workflows where you need to wait for a container to finish its task before proceeding with the next step. When the container stops—either naturally (e.g., its main process exits) or manually (e.g., via `docker stop`)—`docker wait` returns the exit code of the container’s main process.

**Syntax**:
```bash
docker wait [CONTAINER...]
```

- You can specify one or more container names or IDs.
- The command will block until all specified containers have stopped, then print their exit codes in the order they were provided.

#### How It Works
- **Blocking Behavior**: When you run `docker wait`, your terminal (or script) will pause until the container stops. If the container is already stopped, `docker wait` returns immediately with the exit code.
- **Exit Code**: The exit code reflects the status of the container’s main process. For example:
  - `0`: The process exited successfully.
  - `137`: The container was forcefully stopped with `SIGKILL` (common with `docker stop` if the process doesn’t exit gracefully).
  - Other codes: Depend on the application (e.g., `1` often indicates a general error).

#### Example Scenario

![[3.18.1_img-1.png]]
In our output, we started a container named `nginx_stop` using the `nginx:latest` image:

```bash
docker run -d --name nginx_stop nginx:latest
```
- This command starts the `nginx_stop` container in detached mode (`-d`).
- The container runs the default command for the `nginx:latest` image, which is typically `nginx -g 'daemon off;'`, starting the Nginx web server in the foreground.
- The container’s ID is `aa9fb7fbe5bf...752a5a372367f`, as shown in the output.

Next, we ran `docker wait` on this container:

```bash
docker wait nginx_stop
```

Then, in a separate command, we stopped the container with:

```bash
docker stop -t 5 nginx_stop
```
- This sends a `SIGTERM` signal to the Nginx process, giving it 5 seconds to shut down gracefully before sending a `SIGKILL`.

**What Happens**:
- The `docker wait nginx_stop` command blocks, waiting for the `nginx_stop` container to stop.
- When you run `docker stop -t 5 nginx_stop`, Docker sends a `SIGTERM` to the Nginx process. Nginx is designed to handle `SIGTERM` gracefully—it closes open connections and shuts down cleanly, usually within a second or two.
- Since Nginx exits quickly (well before the 5-second timeout), Docker doesn’t need to send a `SIGKILL`. The container stops, and `docker wait` unblocks, returning the exit code.

**Output**:
```
0
```
- The exit code `0` indicates that the Nginx process exited successfully after receiving the `SIGTERM` signal.

**Why This Behavior?**:
- Nginx is well-behaved when it comes to signal handling. It responds to `SIGTERM` by performing a clean shutdown, which is why the container stops almost immediately.
- The `docker wait` command captures this exit code, making it useful for scripts where you need to confirm that a container has stopped and check its exit status.

#### Use Case with `docker stop`
If you stop a container manually, `docker wait` can help you capture the exit code. For example, using the `centos_bash` container (ID `36964d2e17c8` from your output):

1. In one terminal, run:
```bash
docker wait centos_bash
```
   This will block and wait for `centos_bash` to stop.

2. In another terminal, stop the container:
```bash
docker stop centos_bash
```
   As we discussed earlier, this sends a `SIGTERM` to the `/bin/bash` process, which exits immediately, stopping the container.

3. Back in the first terminal, `docker wait` will unblock and return the exit code, likely `0`, since `/bin/bash` exited cleanly.

#### Additional Insight: Multiple Containers
You can wait for multiple containers at once:

```bash
docker wait centos_bash short_task
```
- `docker wait` will block until both containers stop.
- It returns the exit codes in the order the containers were listed, one per line. For example:
```
0
0
```

**Practical Tip**:  
`docker wait` is especially useful in CI/CD pipelines or scripts where you need to ensure a container has finished its task (e.g., a batch job) before proceeding. For example, you might wait for a container to process data, then use its exit code to determine if the next step should run.

### Flags for `docker wait`

The `docker wait` command is straightforward and has minimal options. Here’s a table of its available flags:

| Option           | Description                                                                                                                                                                                          |
| ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `-f`, `--format` | Formats the output using a Go template. Useful for scripting to extract the exit code in a specific format. Example: `docker wait --format '{{.ExitCode}}' centos_bash` to print just the exit code. |
|                  |                                                                                                                                                                                                      |

**Note**:  
- The `--format` flag is not commonly used since `docker wait` already outputs the exit code in a simple format. However, it can be handy if you’re integrating the output into a larger script and need to parse it in a specific way.
- There are no other flags for `docker wait`, as its functionality is intentionally simple.

---

## Exploring `docker start` and `docker restart`: Differences and Flags

Let’s dive into the `docker start` and `docker restart` commands, which are essential for managing the lifecycle of Docker containers. I’ll explain how `docker start` works, clarify its behavior with the provided flags, and compare it thoroughly with `docker restart`. Additionally, I’ll provide tables listing the flags for both commands to give you a clear reference.

### Understanding `docker start`

The `docker start` command is the counterpart to `docker stop`. While `docker stop` halts a running container, `docker start` brings a stopped container back to life, transitioning it from the `Exited` state to the `Up` state. It restarts the container’s main process (the one defined by the `CMD` or `ENTRYPOINT` in the image) using the same configuration the container was created with.

**Syntax**:
```bash
docker start [OPTIONS] CONTAINER [CONTAINER...]
```

You can start one or more containers by specifying their names or IDs. For example, if you have a stopped container named `centos_bash` (from your earlier outputs), you can start it with:

```bash
docker start centos_bash
```

#### Flags for Interacting with Streams
The `docker start` command has flags that let you interact with the container’s streams (standard output, standard error, and standard input) as it starts:

- **`-a`, `--attach`**: Attaches your terminal to the container’s standard output (stdout) and standard error (stderr). This means you’ll see the container’s logs in real-time as it starts, but you won’t be connected to standard input (stdin) by default.  
  **Example**:
  ```bash
  docker start -a centos_bash
  ```
  If `centos_bash` runs `"/bin/bash"`, you’ll see any output or errors from the Bash process, but you won’t be able to send input (e.g., type commands) because stdin isn’t attached.

- **`-i`, `--interactive`**: When used with `-a`, this flag also attaches your terminal to the container’s standard input (stdin), allowing you to interact with the container’s main process.  
  **Example**:
  ```bash
  docker start -ai centos_bash
  ```
  Now, you’re fully attached to `centos_bash`—you can see stdout/stderr and send input to the Bash shell (e.g., type commands like `ls` or `pwd`).

**Clarification on `docker start -a` vs. `docker attach`**:  
The text mentions that the only difference between `docker start -a` and `docker attach` is that `docker start -a` doesn’t attach to stdin. This is mostly accurate, but let’s add some nuance:
- `docker start -a` starts the container and then attaches to its stdout/stderr. If the container was already running, `docker start` will return an error (`Error: Container already started`).
- `docker attach` doesn’t start the container—it only attaches to an already running container’s streams. By default, `docker attach` connects to all three streams (stdin, stdout, stderr) unless you use flags like `--no-stdin`.
- So, the key difference is in their purpose: `docker start -a` is for starting a stopped container and optionally attaching, while `docker attach` is for attaching to a container that’s already running.

**Additional Insight**:  
If you use `docker start -a` on a container that produces a lot of output (e.g., a web server logging requests), your terminal will display that output in real-time. However, if the container’s main process doesn’t produce output (e.g., a daemon that logs to a file), you might not see anything unless you use `docker logs` afterward.

### Flags for `docker start`

Here’s a table listing all the flags available for the `docker start` command:

| Option              | Description                                                                                     |
|---------------------|-------------------------------------------------------------------------------------------------|
| `-a`, `--attach`    | Attaches your terminal to the container’s stdout and stderr, allowing you to see the container’s output as it starts. Does not attach to stdin unless combined with `-i`. Example: `docker start -a centos_bash`. |
| `--detach-keys`     | Specifies a key sequence to detach from the container after attaching (used with `-a`). Overrides the default detach sequence (e.g., `Ctrl+P, Ctrl+Q`). Example: `docker start --detach-keys="ctrl-x,ctrl-x" -a centos_bash`. |
| `-i`, `--interactive` | When used with `-a`, attaches your terminal to the container’s stdin, enabling interaction with the container’s main process. Example: `docker start -ai centos_bash` to interact with a Bash shell. |

### Understanding `docker restart`

The `docker restart` command combines the functionality of stopping and starting a container into a single operation. It stops the container (if it’s running) and then immediately starts it again, effectively restarting the container’s main process with the same configuration.

**Syntax**:
```bash
docker restart [OPTIONS] CONTAINER [CONTAINER...]
```

**Example**:
```bash
docker restart centos_bash
```
- This stops the `centos_bash` container (if it’s running) by sending a `SIGTERM` to its main process, waits for it to stop, and then starts it again.

### Flags for `docker restart`

Here’s a table listing all the flags available for the `docker restart` command:

| Option              | Description                                                                                     |
|---------------------|-------------------------------------------------------------------------------------------------|
| `-s`, `--signal`    | Specifies the signal to send to the container’s main process when stopping it, instead of the default `SIGTERM`. Example: `docker restart --signal SIGINT centos_bash` to send a `SIGINT` signal. |
| `-t`, `--time`      | Sets the timeout (in seconds) to wait after sending the initial signal (default `SIGTERM`) before sending a `SIGKILL` to forcefully stop the container. Default is 10 seconds. Example: `docker restart -t 20 centos_bash` waits 20 seconds before killing the container. |

### Comparison of `docker start` and `docker restart`

Here’s a table comparing `docker start` and `docker restart` across various aspects to highlight their differences clearly:

| Aspect              | `docker start`                                                                                  | `docker restart`                                                                                |
|---------------------|-------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------|
| **Purpose**         | Starts a stopped container (in the `Exited` state) and brings it to the `Up` state. If the container is already running, it returns an error (`Error: Container already started`). | Restarts a container, regardless of its state. Stops the container (if running) and then starts it again. Works on both running and stopped containers. |
| **Effect on State** | Transitions a container from `Exited` to `Up`. Does not affect a running container.             | Always performs a stop-then-start sequence. If running, the container is stopped and restarted; if stopped, it just starts. |
| **Use Case**        | Use when you want to bring a stopped container back online without interrupting its previous state (e.g., after a `docker stop`). Example: `docker start centos_bash`. | Use to refresh a container’s state, such as reloading a service or recovering from a stuck process. Example: `docker restart nginx_attach` to restart a web server. |
| **Stream Interaction** | Supports `-a` and `-i` flags to attach to stdout, stderr, and optionally stdin as the container starts. Example: `docker start -ai centos_bash`. | Does not support attaching to streams during the restart. Use `docker attach` or `docker logs` afterward to see output. |
| **Signal Handling** | Doesn’t involve stopping, so no signals or timeouts are used.                                   | Stops the container first, sending a `SIGTERM` (or custom signal via `--signal`) and waiting for a timeout (default 10 seconds, adjustable with `-t`) before sending a `SIGKILL`. |
| **Impact on Running Containers** | Cannot be used on a running container—only for stopped containers.                        | Works on both running and stopped containers. If running, it interrupts the container; if stopped, it starts it. |
| **Example**         | `docker start -a centos_bash`: Starts a stopped container and attaches to its output. If already running, it errors. | `docker restart -t 5 centos_bash`: Stops the container (waiting up to 5 seconds) and restarts it, even if it’s already running. |

### Differences Between `docker start` and `docker restart`

Let’s break down the differences between `docker start` and `docker restart` to make their purposes and behaviors crystal clear:

- **Purpose**:
  - **`docker start`**: Starts a stopped container (in the `Exited` state) and brings it back to the `Up` state. It does not stop the container first, so if the container is already running, you’ll get an error: `Error: Container already started`.
  - **`docker restart`**: Restarts a container, regardless of its current state. If the container is running, it stops it first (by sending a `SIGTERM` and waiting for a timeout) and then starts it again. If the container is already stopped, it simply starts it.

- **Effect on Container State**:
  - **`docker start`**: Only transitions a container from `Exited` to `Up`. It doesn’t affect a running container.
  - **`docker restart`**: Always performs a stop-then-start sequence. If the container is running, it will be stopped and restarted, which means the main process is terminated and restarted, potentially interrupting any ongoing tasks.

- **Use Case**:
  - **`docker start`**: Use this when you have a stopped container that you want to bring back online without interrupting its previous state (e.g., after a manual `docker stop` or a system reboot). For example, if `centos_bash` is stopped, `docker start centos_bash` will restart the `/bin/bash` process.
  - **`docker restart`**: Use this when you need to refresh a container’s state, such as reloading a service or recovering from a stuck process. For example, if `nginx_attach` (from your earlier outputs) is running but not responding, `docker restart nginx_attach` will stop and restart the Nginx process, potentially resolving the issue.

- **Stream Interaction**:
  - **`docker start`**: Supports the `-a` and `-i` flags to attach to the container’s streams (stdout, stderr, and optionally stdin) as it starts. This lets you see the container’s output or interact with it immediately.
  - **`docker restart`**: Does not support attaching to streams during the restart process. You’ll need to use `docker attach` or `docker logs` afterward to see the container’s output.

- **Signal Handling and Timeout**:
  - **`docker start`**: Doesn’t involve stopping the container, so it doesn’t deal with signals or timeouts.
  - **`docker restart`**: Since it stops the container first, it sends a `SIGTERM` (or a custom signal via `--signal`) and waits for a timeout (default 10 seconds, adjustable with `-t`) before sending a `SIGKILL`. This is the same behavior as `docker stop`.

- **Impact on Running Containers**:
  - **`docker start`**: Cannot be used on a running container—it’s only for stopped containers.
  - **`docker restart`**: Works on both running and stopped containers. If the container is running, it will be interrupted; if it’s stopped, it will simply start.

**Example to Illustrate the Difference**:
- Suppose `centos_bash` is stopped (`Exited` state). You run:
  ```bash
  docker start -a centos_bash
  ```
  This starts the container, and you see its output (e.g., any Bash output). If you try `docker start centos_bash` again while it’s running, you’ll get an error.
- Now, with the same container running, you run:
  ```bash
  docker restart -t 5 centos_bash
  ```
  This stops `centos_bash` (sending `SIGTERM`, waiting up to 5 seconds, then sending `SIGKILL` if needed) and then starts it again. The `/bin/bash` process is terminated and restarted, and the container is back in the `Up` state.

**Practical Tip**:  
If you need to restart a container but want to see its output immediately, you can combine `docker restart` with `docker attach`:
```bash
docker restart centos_bash && docker attach centos_bash
```
This restarts the container and then attaches to its streams, giving you a seamless way to monitor the restart process.
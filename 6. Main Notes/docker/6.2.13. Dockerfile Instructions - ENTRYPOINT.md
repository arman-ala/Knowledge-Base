# 6.2.13. Dockerfile Instructions - ENTRYPOINT

2025-07-10 05:00
Status: #DONE 
Tags: [[Docker]]

---
### Mastering the `ENTRYPOINT` Command in Dockerfile

#### Understanding the `ENTRYPOINT` Command with Simple Explanations

The `ENTRYPOINT` command in a Dockerfile is like setting the main game controller for our toy box that always starts the fun. Imagine we’re building a playhouse and decide that every time we enter, a special game console turns on automatically—that’s what `ENTRYPOINT` does. It’s the boss command that kicks off the action when our container starts, and we can tweak it with extra instructions if needed.

For someone new to this, think of it like plugging in your favorite video game system every time you walk into the playroom. The `ENTRYPOINT` is that system, and we can add new game levels (arguments) without changing the console. It’s more permanent than a suggestion, making it the go-to way to run our application.

Technically, the `ENTRYPOINT` instruction specifies the executable that will always run when a container starts, serving as the container’s main process (PID 1). It can be written in shell form or exec form and supports runtime arguments, with `CMD` providing default parameters. Let’s explore its details with examples.

#### Syntax and Usage of the `ENTRYPOINT` Command

The `ENTRYPOINT` command supports two forms: shell form and exec form. Here’s how it works with the specified images:

1. **Shell Form**
```
ENTRYPOINT go version
```
   This runs `go version` in a shell when the container starts, using the `alpine:latest` base. It’s like starting the playhouse with a quick check of our game version.

2. **Exec Form (Array)**
```
ENTRYPOINT ["/usr/local/go/bin/go", "version"]
```
   This executes the `go` binary directly with the `version` argument, offering precise control. It’s preferred for reliability.

3. **With `CMD` and Runtime Args**
```
   FROM go:1.24
   ENTRYPOINT ["/usr/local/go/bin/go", "run"]
   CMD ["/app/main.go"]
```
   - `FROM go:1.24` sets the base image with Go 1.24.
   - `ENTRYPOINT ["/usr/local/go/bin/go", "run"]` sets the entrypoint to run a Go program.
   - `CMD ["/app/main.go"]` provides the default argument, `/app/main.go`, to run a sample Go file.
   - **Build**: 
```
docker build -t mygoapp:v1 .
```
   - **Run with Default**: 
```
docker run mygoapp:v1
```
This runs `/app/main.go` by default.
   - **Run with Runtime Args**: 
```
docker run mygoapp:v1 /app/test.go
```
This overrides the `CMD` argument, running `/app/test.go` instead.

4. **Overridden `ENTRYPOINT`**
```
FROM nginx:latest
ENTRYPOINT ["/usr/sbin/nginx"]
CMD ["-g", "daemon off;"]
```
   - `FROM nginx:latest` sets the base image for an Nginx web server.
   - `ENTRYPOINT ["/usr/sbin/nginx"]` starts the Nginx server.
   - `CMD ["-g", "daemon off;"]` adds default arguments to run Nginx in the foreground.
   - **Build**: 
```
docker build -t mynginx:v1 .
```
   - **Run with Default**: 
```
docker run -p 8080:80 mynginx:v1
```
This starts Nginx on port 80 inside the container, mapped to host port 8080.
   - **Run with Overridden `ENTRYPOINT`**: 
```
docker run -p 8080:80 --entrypoint /bin/sh mynginx:v1
```     
This overrides `ENTRYPOINT` to run a shell, ignoring the Nginx start.

#### ELI5 Linux Concept Explanation

Linux might sound like a big toy factory, but think of it as the workshop where our playhouse is built. Inside, we have a main toy robot (the process) that starts working when we open the door. The `ENTRYPOINT` command tells that robot what job to do first—like turning on the lights or starting a game. We can give it extra instructions later, but the robot always follows the main job unless we change it.

Technically, `ENTRYPOINT` defines the primary executable within the Linux-based container runtime, executed as PID 1. It leverages the container’s filesystem and environment, with the exec form ensuring direct execution without shell interpretation. Runtime arguments modify its behavior, and overriding via `--entrypoint` alters the default process, managed by Docker’s container initialization system.

#### Key Rules and Behaviors

- **Primary Executable**: `ENTRYPOINT` is the container’s main process, always executed unless overridden.
- **Forms**:
  - **Shell Form** (e.g., `ENTRYPOINT go version`): Runs in a shell, less common due to shell dependency.
  - **Exec Form** (e.g., `ENTRYPOINT ["/usr/local/go/bin/go", "run"]`): Preferred for control and compatibility.
- **Runtime Args**: `CMD` provides default arguments, overridable with `docker run` (e.g., `docker run mygoapp:v1 /app/test.go`).
- **Override**: Use `--entrypoint` to replace `ENTRYPOINT` at runtime (e.g., `--entrypoint /bin/sh`).
- **Single Instance**: Only the last `ENTRYPOINT` applies, like the final game controller setting.

#### Differences Between `CMD` and `ENTRYPOINT`

| Feature                | `CMD`                              | `ENTRYPOINT`                       |
|-------------------------|------------------------------------|------------------------------------|
| **Purpose**            | Sets the default command or arguments at startup. | Defines the primary executable at startup. |
| **Default Value**      | None (must be explicitly set, e.g., `CMD ["/bin/sh"]`). | None (must be explicitly set, e.g., `ENTRYPOINT ["/bin/sh"]`). |
| **Override**           | Overridden by `docker run` arguments. | Overridden with `--entrypoint` at runtime. |
| **Behavior**           | Ignored if runtime command provided. | Always executes unless overridden. |
| **Forms**              | Shell (`CMD command`) or exec (`CMD ["executable", "param"]`). | Shell (`ENTRYPOINT command`) or exec (`ENTRYPOINT ["executable", "param"]`). |
| **Use with Args**      | Acts as default args for `ENTRYPOINT` if present. | Accepts runtime args to modify behavior. |
| **Layer Impact**       | No layer created.                  | No layer created.                  |
| **Example**            | `CMD ["/app/main.go"]`             | `ENTRYPOINT ["/usr/local/go/bin/go", "run"]` |
| **Use Case**           | Flexible default startup option.   | Fixed application entry point.     |

#### Build and Runtime Process

- **Build for Go Example**:
  ```
  docker build -t mygoapp:v1 .
  ```
- **Run with Default**:
  ```
  docker run mygoapp:v1
  ```
  Executes `/usr/local/go/bin/go run /app/main.go`.
- **Run with Runtime Args**:
  ```
  docker run mygoapp:v1 /app/test.go
  ```
  Runs `/usr/local/go/bin/go run /app/test.go`.
- **Build for Nginx Example**:
  ```
  docker build -t mynginx:v1 .
  ```
- **Run with Default**:
  ```
  docker run -p 8080:80 mynginx:v1
  ```
  Starts Nginx with default args.
- **Run with Overridden `ENTRYPOINT`**:
  ```
  docker run -p 8080:80 --entrypoint /bin/sh mynginx:v1
  ```
  Opens a shell instead of Nginx.

#### Additional Considerations

- **Best Practices**: Use exec form for `ENTRYPOINT` to avoid shell issues. Pair with `CMD` for arg flexibility.
- **Security**: Ensure the entry point is secure, as it runs with container privileges.
- **Docker Compose**: `ENTRYPOINT` aligns with `command` in `docker-compose.yml` for consistent orchestration.

#### Key Takeaways

- The `ENTRYPOINT` command sets the primary executable, supporting shell or exec form, with `CMD` as default args.
- It accepts runtime args and can be overridden with `--entrypoint`, offering dynamic control.
- Compared to `CMD`, `ENTRYPOINT` is the fixed entry point, while `CMD` is a flexible default.
- Proper usage ensures robust container startup tailored to our applications.

By mastering the `ENTRYPOINT` command, we can define reliable, customizable startup behaviors for our Docker containers.
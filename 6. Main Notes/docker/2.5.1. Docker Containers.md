# Containers Introduction
A Docker container can be thought of as a running instance of a Docker image, much like how an object is an instance of a class in programming languages. In object-oriented programming, a class defines the blueprint or template, and objects are created from that blueprint to perform specific tasks. Similarly, in the context of Docker, an image serves as the blueprint, and a container is the active, operational version of that blueprint.

A container encapsulates everything needed to run an application: the code, runtime, libraries, and dependencies, all bundled together in an isolated environment. This isolation ensures that the application inside the container runs consistently, regardless of where the container is deployed—whether on a developer's laptop, a testing server, or a production environment.

The similarity between a container and an object lies in their roles as functional, dynamic entities. Just as an object brings a class to life by holding state and behavior, a container activates the static definition of an image by executing the application it represents. Each container operates independently, even if multiple containers are created from the same image, much like how different objects can be instantiated from the same class but maintain their own unique states.

In summary, a Docker container is a live, isolated runtime environment created from an image, analogous to how an object is a live, functional entity created from a class. Both concepts emphasize reusability, consistency, and isolation in their respective domains.

---

![[2.5.1_containers.png]]

1. **The Birth of a Docker Container** :
    
    - When a Docker container is created, it initially copies all the information from its corresponding image. This means that the container starts with the same read-only layers as the image.
2. **The Readable/Writable Layer** :
    
    - The only difference between an image and a container is the addition of a thin readable/writable (R/W) layer on top of the existing image layers. This layer allows users to make changes within the container, but these changes are stored only in this R/W layer, leaving the original image layers untouched.
3. **Creating Multiple Containers from One Image** :
    
    - Multiple containers can be created from a single image. Each container operates like an independent process, and any changes made within a container are stored only in its specific R/W layer. This feature ensures that creating multiple containers from one image does not cause conflicts, and each container functions independently.
4. **Image Information** :
    
    - In the provided diagram, the different layers of an image and container are illustrated. The image layers are read-only, and each container adds a thin R/W layer on top of them. Additionally, the sizes of the layers (such as 0B, 1.895KB, 194.5KB, and 188.1MB) indicate the size of each layer. The base image in this example is "ubuntu:15.04."

This layered structure makes containers lightweight and efficient because the shared image layers are reused across containers, and only the changes are stored in each container’s R/W layer.
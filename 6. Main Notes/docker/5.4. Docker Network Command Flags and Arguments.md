# 5.4. Docker Network Command Flags and Arguments
2025-08-09 10:49
Status: #DONE
Tags: [[Docker]]

---

# Docker Network Command Flags and Arguments: The Complete Guide

Hey there, fellow tech explorers! If you've ever dabbled in Docker, you know that containers are the superheroes of modern development, spinning up apps in isolated environments faster than you can say "microservices." But here's the thing: containers don't just run in a vacuum—they need to talk to each other, to databases, to APIs, and sometimes even to the big bad internet. That's where Docker's `network` command swoops in, acting like the ultimate network traffic controller. In this post, I'm diving deep into what Docker networking is, why it matters, and how you can wield its power like a pro. Buckle up, because we're about to unravel the magic behind container connectivity!

## Why Docker Networking Matters

Before we get into the nitty-gritty, let’s talk about why networking in Docker is such a big deal. Containers are designed to be lightweight and portable, but they’re useless if they can’t communicate. Whether you’re running a web app that needs to connect to a database, orchestrating a swarm of services, or securing a sensitive workload, Docker’s networking capabilities ensure your containers play nicely together. The `docker network` command is your Swiss Army knife for creating, managing, and troubleshooting these connections.

Docker offers several network drivers—think of them as blueprints for how containers interact. From the default `bridge` network for simple setups to `overlay` for multi-host orchestration, each driver serves a specific purpose. Add in features like custom subnets, IPv6 support, and internal-only networks, and you’ve got a toolkit that’s as flexible as it is powerful. But with great power comes… well, a bit of complexity. That’s why I’ve put together this guide, complete with practical examples, to help you navigate the `docker network` command like a seasoned DevOps wizard.

## The `docker network` Command: Your Networking Superpower

The `docker network` command is the gateway to managing how containers communicate. It comes with a handful of subcommands—`create`, `connect`, `disconnect`, `inspect`, `ls`, `prune`, and `rm`—each with its own set of flags and arguments. Think of these subcommands as tools in your networking toolbox, and the flags as the settings that fine-tune their behavior. Below, I’ll break down each subcommand, explain what it does, and share real-world scenarios to show why it’s useful. I’ve also included a detailed reference table at the end for quick lookups.

### 1. Creating Networks with `docker network create`

Let’s start with the foundation: creating a network. The `create` subcommand lets you define a custom network tailored to your needs. Want a network that’s completely isolated from the outside world? Or one that supports IPv6 for cutting-edge apps? This is where you make it happen.

- **Why it’s useful**: Custom networks give you control over how containers communicate. For example, you can create an internal network for a database and backend service to talk securely without exposing them to the internet.
- **Key flags**:
    - `--driver` (or `-d`): Choose the network type, like `bridge` (default for single-host setups), `overlay` (for Swarm or multi-host), or `macvlan` (for direct hardware access).
    - `--subnet` and `--gateway`: Define the IP range and gateway for precise IP management.
    - `--internal`: Lock down the network to prevent external access, perfect for sensitive workloads.
    - `--ipv6`: Enable IPv6 for containers that need it.
    - `--attachable`: Allow containers to join the network manually, even in Swarm setups.

**Real-world example**: Imagine you’re building a microservices app with a frontend, backend, and database. You want the backend and database to communicate on a private network with no internet access. You’d run:

```bash
docker network create --internal --subnet 172.20.0.0/16 private_backend
```

This creates a network called `private_backend` with a custom subnet, ensuring the containers are isolated and secure.

### 2. Connecting Containers with `docker network connect`

Once you’ve got a network, you need to hook up your containers to it. That’s where `connect` comes in. This subcommand lets you attach a running or stopped container to a network, giving it access to other containers on that network.

- **Why it’s useful**: You can dynamically adjust a container’s connectivity without restarting it. For instance, you might connect a web server to a new network to access a different database.
- **Key flags**:
    - `--alias`: Assign a DNS-friendly name for the container, so others can reach it by name (e.g., `web1`).
    - `--ip` or `--ip6`: Assign a specific IP address for precise control.

**Real-world example**: Suppose you have a container `web_app` that needs to join the `private_backend` network to talk to a database. You’d run:

```bash
docker network connect --alias web1 private_backend web_app
```

Now, the database container can reach `web_app` by the alias `web1` via DNS resolution, making communication seamless.

### 3. Disconnecting Containers with `docker network disconnect`

Sometimes, you need to cut ties. The `disconnect` subcommand removes a container from a network, effectively isolating it from other containers on that network.

- **Why it’s useful**: This is great for troubleshooting or reconfiguring network setups without deleting the network or container.
- **Key arguments**: Just specify the network and container names or IDs.

**Real-world example**: If `web_app` no longer needs to access the database on `private_backend`, you can disconnect it:

```bash
docker network disconnect private_backend web_app
```

This keeps your network clean and ensures containers only connect where necessary.

### 4. Inspecting Networks with `docker network inspect`

Curious about what’s going on under the hood? The `inspect` subcommand spills all the details about a network, from its driver and subnet to the containers attached and their IP addresses.

- **Why it’s useful**: Inspecting a network helps you debug connectivity issues or verify configurations.
- **Key flags**:
    - `--format`: Customize the output with Go templates for scripting.
    - `--verbose`: Get low-level driver details (mostly for advanced users).

**Real-world example**: To check which containers are on `private_backend` and their IPs, run:

```bash
docker network inspect private_backend
```

This outputs a JSON object with everything you need to know, like container IDs, IP addresses, and network settings.

### 5. Listing Networks with `docker network ls`

Need a quick overview of all your networks? The `ls` subcommand lists every network on your system, showing their names, IDs, drivers, and scope.

- **Why it’s useful**: It’s a fast way to see what networks exist, especially when managing multiple projects.
- **Key flags**:
    - `--filter`: Narrow down the list by driver, name, or label.
    - `--no-trunc`: Show full network IDs without truncation.
    - `--quiet` (or `-q`): Get just the IDs for scripting.

**Real-world example**: To see only bridge networks, run:

```bash
docker network ls --filter driver=bridge
```

This helps you quickly identify networks for single-host setups.

### 6. Cleaning Up with `docker network prune`

Over time, unused networks can pile up, cluttering your system. The `prune` subcommand sweeps away networks that aren’t connected to any containers.

- **Why it’s useful**: Keeps your Docker environment tidy and frees up resources.
- **Key flags**:
    - `--force` (or `-f`): Skip the confirmation prompt.
    - `--filter`: Prune networks based on criteria, like age or labels.

**Real-world example**: To remove all unused networks older than a day, run:

```bash
docker network prune --filter "until=24h"
```

This is a lifesaver for keeping your Docker host lean and mean.

### 7. Removing Networks with `docker network rm`

For a more targeted cleanup, the `rm` subcommand deletes specific networks by name or ID.

- **Why it’s useful**: When you’re done with a project or testing a setup, you can remove networks you no longer need.
- **Key arguments**: Specify one or more network names/IDs.

**Real-world example**: To delete `private_backend` and another network `old_network`, run:

```bash
docker network rm private_backend old_network
```

Just make sure no containers are still attached, or Docker will complain!

## Common Use Cases and Pro Tips

Now that we’ve covered the commands, let’s look at some real-world scenarios where Docker networking shines:

- **Microservices Architecture**: Create a `bridge` network for each service tier (e.g., frontend, backend, database). Use `--internal` for the database network to keep it secure.
- **Multi-Host Deployments**: Use the `overlay` driver with Docker Swarm to connect containers across multiple hosts. The `--attachable` flag lets you add containers manually.
- **IP Management**: Assign specific IPs with `--ip` or `--ip-range` to avoid conflicts in complex setups.
- **Troubleshooting**: Use `inspect` to debug connectivity issues or `ls --filter` to find misconfigured networks.
- **Security**: Disable Inter-Container Communication (ICC) with `-o com.docker.network.bridge.enable_icc=false` for extra isolation.

**Pro tip**: Always name your networks descriptively (e.g., `app_frontend`, `db_private`) and use `--label` to add metadata like `env=prod`. This makes managing networks much easier, especially in large projects.

## Challenges and Gotchas

Docker networking is powerful, but it’s not without quirks. Here are a few things to watch out for:

- **Default Bridge Limitations**: The default `bridge` network doesn’t support DNS resolution by container name. Always create custom networks for better control.
- **IP Conflicts**: If you specify a `--subnet` that overlaps with your host’s network, you’ll run into connectivity issues. Plan your IP ranges carefully.
- **Swarm Scope**: Some flags, like `--attachable`, are only relevant in Swarm mode. Double-check your environment before using them.
- **Performance**: The `overlay` driver can introduce latency in high-traffic setups. Test thoroughly in production-like environments.

## Reference Table: Docker Network Flags and Arguments

Here’s a comprehensive table summarizing all the flags and arguments for `docker network` and its subcommands. Use it as a quick reference when you’re in the trenches!

|**Subcommand**|**Flag/Argument**|**Description**|**Example**|
|---|---|---|---|
|**create**|`--attachable`|Makes the network attachable, allowing containers to join it even if managed by external services (e.g., Docker Swarm). Useful for hybrid setups.|`docker network create --attachable my_network`  <br>Creates a network `my_network` that containers can attach to manually.|
||`-d, --driver`|Specifies the network driver to use (e.g., `bridge`, `host`, `overlay`, `macvlan`, `none`). Defaults to `bridge` if not set.|`docker network create -d macvlan my_macvlan`  <br>Creates a `macvlan` network named `my_macvlan`.|
||`--gateway`|Sets the gateway IP address for the network. Must align with the subnet specified.|`docker network create --gateway 172.18.0.1 --subnet 172.18.0.0/16 my_network`  <br>Creates a network with a gateway at `172.18.0.1`.|
||`--internal`|Restricts the network to internal use, preventing external connectivity (e.g., no internet access). Enhances security for isolated workloads.|`docker network create --internal private_network`  <br>Creates an internal network with no external access.|
||`--ip-range`|Defines the range of IP addresses Docker can allocate to containers within the subnet. Helps manage IP assignments.|`docker network create --subnet 172.18.0.0/16 --ip-range 172.18.1.0/24 my_network`  <br>Restricts IP assignments to `172.18.1.0/24`.|
||`--ipam-driver`|Specifies the IP Address Management (IPAM) driver (e.g., `default`). Rarely changed unless using a custom IPAM plugin.|`docker network create --ipam-driver default my_network`  <br>Uses the default IPAM driver for `my_network`.|
||`--ipam-opt`|Sets custom options for the IPAM driver. Depends on the IPAM driver used (rarely needed).|`docker network create --ipam-opt key=value my_network`  <br>Passes a custom IPAM option (example is generic).|
||`--ipv6`|Enables IPv6 support for the network, allowing containers to use IPv6 addresses.|`docker network create --ipv6 --subnet 2001:db8::/64 my_network`  <br>Creates a network with IPv6 support.|
||`-o, --opt`|Sets driver-specific options (e.g., MTU size or parent interface). Varies by driver.|`docker network create -o com.docker.network.bridge.enable_icc=false my_network`  <br>Disables Inter-Container Communication (ICC).|
||`--subnet`|Defines the subnet for the network, specifying the IP range for containers.|`docker network create --subnet 172.18.0.0/16 my_network`  <br>Creates a network with the `172.18.0.0/16` subnet.|
||`--label`|Adds metadata labels to the network for organization or filtering.|`docker network create --label env=prod my_network`  <br>Adds a label `env=prod` to the network.|
||`<network-name>`|The name of the network to create (required argument).|`docker network create app_network`  <br>Creates a network named `app_network`.|
|**connect**|`--alias`|Assigns an alias to the container on the network, allowing other containers to reach it by this name via DNS.|`docker network connect --alias web1 my_network my_container`  <br>Connects `my_container` to `my_network` with alias `web1`.|
||`--ip`|Assigns a specific IPv4 address to the container on the network (must be within the network’s subnet).|`docker network connect --ip 172.18.0.10 my_network my_container`  <br>Assigns `172.18.0.10` to `my_container`.|
||`--ip6`|Assigns a specific IPv6 address to the container (if IPv6 is enabled).|`docker network connect --ip6 2001:db8::10 my_network my_container`  <br>Assigns an IPv6 address to `my_container`.|
||`--link`|Deprecated. Previously used to link containers directly (use networks instead).|Not recommended; no example provided.|
||`--link-local-ip`|Specifies link-local IPs for compatibility (rarely used).|`docker network connect --link-local-ip 169.254.1.1 my_network my_container`  <br>Adds a link-local IP (example is niche).|
||`<network>`|The name or ID of the network to connect the container to (required).|`docker network connect my_network my_container`  <br>Connects `my_container` to `my_network`.|
||`<container>`|The name or ID of the container to connect (required).|`docker network connect my_network my_container`  <br>Connects `my_container` to `my_network`.|
|**disconnect**|`<network>`|The name or ID of the network to disconnect the container from (required).|`docker network disconnect my_network my_container`  <br>Disconnects `my_container` from `my_network`.|
||`<container>`|The name or ID of the container to disconnect (required).|`docker network disconnect my_network my_container`  <br>Disconnects `my_container` from `my_network`.|
|**inspect**|`-f, --format`|Formats the output using a Go template for custom display. Useful for scripting.|`docker network inspect -f '{{.Name}}' my_network`  <br>Outputs only the network name (`my_network`).|
||`--verbose`|Shows detailed information, including low-level driver details (rarely needed).|`docker network inspect --verbose my_network`  <br>Displays verbose details about `my_network`.|
||`<network> [network...]`|The name(s) or ID(s) of the network(s) to inspect (required). Multiple networks can be specified.|`docker network inspect my_network bridge`  <br>Inspects both `my_network` and `bridge` networks.|
|**ls**|`-f, --filter`|Filters the list of networks based on conditions (e.g., `driver`, `name`, `label`).|`docker network ls -f driver=bridge`  <br>Lists only bridge networks.|
||`--no-trunc`|Prevents truncation of output, showing full network IDs.|`docker network ls --no-trunc`  <br>Shows full network IDs without truncation.|
||`-q, --quiet`|Displays only network IDs, useful for scripting.|`docker network ls -q`  <br>Outputs only the IDs of all networks.|
||`--format`|Formats the output using a Go template for custom display.|`docker network ls --format '{{.Name}}'`  <br>Lists only network names.|
|**prune**|`-f, --force`|Forces the removal of unused networks without prompting for confirmation.|`docker network prune -f`  <br>Removes all unused networks without asking.|
||`--filter`|Filters which unused networks to prune (e.g., by label or until a timestamp).|`docker network prune --filter "until=24h"`  <br>Removes unused networks older than 24 hours.|
|**rm**|`<network> [network...]`|The name(s) or ID(s) of the network(s) to remove (required). Multiple networks can be specified.|`docker network rm my_network old_network`  <br>Removes `my_network` and `old_network`.|
|**Global Flags**|`--help`|Displays help information for the `docker network` command or its subcommands.|`docker network create --help`  <br>Shows help for the `create` subcommand.|

## Wrapping Up

Docker’s `network` command is like the conductor of an orchestra, ensuring every container plays its part in perfect harmony. Whether you’re isolating workloads, orchestrating multi-host services, or just trying to keep your Docker host tidy, this command has you covered. By mastering `create`, `connect`, `inspect`, and the rest, you’ll unlock the full potential of containerized applications.

So, what’s next? Try creating a custom network for your next project, experiment with `--internal` for security, or use `inspect` to debug a tricky setup. And if you hit a snag, drop a comment below—I’d love to hear your questions or war stories from the Docker trenches. Until next time, keep containerizing and stay curious!
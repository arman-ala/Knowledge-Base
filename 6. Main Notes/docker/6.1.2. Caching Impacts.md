# 6.1.2. Caching Impacts

2025-08-09 19:43
Status: #DONE 
Tags: [[Docker]]

---
# Understanding Docker Layer Caching and Its Impact on CI/CD  

When building Docker images, we often see messages like `CACHED` in the logs. This indicates Docker is using layer caching—a powerful optimization that speeds up builds, especially in CI/CD pipelines.  

## ELI5: How Docker Caching Works  
Imagine building a toy car (your Docker image) with LEGO blocks (layers). If you rebuild it but only change the wheels (one layer), you don’t need to reassemble the entire car—just replace the wheels. Docker works similarly:  
1. Each instruction in a `Dockerfile` (e.g., `COPY`, `RUN`) creates a layer.  
2. If a layer hasn’t changed, Docker reuses its cached version instead of rebuilding it.  

In the provided logs:  
```
CACHED [1/2] FROM docker.io/library/alpine:latest
```  
Docker skipped rebuilding the base `alpine` layer because it was unchanged.  

---

![[6.2.4. Docker_Layer_Caching.png]]  

The diagram shows how Docker compares each layer’s checksum (like a fingerprint) to decide whether to reuse the cache or rebuild.  

---

## Technical Breakdown of the Logs  
1. **Layer Identification**:  
   - Docker assigns a unique hash to each layer based on its content and the previous layer’s hash.  
   - Example: The `COPY file1.txt file2.txt` command creates a new layer because file changes invalidate the cache.  

2. **Cache Invalidation**:  
   - Changing a file (e.g., `file1.txt`) or reordering `Dockerfile` instructions forces a rebuild from that point onward.  

3. **Exporting the Image**:  
   - The final step combines all layers (cached or new) into an image with a unique SHA256 hash:  
   ```sha256:753f83aab9735f3ae6ef12ed3704962d97ad44ba0e0a1c07be741a2e35b3d5d0```  

## Why Caching Matters in CI/CD  
1. **Faster Builds**:  
   - Reusing cached layers reduces build time. For example, dependency installation (`RUN apt-get install`) is skipped if unchanged.  

2. **Cost Efficiency**:  
   - CI/CD platforms charge by compute time. Caching minimizes redundant work, lowering costs.  

3. **Predictable Deployments**:  
   - Ensures consistency by rebuilding only modified layers, reducing "works on my machine" issues.  

## Optimizing Cache Usage  
1. **Order Instructions Strategically**:  
   Place frequently changed operations (e.g., `COPY`) late in the `Dockerfile` to preserve cache for stable layers. (The reason behind this action is to make caching possible. When a layer is rebuilt-means cache miss, layers after this layer will not check by cache whether they exist in cache or not)

2. **Leverage BuildKit**:  
   Enable Docker’s modern builder for advanced caching:  
``` 
DOCKER_BUILDKIT=1 docker build -t custom_alpine:v2 . 
```  

3. **Use CI/CD Cache Directives**:  
   In GitHub Actions, cache Docker layers with:  
```yaml
- name: Cache Docker layers  
  uses: actions/cache@v3  
  with:  
    path: /var/lib/docker  
    key: ${{ runner.os }}-docker-${{ hashFiles('**/Dockerfile') }}  
```  

## Key Takeaway  
Docker layer caching is like a smart LEGO builder—reusing unchanged parts to save time and effort. In CI/CD, this translates to faster iterations, lower costs, and more reliable deployments. By structuring `Dockerfile`s thoughtfully and leveraging tools like BuildKit, we can maximize cache efficiency. 
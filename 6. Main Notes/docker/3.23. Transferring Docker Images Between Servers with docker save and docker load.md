Let’s walk through the process of transferring a Docker image from one server (Server X) to another (Server Y), using the `docker save` and `docker load` commands. We’ll use the `mycent:v1` image you created with `docker commit` as an example, and we’ll explore the steps in detail, including how to handle potential issues like dangling images. Additionally, we’ll provide tables listing all the flags for both `docker save` and `docker load` to give you a complete reference.

### Step 1: Creating the Image with `docker commit`

![[3.23_img-1.png]]

We’ve already created an image named `mycent:v1` using the `docker commit` command:

```bash
docker commit centos_bash mycent:v1
```

This command creates a new image from the `centos_bash` container, and the output shows the new image ID: `sha256:a9a90f1a03ba2fa0fc20e824dd7cdcac9454e6cb1dea3ed4ec24bae32ce6410f`. When we list the images with:

```bash
docker images
```

We see `mycent:v1` in the list:

```
REPOSITORY    TAG       IMAGE ID         CREATED         SIZE
mycent        v1        a9a90f1a03ba     5 seconds ago   204MB
```

The image is now ready to be transferred from Server X to Server Y.

### Step 2: Saving the Image with `docker save`

Docker images are composed of multiple layers (as you mentioned), which are stored as a series of files on the host. To transfer an image between servers, we need to package these layers into a single file. This is where `docker save` comes in—it converts the image into a tar archive that we can easily move.

**Command**:
```bash
docker save -o arman_cent.tar.gz mycent:v1
```

- The `-o` flag specifies the output file (`arman_cent.tar.gz`).
- `mycent:v1` is the image we want to save.

**What Happens**:
- `docker save` bundles the `mycent:v1` image, including all its layers and metadata, into a single tar archive (`arman_cent.tar.gz`).
- We can verify the file exists with:
  ```bash
  ls
  ```
  Output:
  ```
  arman_cent.tar.gz  container_file.txt  Desktop  Downloads  host_file.txt  Music  Pictures  Public  Templates  Videos
  ```
  The `arman_cent.tar.gz` file is now in our current directory on Server X.

**Insight**:
- The `.tar.gz` extension indicates that the tar archive is compressed with gzip, which reduces the file size for easier transfer. If you omit the `.gz` (e.g., `docker save -o arman_cent.tar mycent:v1`), the output will be an uncompressed tar file, which will be larger.
- You can save multiple images into a single tar file by specifying multiple image names. For example:
  ```bash
  docker save -o multi_images.tar.gz mycent:v1 nginx:latest
  ```

### Step 3: Transferring the Tar File to Server Y

Now that we have the `arman_cent.tar.gz` file, we need to transfer it from Server X to Server Y. We can use a tool like `scp`, `rsync`, or even a manual file transfer (e.g., via a USB drive). For example, using `scp`:

```bash
scp arman_cent.tar.gz user@server-y:/path/to/destination
```

This copies the file to Server Y, where we can proceed with loading it.

### Step 4: Loading the Image with `docker load`

On Server Y, we use the `docker load` command to convert the tar archive back into a Docker image. This is essentially the reverse of `docker save`.

**Command**:
```bash
docker load < arman_cent.tar.gz
```

- The `<` operator redirects the contents of `arman_cent.tar.gz` into `docker load`.
- Alternatively, we could use the `-i` flag: `docker load -i arman_cent.tar.gz`.

**What Happens**:
- `docker load` extracts the image layers and metadata from `arman_cent.tar.gz` and imports them into Docker’s image store on Server Y.
- The output confirms the loading process:
```
620cac3ec47a: Loading layer 2.048kB/2.048kB
Loaded image: mycent:v1
```
- We can verify the image is now available on Server Y with:
  ```bash
  docker images
  ```
  Output:
```
REPOSITORY    TAG       IMAGE ID         CREATED         SIZE
mycent        v1        a9a90f1a03ba     7 minutes ago   204MB
```

### Step 5: Handling Dangling Images

Sometimes, after running `docker load`, the image might appear with `<none>` in the `REPOSITORY` and `TAG` columns, indicating a dangling image. This can happen if the image’s metadata (e.g., name or tag) isn’t properly set in the tar file, or if there’s a conflict with an existing image.

**Example of a Dangling Image**:
If we saw:

```
REPOSITORY    TAG       IMAGE ID         CREATED         SIZE
<none>        <none>    a9a90f1a03ba     7 minutes ago   204MB
```

We can fix this by tagging the image with `docker tag`:

**Command**:
```bash
docker tag a9a90f1a03ba mycent:v1
```

- This assigns the name `mycent` and tag `v1` to the image with ID `a9a90f1a03ba`.
- Running `docker images` again would show:

```
REPOSITORY    TAG       IMAGE ID         CREATED         SIZE
mycent        v1        a9a90f1a03ba     7 minutes ago   204MB
```

**Insight**:
- Dangling images often occur if the tar file contains an image that was saved without a proper name or tag, or if the image ID conflicts with an existing image on the target server.
- To clean up dangling images, you can use:

```bash
docker image prune
```

  This removes all images with `<none>` tags, freeing up space.

### Step 6: Cleaning Up (Optional)

After transferring the image, we might want to clean up on Server X. Since we no longer need the `mycent:v1` image on Server X, we can remove it:

**Command**:
```bash
docker rmi -f mycent:v1
```

- The `-f` flag forces the removal, even if the image is in use by a stopped container.
- Output:

```
Untagged: mycent:v1
Deleted: sha256:a9a90f1a03ba2fa0fc20e824dd7cdcac9454e6cb1dea3ed4ec24bae32ce6410f
Deleted: sha256:ac19727072d3dcae5298449db4aa9c10381f5190f5bc5271c5527c9cecefdf7c
```
- Running `docker images` confirms the image is gone:

```
REPOSITORY    TAG       IMAGE ID         CREATED         SIZE
nginx         latest    53a18edff809     7 weeks ago     192MB
hello-world   latest    74cc554e27dc     2 months ago    10.1kB
busybox       latest    ff7a7936e930     6 months ago    4.28MB
centos        latest    eebee6e3f44bd    3 years ago     204MB
```

### Flags for `docker save`

Here’s a table listing all the flags for the `docker save` command, along with their purposes:

| Option              | Description                                                                                     |
|---------------------|-------------------------------------------------------------------------------------------------|
| `-o`, `--output`    | Specifies the output file for the tar archive. If not set, the output is sent to stdout. Example: `docker save -o my_image.tar mycent:v1`. |
| `--quiet`, `-q`     | Suppresses the progress output during the save operation, making the command quieter. Useful for scripting. Example: `docker save -q -o my_image.tar mycent:v1`. |

**Insight**:
- If you omit the `-o` flag, `docker save` will output the tar archive to stdout, which you can redirect manually. For example:

```bash
docker save mycent:v1 > my_image.tar
```

- The `--quiet` flag is helpful in automated scripts where you don’t want verbose output cluttering the logs.

### Flags for `docker load`

Here’s a table listing all the flags for the `docker load` command, along with their purposes:

| Option              | Description                                                                                     |
|---------------------|-------------------------------------------------------------------------------------------------|
| `-i`, `--input`     | Specifies the input file to load the image from. If not set, the input is read from stdin. Example: `docker load -i my_image.tar`. |
| `--quiet`, `-q`     | Suppresses the progress output during the load operation, making the command quieter. Useful for scripting. Example: `docker load -q -i my_image.tar`. |

**Insight**:
- If you omit the `-i` flag, `docker load` expects the tar archive to be piped in via stdin. For example:

```bash
cat my_image.tar | docker load
```

- The `--quiet` flag reduces output, which is useful in CI/CD pipelines where you only care about the result, not the progress.

### Additional Insights

- **Compression**: The `.tar.gz` extension in your example indicates you compressed the tar file manually or used a tool to do so after `docker save`. The `docker save` command itself doesn’t compress the output—it creates a plain `.tar` file. To compress, you can use `gzip`:

```bash
docker save mycent:v1 | gzip > my_image.tar.gz
```

  On Server Y, you’d decompress before loading:
  
```bash
gunzip -c my_image.tar.gz | docker load
```

- **Transfer Efficiency**: For large images, compressing the tar file (as you did) is a good practice to save bandwidth during transfer. The `mycent:v1` image is 204MB, but compressing it might reduce the size significantly (e.g., to 100-150MB).
- **Image Layers**: When `docker save` creates the tar file, it includes all the image’s layers (as seen in the `docker load` output: `620cac3ec47a: Loading layer 2.048kB/2.048kB`). These layers are the same ones stored in `/var/lib/docker/overlay2` on the host, as we discussed earlier.
- **Security Note**: Be cautious when transferring images between servers, especially if the image comes from an untrusted source. Always verify the image’s integrity (e.g., using a checksum) and consider using Docker Content Trust to ensure the image hasn’t been tampered with.

By following these steps, we’ve successfully transferred the `mycent:v1` image from Server X to Server Y, and we’ve learned how to handle potential issues like dangling images along the way.

### Understanding Daemonless Containers in Docker

The concept of a "daemonless container" in Docker refers to the ability of containers to continue running even if the Docker daemon (`dockerd`) stops functioning for any reason. This is particularly useful in scenarios where the Docker daemon needs to be shut down for maintenance purposes, such as applying updates or restarting the Docker service. Despite the daemon being offline, containers can still provide services to end-users without interruption.

#### Enabling Live Restore for Daemonless Behavior
By default, this capability is not enabled in Docker. To allow containers to persist during `dockerd` downtime, the `live-restore` feature must be activated. To enable `live-restore`, you need to modify the Docker daemon configuration file located at `/etc/docker/daemon.json`. If the file does not exist, you can create it. Add the following configuration to the file:

```json
{"live-restore": true}
```

After saving the changes, reload the Docker service to apply the new configuration by running the command `systemctl reload docker`. This ensures that the Docker daemon picks up the updated settings without requiring a full restart of the service. With `live-restore` enabled, if the Docker daemon is stopped or crashes, running containers will remain active and continue to function. However, you won’t be able to manage the containers (e.g., start, stop, or inspect them) until the daemon is back online.

#### Limitations: Live Restore on Windows
It’s important to note that the `live-restore` feature is not supported on Windows. This functionality is specific to Linux-based Docker installations, as it relies on the underlying architecture of Linux container runtimes and the way Docker interacts with the Linux kernel. On Windows, containers are more tightly coupled with the Docker daemon, and stopping the daemon will typically cause containers to stop as well.

#### Docker Architecture: Role of Shim and Containerd
This daemonless behavior is made possible by Docker’s architecture, which decouples the container runtime from the Docker daemon to some extent. In Docker’s architecture:
- **containerd**: This is a container runtime that manages the lifecycle of containers at a lower level. It handles tasks like creating, starting, and stopping containers, as well as managing their namespaces and cgroups. `containerd` operates independently of `dockerd` and is designed to be a lightweight, standalone runtime.
- **shim**: The `containerd-shim` (or simply "shim") acts as an intermediary between `containerd` and the container’s runtime process. When a container is started, `containerd` spawns a `shim` process for each container. The `shim` becomes the parent of the container’s main process (PID 1 inside the container). The `shim` is responsible for keeping the container running even if `containerd` or `dockerd` restarts. It also manages the container’s standard input/output streams and ensures that the container process remains isolated from the lifecycle of the Docker daemon.

In this hierarchy, `containerd` is the parent of the `shim`, and the `shim` is the parent of the container’s main process. This layered architecture allows containers to remain running independently of the Docker daemon when `live-restore` is enabled.

#### Decoupling the Container Runtime from the Docker Daemon
The decoupling of the container runtime from the Docker daemon is a key evolution in Docker’s architecture, introduced to improve reliability and scalability. Historically, Docker used a monolithic architecture where the Docker daemon (`dockerd`) directly managed all container operations, including image management, networking, and container execution. However, this tight coupling meant that if `dockerd` crashed or was stopped, all containers would stop as well, leading to potential downtime for applications.

To address this, Docker adopted a more modular architecture by integrating `containerd` as its default container runtime starting with Docker 1.11 (released in 2016). `containerd` is a high-level container runtime that provides a stable and standardized interface for managing containers. It is designed to be independent of `dockerd`, allowing containers to persist even if the daemon is unavailable. Below `containerd`, a low-level runtime like `runc` (which implements the Open Container Initiative runtime specification) handles the actual creation and execution of containers by interacting with the Linux kernel to set up namespaces, cgroups, and other isolation mechanisms.

The decoupling process works as follows:
- When a container is started, `dockerd` communicates with `containerd` via a gRPC API over a Unix socket (typically `/run/containerd/containerd.sock`).
- `containerd` then delegates the container creation to `runc` via the `containerd-shim`. The `shim` process ensures that the container’s main process remains running independently of `containerd` and `dockerd`.
- If `dockerd` stops (e.g., for maintenance or due to a crash), `containerd` and the `shim` processes keep the container alive. This is because the container’s main process is not a direct child of `dockerd` but is instead managed by the `shim`, which is managed by `containerd`.

This architecture not only enables the `live-restore` feature but also allows Docker to support alternative runtimes (e.g., `cri-o` or `kata-containers`) and makes the system more resilient. For example, in Kubernetes environments, `containerd` can be used directly as the container runtime without involving `dockerd` at all, further reducing dependencies on the Docker daemon.

#### Additional Considerations
While `live-restore` ensures that containers remain running during daemon downtime, there are some limitations to be aware of:
- You cannot manage containers (e.g., start new containers, stop existing ones, or inspect their state) while the Docker daemon is down.
- If `containerd` itself crashes, the containers will stop, as `containerd` is still a critical component in the runtime stack. However, `containerd` is designed to be more lightweight and stable than `dockerd`, reducing the likelihood of such failures.
- The `live-restore` feature does not persist container state across a full system reboot. If the host system is restarted, all containers will stop unless a restart policy (e.g., `--restart=always`) is configured to automatically restart them when the system comes back online.

---

## It's Show Time!
we are going to run a daemonless **nginx** container.

```bash
docker run -d --name example_nginx nginx
```

run the command below to see if the nginx container is running in background: 
```bash
docker ps
```

![[3.5.1_result_run_nginx.png]]

let's stop docker and see if container can survive by its own:

```bash
systemctl stop docker
```

```bash
ps aux | grep nginx
```

containers are not working and they have been terminated.

![[3.5.1_result_ps_aux.png]]

when we start the docker engine again, the container won't be ran by its own and docker won't make it run (not as a default behavior).

```bash
systemctl start docker
```

![[3.5.1_result_start_docker.png]]

```bash
cd /etc/docker
vim daemon.json
```

then write this json in the daemon.json:
```json
{
	"live-restore": true
}
```

![[3.5.1_result_vim.png]]

```bash
docker info
```

as you can see, the live restore feature is not available yet.

![[3.5.1_result_docker_info.png]]

```bash
systemctl restart docker
```

after this command the feature must be enabled.

![[3.5.1_result_info.png]]

It's now activated!

```bash
docker run -d --name daemonless_nginx nginx
```

```bash
docker ps
```

```bash
systemctl stop docker
```

```bash
ps aux | grep nginx
```

![[3.5.1_result_daemonless.png]]

nginx container is running without docker being started.
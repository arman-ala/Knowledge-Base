# 6.2.8. Dockerfile Instructions - ARG

2025-08-09 10:49
Status: #DONE
Tags: [[Docker]]

---

### Mastering the `ARG` Command in Dockerfile

#### Understanding the `ARG` Command with Simple Explanations

The `ARG` command in a Dockerfile is like giving our toy box a secret code that we can change before building it. Imagine we’re making a playhouse and want to decide the color of the walls (e.g., blue or red) each time we build it—we use `ARG` to set that changeable code. Unlike a fixed rule, this code only works during the building process and disappears once the playhouse is ready, unless we save it with another trick.

For someone new to this, think of `ARG` as a magic word we whisper to the builder before starting work. We can say, “Use blue paint today,” and the builder follows it while constructing, but the playhouse doesn’t remember the word after it’s done—unless we write it down somewhere else.

Technically, the `ARG` instruction defines a variable that users can pass at build time using the `docker build` command with the `--build-arg` flag. These variables are available only during the build process and are not persisted in the runtime environment unless assigned to an `ENV` variable. Let’s explore its details with a practical approach.

#### Syntax and Usage of the `ARG` Command

The `ARG` command sets a variable with an optional default value. Here’s how it works based on the context:

1. **Basic `ARG` with Default Value**
   ```
   ARG BUILD_VERSION=1.0
   ```
   This defines `BUILD_VERSION` with a default value of `1.0`. It’s like setting “blue” as the default paint color, but we can change it if we want.

2. **Using `ARG` in Build**
   ```
   FROM alpine:latest
   ARG BUILD_DATE=2025-07-09
   LABEL "build.date"=$BUILD_DATE
   COPY test.txt /dir1
   ```
   - `FROM alpine:latest` sets the base image, like choosing a pre-built playhouse kit.
   - `ARG BUILD_DATE=2025-07-09` defines `BUILD_DATE` with today’s date (10:45 AM CEST on Wednesday, July 09, 2025) as the default.
   - `LABEL "build.date"=$BUILD_DATE` uses the `BUILD_DATE` variable in the label.
   - `COPY test.txt /dir1` copies a file, unaffected by `ARG`.

   We build it with:
   ```
   docker build -t myapp:v1 --build-arg BUILD_DATE=2025-07-10 .
   ```
   This overrides `BUILD_DATE` to `2025-07-10`, updating the label accordingly.

3. **Multiple `ARG` Definitions**
   ```
   ARG APP_NAME=myapp
   ARG APP_VERSION=1.0
   ENV APP_NAME=$APP_NAME
   ```
   - `ARG APP_NAME=myapp` and `ARG APP_VERSION=1.0` define two variables with defaults.
   - `ENV APP_NAME=$APP_NAME` persists `APP_NAME` into the runtime environment.
   - `APP_VERSION` remains build-time only unless assigned to an `ENV`.

#### Key Rules and Behaviors

- **Build-Time Only**: `ARG` variables are available only during the build process. They’re like temporary instructions the builder forgets after finishing the playhouse.
- **Default Values**: If no value is provided via `--build-arg`, the default is used. It’s a fallback, like having a backup paint color.
- **Overriding**: Users can override defaults with `docker build --build-arg VAR=value`, offering flexibility.
- **Persistence**: To keep a variable at runtime, we must assign it to an `ENV` variable. Otherwise, it’s lost after the build.

#### ELI5 Linux Concept Explanation

Linux might sound like a big word, but think of it as a super-organized toy factory where our playhouse is built. The factory has workers (commands) who follow our instructions. The `ARG` command is like giving a worker a note with a changeable task, like “paint with color X,” but the note gets thrown away once the playhouse is done—unless we tell another worker to remember it.

Technically, `ARG` operates within the build environment of the Docker image, which is based on the Linux kernel in this case (alpine). It allows parameterization of the build process, leveraging the shell environment to substitute variables, but its scope is limited to the build context and does not persist in the container’s runtime environment unless explicitly persisted via `ENV`.

#### Comparison of `ARG` and `ENV`

| Feature                | `ARG`                              | `ENV`                              |
|------------------------|------------------------------------|------------------------------------|
| **Scope**              | Available only during build time.  | Persists in build and runtime environments. |
| **Default Value**      | Supports optional default (e.g., `ARG VAR=value`). | No default unless set explicitly.  |
| **Override**           | Overridden with `--build-arg` at build time. | Overridden with `-e` at runtime or build time with `--build-arg` if persisted. |
| **Persistence**        | Not persisted unless assigned to `ENV`. | Persisted in the image and container. |
| **Use Case**           | Parameterizes build process (e.g., version, date). | Configures runtime behavior (e.g., paths, settings). |
| **Visibility**         | Not visible in `docker run` unless persisted. | Visible in `docker run` and `docker inspect`. |
| **Example**            | `ARG BUILD_DATE=2025-07-09`        | `ENV APP_PATH=/app`                |

#### Additional Considerations

- **Security**: Avoid passing sensitive data (e.g., passwords) via `ARG` unless secured, as build arguments can be logged. It’s like not shouting secret codes in the factory.
- **Build Caching**: Changing an `ARG` value invalidates the cache for that layer and beyond, ensuring a fresh build. It’s like re-painting the playhouse when the color changes.
- **Best Practices**: Use descriptive names (e.g., `BUILD_VERSION`) and document their purpose to keep our team on the same page.

#### Key Takeaways

- The `ARG` command defines build-time variables with optional defaults, allowing customization via `--build-arg`.
- It’s temporary unless persisted with `ENV`, making it ideal for build parameters like dates or versions.
- Compared to `ENV`, `ARG` is build-specific, while `ENV` handles runtime configuration.
- Proper usage enhances flexibility and maintainability in our Docker image builds.

By mastering the `ARG` command, we can create dynamic, efficient Docker images tailored to our build needs.
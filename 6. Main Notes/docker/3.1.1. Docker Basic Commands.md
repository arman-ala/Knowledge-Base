### **Docker Commands and Their Outputs**

| **Command**                              | **Output/Explanation**                                                                                                                                                                                                                       |
| ---------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`docker --version`**                   | Displays the installed Docker version (e.g., `Docker version 28.0.1`). [[#docker --version \| link]]                                                                                                                                         |
| **`docker version`**                     | Provides detailed information about the Docker Client and Server (Daemon), including versions, API compatibility, Go version, Git commit hashes, and runtime components (`containerd`, `runc`, `docker-init`). [[#docker version \| link]]   |
| **`docker info`**                        | Displays system-wide information about Docker, including the number of containers/images, storage driver, logging driver, cgroup settings, security options, and host system details (OS, kernel, CPUs, memory). [[#**docker info**\| link]] |
| **`docker pull hello-world`**            | Pulls the `hello-world` image from Docker Hub, showing progress (e.g., "Pulling from library/hello-world", "Digest", "Status"). [[#**docker pull hello-world**\| link]]                                                                      |
| **`docker images` or `docker image ls`** | Lists all locally available Docker images with details: `REPOSITORY`, `TAG`, `IMAGE ID`, `CREATED`, and `SIZE`. For example: `hello-world latest 74cc54e27dc4 7 weeks ago 10.1kB`. [[#**docker images** or **docker image ls** \| link]]     |
| **`docker run hello-world`**             | Executes the `hello-world` container, displaying a welcome message confirming that Docker is working correctly. [[#**docker run hello-world**\| link]]                                                                                       |
| **`docker ps`**                          | The `docker ps` command lists the currently running Docker containers on your system. [[3.1.1. Docker Basic Commands#**docker ps**\| link]]                                                                                                  |

---

## **docker --version**

```
docker --version
```

![[3.1.1_version_result.png]]

## **docker version**

```bash
docker version
```

![[3.1.1_result_version_2.png]]

Let's break down the output of the `docker version` command line by line and explain each component in detail. This output provides information about both the **Docker Client** and the **Docker Server (Daemon)**, as well as related components like `containerd`, `runc`, and `docker-init`.

---

### **Client: Docker Engine - Community**

### **1. Version: 28.0.1**
- This indicates the version of the **Docker Client**. The client is the user-facing tool that interacts with the Docker Daemon.
- In this case, the Docker Client version is `28.0.1`.

### **2. API version: 1.48**
- The **API version** specifies the version of the Docker REST API that the client is using to communicate with the Docker Daemon.
- Here, the API version is `1.48`. This ensures compatibility between the client and the server.

### **3. Go version: go1.23.6**
- Docker is written in the **Go programming language**. This line specifies the version of Go used to build the Docker binary.
- In this case, the Go version is `1.23.6`.

### **4. Git commit: 068a01e**
- This is the **Git commit hash** of the source code used to build the Docker Client. It helps identify the exact version of the codebase.
- Here, the commit hash is `068a01e`.

### **5. Built: Wed Feb 26 10:42:13 2025**
- This indicates the date and time when the Docker Client binary was built.
- In this case, it was built on `February 26, 2025, at 10:42:13`.

### **6. OS/Arch: linux/amd64**
- This specifies the **operating system** (`linux`) and **architecture** (`amd64`, i.e., 64-bit Intel/AMD processors) for which the Docker Client was built.
- Here, the client is designed to run on a Linux machine with an AMD64 architecture.

### **7. Context: default**
- Docker supports multiple **contexts**, which allow you to switch between different Docker environments (e.g., local Docker daemon, remote Docker daemon, Kubernetes clusters).
- The `default` context means the client is currently configured to communicate with the local Docker daemon.

---

### **Server: Docker Engine - Community**

This section provides details about the **Docker Daemon**, which is the server-side component responsible for managing Docker objects.

### **1. Engine:**
- This block contains information about the Docker Engine (Daemon).

#### **a. Version: 28.0.1**
- The **version of the Docker Daemon** matches the client version (`28.0.1`). This ensures compatibility between the client and server.

#### **b. API version: 1.48 (minimum version 1.24)**
- The **API version** of the Docker Daemon is `1.48`, matching the client's API version.
- The `(minimum version 1.24)` indicates the oldest API version that the daemon supports. Clients using older API versions may not be compatible.

#### **c. Go version: go1.23.6**
- Like the client, the daemon is also built using Go, and here the Go version is `1.23.6`.

#### **d. Git commit: bbd0a17**
- This is the **Git commit hash** of the source code used to build the Docker Daemon.
- The commit hash is `bbd0a17`, which differs from the client's commit hash because the client and daemon are separate binaries.

#### **e. Built: Wed Feb 26 10:40:33 2025**
- This indicates the date and time when the Docker Daemon binary was built.
- The daemon was built slightly earlier than the client (`10:40:33` vs. `10:42:13`).

#### **f. OS/Arch: linux/amd64**
- The daemon is also built for `Linux` on `AMD64` architecture.

#### **g. Experimental: false**
- Docker has an **experimental mode** that enables cutting-edge features that are not yet stable.
- Here, experimental mode is disabled (`false`).

---

### **Container Runtime Components**

Docker relies on several low-level components to manage containers. These are listed below:

### **1. containerd:**
- **containerd** is a core container runtime that manages the lifecycle of containers (e.g., starting, stopping, and supervising containers).
- It acts as an intermediary between Docker and the lower-level runtime (`runc`).

#### **a. Version: 1.7.25**
- The version of `containerd` is `1.7.25`.

#### **b. GitCommit: bcc810d6b9066471b0b6fa75f557a15a1cbf31bb**
- This is the **Git commit hash** of the `containerd` source code.

### **2. runc:**
- **runc** is the low-level container runtime that actually creates and runs containers. It implements the OCI (Open Container Initiative) runtime specification.

#### **a. Version: 1.2.4**
- The version of `runc` is `1.2.4`.

#### **b. GitCommit: v1.2.4-0-g6c52b3f**
- This is the **Git commit hash** of the `runc` source code.

### **3. docker-init:**
- **docker-init** is a lightweight init system used inside containers to handle process management (e.g., reaping zombie processes).
- It ensures that containers have a proper process hierarchy.

#### **a. Version: 0.19.0**
- The version of `docker-init` is `0.19.0`.

#### **b. GitCommit: de40ad0**
- This is the **Git commit hash** of the `docker-init` source code.

---

### **Summary of Key Points**

1. **Docker Client and Daemon Versions Match**: Both the client and daemon are running version `28.0.1`, ensuring compatibility.
2. **API Compatibility**: The API version is `1.48`, with backward compatibility for older clients (minimum version `1.24`).
3. **Built with Go**: Both the client and daemon are built using Go version `1.23.6`.
4. **Container Runtimes**:
   - **containerd** (`1.7.25`) manages container lifecycles.
   - **runc** (`1.2.4`) is the low-level runtime that creates and runs containers.
   - **docker-init** (`0.19.0`) handles process management inside containers.
5. **Experimental Features Disabled**: Experimental mode is turned off (`false`).

---

### **Why Is This Information Useful?**

Understanding this output helps in:
- Verifying compatibility between the Docker Client and Daemon.
- Debugging issues related to API mismatches or runtime components.
- Ensuring that the correct versions of Docker and its dependencies are installed.
- Identifying the exact build and source code versions for troubleshooting or auditing purposes.

---

### **Final Answer**

The `docker version` output provides detailed information about the **Docker Client**, **Docker Daemon**, and related runtime components (`containerd`, `runc`, and `docker-init`). Each component's version, build details, and configuration are listed to ensure compatibility, traceability, and transparency in the Docker environment.

## **docker info**

```
docker info
```

![[3.1.1_result_info.png]]

Let’s break down the output of the `docker info` command line by line and then explain why there is separate client and server information when using the `docker version` or `docker info` commands.

---

### **Line-by-Line Explanation of `docker info`**

### **1. Client: Docker Engine - Community**
This section provides details about the **Docker Client**.

#### **a. Version: 28.0.1**
- The version of the **Docker Client** is `28.0.1`. This indicates the version of the CLI tool used to interact with Docker.

#### **b. Context: default**
- The **context** defines which Docker environment the client is currently targeting (e.g., local Docker daemon, remote Docker daemon, or Kubernetes cluster).
- Here, the context is set to `default`, meaning the client is communicating with the local Docker daemon.

#### **c. Debug Mode: false**
- Indicates whether the Docker Client is running in debug mode.
- Debug mode provides detailed logs for troubleshooting. In this case, it is disabled (`false`).

#### **d. Plugins:**
- Lists the plugins installed on the Docker Client. Plugins extend the functionality of Docker.

	1. buildx: Docker Buildx (Docker Inc.)
	- **buildx** is a plugin for advanced Docker builds (e.g., multi-platform builds).
	- **Version**: `v0.21.1`
	- **Path**: `/usr/libexec/docker/cli-plugins/docker-buildx`

	2. compose: Docker Compose (Docker Inc.)
	- **compose** is a plugin for defining and running multi-container applications using `docker-compose.yml` files.
	- **Version**: `v2.33.1`
	- **Path**: `/usr/libexec/docker/cli-plugins/docker-compose`

---

### **2. Server:**
This section provides details about the **Docker Daemon** and its configuration.

#### **a. Containers: 0**
- Total number of containers managed by the Docker Daemon.
- **Running**: `0` (no containers are currently running).
- **Paused**: `0` (no containers are paused).
- **Stopped**: `0` (no containers are stopped).

#### **b. Images: 0**
- Total number of Docker images available locally. Here, there are no images (`0`).

#### **c. Server Version: 28.0.1**
- The version of the **Docker Daemon** matches the client version (`28.0.1`).

#### **d. Storage Driver: overlay2**
- The storage driver used by Docker to manage container layers. `overlay2` is the default and most widely used driver.
- **Backing Filesystem**: `xfs` (the underlying filesystem used by the host).
- **Supports d_type**: `true` (indicates that the filesystem supports directory entry types, which is required for `overlay2`).
- **Using metacopy**: `false` (metadata copying is disabled for performance reasons).
- **Native Overlay Diff**: `true` (native diff calculation is enabled for efficiency).
- **userxattr**: `false` (user extended attributes are not enabled).

### **e. Logging Driver: json-file**
- The logging driver determines how container logs are stored and managed. Here, Docker uses the `json-file` driver, which writes logs to JSON files.

#### **f. Cgroup Driver: systemd**
- The cgroup (control group) driver manages resource allocation for containers. Here, Docker uses the `systemd` driver, which integrates with the host's `systemd` service manager.

#### **g. Cgroup Version: 2**
- Indicates the version of cgroups used by the system. `Cgroup Version 2` is the latest and unified version.

#### **h. Plugins:**
- Lists the plugins available on the Docker Daemon.

	1. Volume: local
		- The `local` volume plugin is used for managing local volumes.

	2. Network: bridge, host, ipvlan, macvlan, null, overlay
		- These are network drivers supported by Docker:
			- `bridge`: Default network driver for isolated container networks.
			- `host`: Shares the host's network stack with the container.
			-  `ipvlan`: Allows fine-grained control over IP addresses.
			-  `macvlan`: Assigns a unique MAC address to each container.
			- `null`: Disables networking for the container.
			- `overlay`: Used for multi-host networking in Swarm mode.

	3. Log: awslogs, fluentd, gcplogs, gelf, journald, json-file, local, splunk, syslog
		- Supported logging drivers for container logs.

#### **i. Swarm: inactive**
- Indicates whether Docker Swarm (a native clustering and orchestration tool) is active. Here, it is `inactive`.

#### **j. Runtimes: runc, io.containerd.runc.v2**
- Lists the container runtimes supported by Docker:
  - `runc`: The default runtime for running containers.
  - `io.containerd.runc.v2`: A runtime provided by `containerd`.

#### **k. Default Runtime: runc**
- The default runtime used by Docker is `runc`.

#### **l. Init Binary: docker-init**
- The init binary (`docker-init`) is used inside containers to handle process management.

#### **m. containerd version: bcc810d6b9066471b0b6fa75f557a15a1cbf31bb**
- The version of `containerd`, the container runtime responsible for managing container lifecycles.

#### **n. runc version: v1.2.4-0-g6c52b3f**
- The version of `runc`, the low-level runtime that creates and runs containers.

#### **o. init version: de40ad0**
- The version of `docker-init`, the lightweight init system used inside containers.

#### **p. Security Options:**
- Lists security-related features enabled in Docker.

##### **i. seccomp**
- **seccomp** (secure computing mode) restricts the system calls a container can make.
- **Profile**: `builtin` (uses the default seccomp profile).

##### **ii. cgroupns**
- Indicates that cgroup namespaces are enabled for isolation.

#### **q. Kernel Version: 6.12.0-59.el10.x86_64**
- The version of the Linux kernel running on the host.

#### **r. Operating System: CentOS Stream 10 (Coughlan)**
- The operating system running on the host.

#### **s. OSType: linux**
- The type of operating system (`linux`).

#### **t. Architecture: x86_64**
- The architecture of the host machine (`x86_64`, i.e., 64-bit Intel/AMD processors).

#### **u. CPUs: 2**
- The number of CPU cores available on the host.

#### **v. Total Memory: 1.633GiB**
- The total amount of memory available on the host.

#### **w. Name: localhost.localdomain**
- The hostname of the machine.

#### **x. ID: 5863c716-3af6-4702-94f6-f9772a6c7f42**
- A unique identifier for the Docker Daemon.

#### **y. Docker Root Dir: /var/lib/docker**
- The directory where Docker stores its data (e.g., images, containers, volumes).

#### **z. Debug Mode: false**
- Indicates whether the Docker Daemon is running in debug mode. Here, it is disabled (`false`).

#### **aa. Experimental: false**
- Indicates whether experimental features are enabled in the Docker Daemon. Here, they are disabled (`false`).

#### **ab. Insecure Registries:**
- Lists registries that do not require HTTPS or certificate validation.
- Here, insecure access is allowed for `::1/128` (IPv6 loopback) and `127.0.0.0/8` (IPv4 loopback).

#### **ac. Live Restore Enabled: false**
- Indicates whether live restore is enabled. When enabled, containers continue running even if the Docker Daemon restarts. Here, it is disabled (`false`).

---

### **Why Separate Client and Server Information?**

The `docker version` and `docker info` commands display separate client and server information because Docker follows a **client-server architecture**. Here’s why:

1. **Client-Server Separation**:
   - The **Docker Client** is a user-facing tool that sends commands to the **Docker Daemon** (server) via the REST API.
   - The **Docker Daemon** runs as a background service and manages Docker objects (images, containers, networks, etc.).

2. **Different Responsibilities**:
   - The **Client** handles user interaction (e.g., parsing commands like `docker run` or `docker build`).
   - The **Server** performs the actual work (e.g., creating containers, pulling images, managing resources).

3. **Flexibility**:
   - The client and server can run on different machines. For example, you can use a local Docker client to communicate with a remote Docker daemon.
   - This separation allows for distributed setups, such as managing Docker hosts in a data center or cloud environment.

4. **Version Compatibility**:
   - By displaying both client and server versions, you can verify compatibility between them. Mismatched versions may lead to errors or unexpected behavior.

5. **Debugging and Troubleshooting**:
   - Separate information helps identify issues. For example:
     - If the client is outdated, you might encounter API mismatches.
     - If the server has insufficient resources, containers may fail to start.

---

### **Final Answer**

The `docker info` command provides detailed information about the **Docker Client**, **Docker Daemon**, and the host system's configuration. The client and server information are displayed separately because Docker follows a **client-server architecture**, where the client interacts with the server (daemon) over a REST API. This separation ensures flexibility, scalability, and clear responsibility division between user interaction and container management.

## **docker pull hello-world**

```
docker pull hello-world
```

![[3.1.1_result_pull.png]]

Let’s break down the output of the `docker pull hello-world` command line by line and then explain why there is separate client and server information when using Docker commands.

---

#### **1. Using default tag: latest**
- When pulling an image without specifying a tag (e.g., `hello-world:latest`), Docker assumes the `latest` tag by default.
- Here, Docker informs you that it will pull the `latest` version of the `hello-world` image.

---

#### **2. latest: Pulling from library/hello-world**
- This indicates that Docker is pulling the `latest` tag of the `hello-world` image from the official Docker Hub repository (`library/hello-world`).
- The `library` namespace contains official images maintained by Docker.

---

#### **3. e6590344b1a5: Pull complete**
- This line shows the progress of downloading the image layers.
- Each image in Docker is composed of multiple layers, and each layer has a unique identifier (in this case, `e6590344b1a5`).
- The message "Pull complete" confirms that this specific layer has been successfully downloaded.

---

#### **4. Digest: sha256:7e1a4e2d11e2ac7a8c3f768d4166c2defeb09d2a750b010412b6ea13de1efb19**
- The **digest** is a cryptographic hash (SHA-256) of the image's content. It ensures the integrity of the image by verifying that the downloaded image matches the original image on Docker Hub.
- This digest can be used to verify the authenticity of the image or to pull a specific version of the image.

---

#### **5. Status: Downloaded newer image for hello-world:latest**
- This line confirms that the `hello-world:latest` image has been successfully downloaded.
- The term "newer image" indicates that the image pulled is more recent than any existing version of `hello-world:latest` on your system (if one existed).

---

#### **6. docker.io/library/hello-world:latest**
- This is the fully qualified name of the image, including:
  - **Registry**: `docker.io` (Docker Hub).
  - **Repository**: `library/hello-world`.
  - **Tag**: `latest`.

---

### **Why Is There Separate Client and Server Information in Docker?**

The separation of client and server information in Docker is rooted in its **client-server architecture**. Let’s explore why this separation exists and how it applies to the `docker pull` command:

---

#### **1. Client-Server Model**
- Docker operates in a **client-server model**, where:
  - The **Docker Client** is the user-facing tool (CLI) that sends commands to the **Docker Daemon** (server).
  - The **Docker Daemon** runs as a background service and performs the actual work, such as pulling images, creating containers, and managing resources.

---

#### **2. Role of the Client**
- The **Docker Client** is responsible for:
  - Parsing user input (e.g., `docker pull hello-world`).
  - Sending API requests to the Docker Daemon over a REST API.
  - Displaying responses from the daemon to the user.

In this case, when you run `docker pull hello-world`, the client formats the request and sends it to the daemon.

---

#### **3. Role of the Server (Daemon)**
- The **Docker Daemon** handles:
  - Fetching the image from the specified registry (e.g., Docker Hub).
  - Downloading and storing the image layers locally.
  - Managing Docker objects like images, containers, networks, and volumes.

For the `docker pull` command, the daemon communicates with Docker Hub to download the `hello-world` image and stores it in the local image cache.

---

#### **4. Why Separate Information?**
The separation of client and server information is crucial for several reasons:

##### **a. Flexibility**
- The client and server can run on different machines. For example:
  - A developer can use a local Docker client to interact with a remote Docker daemon running on a production server.
  - This allows for centralized management of Docker environments.

##### **b. Scalability**
- The Docker Daemon can manage multiple clients simultaneously, enabling teams to collaborate on containerized workflows.

##### **c. Security**
- The daemon runs with elevated privileges (e.g., root access) to manage system resources, while the client runs with user-level permissions.
- This separation minimizes security risks by isolating privileged operations.

##### **d. Debugging and Maintenance**
- By separating client and server information, it becomes easier to troubleshoot issues:
  - If the client fails, it might indicate a problem with the CLI or API communication.
  - If the server fails, it might indicate a problem with the daemon or host system.

---

### **How Does This Apply to `docker pull hello-world`?**

When you execute `docker pull hello-world`, the following happens:

1. The **Docker Client** parses the command and sends an API request to the **Docker Daemon**.
2. The **Docker Daemon** communicates with Docker Hub to locate the `hello-world:latest` image.
3. The daemon downloads the image layers and stores them locally.
4. The client receives updates from the daemon and displays progress messages (e.g., "Pulling from library/hello-world", "Pull complete").
5. Once the image is downloaded, the daemon notifies the client, which displays the final status (e.g., "Downloaded newer image for hello-world:latest").

This separation ensures that the client remains lightweight and focused on user interaction, while the daemon handles the heavy lifting of managing Docker objects and interacting with registries.

---

### **Final Answer**

The `docker pull hello-world` command demonstrates Docker's client-server architecture. The **Docker Client** sends a request to the **Docker Daemon**, which performs the actual work of downloading the image from Docker Hub. The separation of client and server information ensures flexibility, scalability, security, and ease of debugging. This architecture allows Docker to function efficiently in both local and distributed environments.

## **docker images** or **docker image ls**

```
docker images
```

```
docker image ls
```

![[3.1.1_result_images.png]]

The output from the `docker images` command lists the Docker images available on your system. Here's a line-by-line explanation:

1. **REPOSITORY**: The name of the image repository.

2. **TAG**: The tag associated with the image, which usually indicates the version or variant of the image.

3. **IMAGE ID**: The unique identifier for the image.

4. **CREATED**: The time elapsed since the image was created.

5. **SIZE**: The size of the image.

6. **hello-world latest 74cc54e27dc4 7 weeks ago 10.1kB**: This line provides details about the `hello-world` image.
   - **hello-world**: The name of the image repository.
   - **latest**: The tag associated with the image.
   - **74cc54e27dc4**: The unique identifier for the image.
   - **7 weeks ago**: The time elapsed since the image was created.
   - **10.1kB**: The size of the image.

8. **REPOSITORY TAG IMAGE ID CREATED SIZE**: These are the column headers for the image listing.

9. **hello-world latest 74cc54e27dc4 7 weeks ago 10.1kB**: This line provides the same details about the `hello-world` image as before.


### Latest Tag vs. Edge Tag

- **Latest Tag**: The `latest` tag typically refers to the most recent stable version of an image. It is the default tag used when no specific tag is provided.
- **Edge Tag**: The `edge` tag usually refers to the most recent, potentially unstable or experimental version of an image. It is often used for development and testing purposes.

### Unique Image IDs

- **Unique ID on Your System**: Each image on your system has a unique `IMAGE ID`, which is a SHA-256 hash of the image's content. This ensures that each image is uniquely identifiable on your local system.
- **Unique ID in Docker Hub and Their Registry**: Images on Docker Hub and other registries also have unique identifiers. When you pull an image from a registry, the `IMAGE ID` on your system should match the one in the registry, ensuring consistency and integrity.

### **flags**

| command | result                      |
| ------- | --------------------------- |
| -a      | shows all of the images.    |
| -q      | shows only th IDs of images |


In summary, the `docker images` command lists the images available on your Docker host, with each image having a unique identifier. The `latest` tag generally indicates the most recent stable version, while the `edge` tag may indicate a more experimental version. Each image has a unique ID both on your local system and in Docker registries.

## **docker run hello-world**

```
docker run hello-world
```

![[3.1.1_result_run_hello.png]]

![[3.1.1_run_diagram.png]]
### How Docker Runs a Container: A Simple Journey

Let’s walk through what happens when you type the `docker run` command to start a container. It’s like sending Docker on a little mission to get your app up and running! The diagram breaks this down into a clear sequence of steps, and we’ll explore each one to see how Docker gets the job done.

#### Step-by-Step: The `docker run` Process

#### *Step 1: You Start with `docker run`*
When you run the `docker run` command, you’re telling Docker to launch a container using a specific image. This kicks off the whole process—Docker springs into action to make it happen.

#### *Step 2: Docker Checks Your Computer for the Image*
First, Docker looks on your computer to see if the image you need is already there.
- **Is it installed?** Docker checks its local storage (a cache of images on your machine) to find the image.
  - If **yes**, it skips ahead to creating the container (Step 4).
  - If **no**, it moves to the next step to find the image elsewhere.

#### *Step 3: Docker Searches Docker Hub*
If the image isn’t on your computer, Docker heads to **Docker Hub**, a cloud-based library where tons of Docker images are stored and shared.
- **Is it on Docker Hub?** Docker searches for the image there.
  - If **yes**, Docker downloads the image to your computer.
  - If **no**, the process would stop here with an error (but the diagram assumes the image is found).

#### *Step 4: Docker Downloads and Installs the Image*
Once the image is found on Docker Hub, Docker pulls it down to your computer.
- **Docker downloads the image**: The image is saved locally so you can use it again later without downloading.
- **The image layers are installed on this computer**: Docker images are made up of layers (like stacked building blocks), and these layers are downloaded and stored on your machine.

#### *Step 5: Docker Creates and Starts the Container*
With the image now on your computer, Docker gets to work.
- **Docker creates a new container and starts the program**: Using the image as a blueprint, Docker builds a new container and launches the program inside it.
- **The container is running!** Success! Your container is now up and running, doing whatever task the image was designed for.

#### Why This Flow Matters
This process shows how Docker handles the `docker run` command: <mark style="background: #FFF3A3A6;">it first checks locally for the image, looks on Docker Hub if needed, downloads the image’s layers, and then creates and starts a new container</mark>. It’s a smooth, logical sequence that ensures your app gets running, whether the image is already on your machine or needs to be fetched from the cloud.

## Flags for `docker run` and Pre-Defined Environment Variables in Linux-Based Containers

Let’s break this down into two parts. First, I’ll provide a comprehensive table of all available flags for the `docker run` command, which is used to create and start a container. Then, I’ll list the pre-defined environment variables that are automatically set in a Linux-based container, also in a table format.

### Flags for `docker run`

The `docker run` command is one of the most versatile commands in Docker, allowing you to configure a container’s behavior in countless ways. Below is a table of all available flags for `docker run`, based on Docker’s official documentation and common usage as of March 31, 2025.

| Option                      | Description                                                                                                                                              |
| --------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `--add-host`                | Adds a custom host-to-IP mapping to the container’s `/etc/hosts` file. Format: `host:ip`. Example: `--add-host host1:192.168.1.100`.                     |
| `--annotation`              | Adds metadata annotations to the container. Example: `--annotation key=value`.                                                                           |
| `-a`, `--attach`            | Attaches to the container’s stdin, stdout, and/or stderr. Example: `--attach stdout` to attach to stdout only.                                           |
| `--blkio-weight`            | Sets the Block I/O weight (relative weight for I/O operations). Range: 10-1000. Default: 0 (no weighting). Example: `--blkio-weight 500`.                |
| `--blkio-weight-device`     | Sets Block I/O weight for a specific device. Format: `device:weight`. Example: `--blkio-weight-device /dev/sda:200`.                                     |
| `--cap-add`                 | Adds a Linux capability to the container. Example: `--cap-add NET_ADMIN` to allow network administration tasks.                                          |
| `--cap-drop`                | Drops a Linux capability from the container. Example: `--cap-drop SETUID` to prevent setting user IDs.                                                   |
| `--cgroup-parent`           | Specifies a custom cgroup parent for the container. Example: `--cgroup-parent /docker`.                                                                  |
| `--cgroupns`                | Sets the cgroup namespace mode (`host` or `private`). Example: `--cgroupns private`.                                                                     |
| `--cidfile`                 | Writes the container ID to a file. Example: `--cidfile /tmp/container_id`.                                                                               |
| `--cpu-period`              | Sets the CPU CFS (Completely Fair Scheduler) period in microseconds. Used with `--cpu-quota`. Example: `--cpu-period 50000`.                             |
| `--cpu-quota`               | Limits the CPU CFS quota in microseconds. Example: `--cpu-quota 25000` to limit the container to 25ms of CPU time per 100ms period.                      |
| `--cpu-rt-period`           | Sets the CPU real-time period in microseconds. Example: `--cpu-rt-period 1000000`.                                                                       |
| `--cpu-rt-runtime`          | Sets the CPU real-time runtime in microseconds. Example: `--cpu-rt-runtime 950000`.                                                                      |
| `--cpu-shares`              | Sets the CPU shares (relative weight) for the container. Default: 1024. Example: `--cpu-shares 512` to give the container half the default CPU priority. |
| `--cpus`                    | Limits the number of CPUs the container can use. Example: `--cpus 1.5` to allow 1.5 CPUs.                                                                |
| `--cpuset-cpus`             | Specifies which CPUs the container can use. Example: `--cpuset-cpus 0-1` to restrict to CPUs 0 and 1.                                                    |
| `--cpuset-mems`             | Specifies which memory nodes the container can use. Example: `--cpuset-mems 0` to restrict to memory node 0.                                             |
| `-d`, `--detach`            | Runs the container in detached mode (in the background). Example: `--detach`.                                                                            |
| `--detach-keys`             | Sets the key sequence to detach from a container when attached. Default: `Ctrl+P, Ctrl+Q`. Example: `--detach-keys "ctrl-x,ctrl-x"`.                     |
| `--device`                  | Adds a host device to the container. Format: `host-device:container-device[:permissions]`. Example: `--device /dev/snd:/dev/snd`.                        |
| `--device-cgroup-rule`      | Adds a rule for device access in the cgroup. Example: `--device-cgroup-rule "c 188:* rmw"`.                                                              |
| `--device-read-bps`         | Limits the read rate (bytes per second) from a device. Example: `--device-read-bps /dev/sda:1mb`.                                                        |
| `--device-read-iops`        | Limits the read rate (IO per second) from a device. Example: `--device-read-iops /dev/sda:1000`.                                                         |
| `--device-write-bps`        | Limits the write rate (bytes per second) to a device. Example: `--device-write-bps /dev/sda:1mb`.                                                        |
| `--device-write-iops`       | Limits the write rate (IO per second) to a device. Example: `--device-write-iops /dev/sda:1000`.                                                         |
| `--disable-content-trust`   | Disables content trust verification for the image. Default: `true`. Example: `--disable-content-trust=false`.                                            |
| `--dns`                     | Sets custom DNS servers for the container. Example: `--dns 8.8.8.8`.                                                                                     |
| `--dns-opt`, `--dns-option` | Sets DNS options for the container. Example: `--dns-opt use-vc`.                                                                                         |
| `--dns-search`              | Sets custom DNS search domains. Example: `--dns-search example.com`.                                                                                     |
| `--domainname`              | Sets the container’s domain name. Example: `--domainname mydomain.local`.                                                                                |
| `-e`, `--env`               | Sets environment variables in the container. Example: `--env MY_VAR=value`.                                                                              |
| `--env-file`                | Reads environment variables from a file. Example: `--env-file env.list`.                                                                                 |
| `--entrypoint`              | Overrides the image’s default `ENTRYPOINT`. Example: `--entrypoint /bin/sh`.                                                                             |
| `--expose`                  | Exposes a port or range of ports without publishing to the host. Example: `--expose 8080`.                                                               |
| `--gpus`                    | Grants access to GPUs. Example: `--gpus all` to allow access to all GPUs.                                                                                |
| `--group-add`               | Adds the container to additional groups. Example: `--group-add audio`.                                                                                   |
| `--health-cmd`              | Sets a command to check the container’s health. Example: `--health-cmd "curl -f http://localhost                                                         |
| `--health-interval`         | Sets the interval between health checks. Example: `--health-interval 30s`.                                                                               |
| `--health-retries`          | Sets the number of retries before marking the container as unhealthy. Example: `--health-retries 3`.                                                     |
| `--health-start-period`     | Sets the initialization period before health checks start. Example: `--health-start-period 40s`.                                                         |
| `--health-timeout`          | Sets the timeout for a health check to complete. Example: `--health-timeout 5s`.                                                                         |
| `--hostname`                | Sets the container’s hostname. Example: `--hostname mycontainer`.                                                                                        |
| `-i`, `--interactive`       | Keeps stdin open, allowing interaction with the container. Example: `--interactive`.                                                                     |
| `--init`                    | Runs an init process (like `tini`) inside the container to handle PID 1 responsibilities (e.g., reaping zombie processes). Example: `--init`.            |
| `--ip`                      | Sets a static IPv4 address for the container (requires a custom network). Example: `--ip 172.18.0.22`.                                                   |
| `--ip6`                     | Sets a static IPv6 address for the container (requires a custom network). Example: `--ip6 2001:db8::33`.                                                 |
| `--ipc`                     | Sets the IPC (Inter-Process Communication) mode for the container (`host`, `private`, or `shareable`). Example: `--ipc host`.                            |
| `--isolation`               | Sets the container isolation technology (e.g., `default`, `hyperv`, `process` on Windows). Example: `--isolation hyperv`.                                |
| `--kernel-memory`           | Limits the kernel memory for the container (deprecated in newer Docker versions). Example: `--kernel-memory 50m`.                                        |
| `-l`, `--label`             | Adds metadata labels to the container. Example: `--label com.example.key=value`.                                                                         |
| `--label-file`              | Reads labels from a file. Example: `--label-file labels.txt`.                                                                                            |
| `--link`                    | Links the container to another container (legacy feature; use networks instead). Example: `--link other_container:alias`.                                |
| `--link-local-ip`           | Adds a link-local IP address for the container. Example: `--link-local-ip 169.254.1.1`.                                                                  |
| `--log-driver`              | Sets the logging driver for the container. Example: `--log-driver json-file`.                                                                            |
| `--log-opt`                 | Sets options for the logging driver. Example: `--log-opt max-size=10m` to limit log file size to 10MB.                                                   |
| `--mac-address`             | Sets the container’s MAC address. Example: `--mac-address 02:42:ac:11:00:02`.                                                                            |
| `-m`, `--memory`            | Limits the container’s memory usage. Example: `--memory 512m` to limit to 512MB.                                                                         |
| `--memory-reservation`      | Sets a soft memory limit (reservation). Example: `--memory-reservation 256m`.                                                                            |
| `--memory-swap`             | Sets the total memory limit, including swap. Example: `--memory-swap 1g` (set to `-1` for unlimited swap).                                               |
| `--memory-swappiness`       | Sets the container’s swappiness (0-100). Example: `--memory-swappiness 60`.                                                                              |
| `--mount`                   | Attaches a mount to the container (more flexible than `-v`). Example: `--mount type=bind,source=/host/path,target=/container/path`.                      |
| `--name`                    | Assigns a name to the container. Example: `--name my_container`.                                                                                         |
| `--network`                 | Connects the container to a network. Example: `--network my_network`.                                                                                    |
| `--network-alias`           | Adds a network-scoped alias for the container. Example: `--network-alias my_alias`.                                                                      |
| `--no-healthcheck`          | Disables any health checks defined in the image. Example: `--no-healthcheck`.                                                                            |
| `--oom-kill-disable`        | Disables the OOM (Out of Memory) killer for the container. Example: `--oom-kill-disable`.                                                                |
| `--oom-score-adj`           | Adjusts the container’s OOM score (range: -1000 to 1000). Example: `--oom-score-adj 500`.                                                                |
| `-p`, `--publish`           | Publishes a container’s port(s) to the host. Format: `host_port:container_port`. Example: `-p 8080:80`.                                                  |
| `-P`, `--publish-all`       | Publishes all exposed ports to random host ports. Example: `--publish-all`.                                                                              |
| `--pid`                     | Sets the PID namespace mode (`host` or `container:<name>`). Example: `--pid host`.                                                                       |
| `--pids-limit`              | Limits the number of PIDs in the container. Example: `--pids-limit 100`.                                                                                 |
| `--platform`                | Sets the platform for the image (e.g., for multi-architecture images). Example: `--platform linux/arm64`.                                                |
| `--privileged`              | Gives the container extended privileges (e.g., access to all devices). Example: `--privileged`.                                                          |
| `--pull`                    | Sets the pull policy for the image (`always`, `missing`, `never`). Example: `--pull always`.                                                             |
| `--read-only`               | Mounts the container’s root filesystem as read-only. Example: `--read-only`.                                                                             |
| `--restart`                 | Sets the restart policy for the container (`no`, `on-failure[:max-retries]`, `always`, `unless-stopped`). Example: `--restart on-failure:3`.             |
| `--rm`                      | Automatically removes the container when it exits. Example: `--rm`.                                                                                      |
| `--runtime`                 | Sets the runtime to use for the container (e.g., `runc`, `crun`). Example: `--runtime runc`.                                                             |
| `--security-opt`            | Sets security options (e.g., SELinux, AppArmor). Example: `--security-opt label=level:s0`.                                                               |
| `--shm-size`                | Sets the size of `/dev/shm` (shared memory). Example: `--shm-size 64m`.                                                                                  |
| `--sig-proxy`               | Proxies signals to the container (default: `true`). Example: `--sig-proxy=false`.                                                                        |
| `--stop-signal`             | Sets the signal to stop the container (default: `SIGTERM`). Example: `--stop-signal SIGINT`.                                                             |
| `--stop-timeout`            | Sets the timeout (in seconds) for stopping the container, overriding the image’s default. Example: `--stop-timeout 20`.                                  |
| `--storage-opt`             | Sets storage driver options. Example: `--storage-opt size=120G` (for `devicemapper`).                                                                    |
| `--sysctl`                  | Sets kernel parameters (sysctls) for the container. Example: `--sysctl net.ipv4.ip_forward=1`.                                                           |
| `-t`, `--tty`               | Allocates a pseudo-TTY for the container. Example: `--tty`.                                                                                              |
| `--tmpfs`                   | Mounts a tmpfs (temporary filesystem) in the container. Example: `--tmpfs /tmp:size=100m`.                                                               |
| `-u`, `--user`              | Sets the user (and optionally group) to run the container as. Format: `user[:group]`. Example: `--user 1000:1000`.                                       |
| `--ulimit`                  | Sets ulimit options for the container. Example: `--ulimit nofile=1024:1024`.                                                                             |
| `--userns`                  | Sets the user namespace mode (`host`, `private`). Example: `--userns host`.                                                                              |
| `-v`, `--volume`            | Binds a volume to the container. Format: `host_path:container_path[:ro]`. Example: `-v /host/data:/container/data`.                                      |
| `--volume-driver`           | Specifies the volume driver to use. Example: `--volume-driver local`.                                                                                    |
| `--volumes-from`            | Mounts volumes from another container. Example: `--volumes-from other_container`.                                                                        |
| `-w`, `--workdir`           | Sets the working directory inside the container. Example: `--workdir /app`.                                                                              |

**Additional Insight**:  
- Many of these flags (e.g., `--memory`, `--cpus`, `--ulimit`) are used to fine-tune resource limits and security settings, which are crucial for production environments.
- Flags like `--link` and `--kernel-memory` are considered legacy and may be deprecated in future Docker versions. For networking, use `--network` instead of `--link`.

### Pre-Defined Environment Variables in a Linux-Based Container

When you run a Linux-based container, Docker automatically sets several environment variables that provide information about the container’s runtime environment. These variables are available to the container’s main process and can be accessed using commands like `env` or `printenv` inside the container. Below is a table of the pre-defined environment variables in a typical Linux-based container (e.g., `centos:latest` or `nginx:latest`).

| Environment Variable | Description                                                                                     |
|----------------------|-------------------------------------------------------------------------------------------------|
| `HOSTNAME`           | The hostname of the container, set to the container’s ID (e.g., `7d1539239d41` for `centos_bash`). If you specify `--hostname`, that value overrides this. |
| `PATH`               | The default PATH for executable files, inherited from the image. Example: `/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin` in `centos:latest`. |
| `TERM`               | The terminal type, set to `xterm` if you use the `-t` flag with `docker run`. Not set by default if `-t` is omitted. |
| `HOME`               | The home directory of the user running the container’s main process. Example: `/root` for the `root` user in `centos:latest`. |

**How to Verify These Variables**:
Inside a container like `centos_bash`, you can run:

```bash
docker exec centos_bash env
```

**Example Output** (for `centos_bash`):

![[3.1.1_result_run.png]]

**Additional Insights**:
- **Image-Specific Variables**: The variables above are set by Docker, but the image itself may define additional environment variables in its Dockerfile using the `ENV` instruction. For example, in `nginx:latest`, you might see variables like `NGINX_VERSION` or `NJS_VERSION` set by the image.
- **Custom Variables**: You can add your own environment variables using the `-e` or `--env` flag with `docker run`. For example, `docker run -e MY_VAR=value centos:latest` adds `MY_VAR=value` to the container’s environment.
- **Overriding Defaults**: Some variables, like `HOSTNAME`, can be overridden with flags like `--hostname`. Others, like `PATH`, can be modified by the image or by setting them explicitly with `-e PATH=/new/path`.
- **Notable Absences**: Variables like `PWD`, `SHELL`, or `USER` are not set by Docker unless defined in the image or inherited from the user’s environment. For example, `SHELL` might be `/bin/bash` in `centos:latest` if the image sets it.

**Practical Tip**:  
If you need to debug a container’s environment, use `docker exec <container> env` to see all environment variables, including both Docker’s pre-defined ones and any custom ones set by the image or your `docker run` command.

---
## **docker ps**

```
docker ps
```

![[3.1.1_result_ps.png]]

# Understanding Docker Containers with `docker ps -a`

Let’s take a peek at what happens when you run the `docker ps -a` command in Docker. This handy command shows you a list of all the containers on your system—whether they’re currently running or have already finished their tasks. It’s like getting a snapshot of all the little workers Docker has managed for you. Let’s break down what each piece of information means and look at some examples to see it in action.

## What You See with `docker ps -a`

When you run `docker ps -a`, Docker gives you a table with details about each container. Here’s what each column tells you:

### CONTAINER ID
This is the unique ID for each container—a special code that identifies it, kind of like a fingerprint. It’s usually a long string, but Docker shows a shortened version for simplicity.

### IMAGE
This tells you which Docker image was used to create the container. Think of the image as the blueprint or recipe that the container was built from.

### COMMAND
This shows the command that kicked off when the container started. It’s the main task the container was set to do.

### CREATED
This lets you know how long ago the container was created—like a timestamp showing its age.

### STATUS
Here’s where you see what the container is up to right now. It might say “running” if it’s active, or “exited” if it’s done, along with an exit code (like 0 for success).

### PORTS
This column lists any network ports the container is using to talk to the outside world. If it’s not using any, this will be blank.

### NAMES
Every container gets a name, and this is where you see it. Docker often picks fun, random names unless you set one yourself.

## Real Examples: Containers in Action

Let’s look at some actual containers from the `docker ps -a` output to see these details in practice.

### Container 1: sharp_einstein
- **CONTAINER ID**: `bbbalced6a9f`  
  This is the unique ID for this container.
- **IMAGE**: `hello-world`  
  The container was created from the `hello-world` image, a tiny test image that prints a message.
- **COMMAND**: `"/hello"`  
  When this container started, it ran the `/hello` command, which is what prints the test message.
- **CREATED**: `4 minutes ago`  
  This container was created 4 minutes ago.
- **STATUS**: `Exited (0) 4 minutes ago`  
  The container finished its job 4 minutes ago with an exit code of 0, meaning it completed successfully.
- **PORTS**: (Not shown)  
  This container isn’t using any network ports, so this field is blank.
- **NAMES**: `sharp_einstein`  
  Docker gave this container the fun name `sharp_einstein`.

### Container 2: quirky_dhawan
- **CONTAINER ID**: `8699c026a7d`  
  Another unique ID for this container.
- **IMAGE**: `hello-world`  
  Like the first one, this container also used the `hello-world` image.
- **COMMAND**: `"/hello"`  
  It ran the same `/hello` command to print a message.
- **CREATED**: `4 minutes ago`  
  This container was also created 4 minutes ago.
- **STATUS**: `Exited (0) 4 minutes ago`  
  It exited 4 minutes ago with a success code of 0.
- **PORTS**: (Not shown)  
  No ports are in use here either.
- **NAMES**: `quirky_dhawan`  
  This container’s name is `quirky_dhawan`—another playful name from Docker.

### Container 3: musing_eibakyan
- **CONTAINER ID**: `1522019731ab`  
  The unique ID for this container.
- **IMAGE**: `hello-world`  
  Once again, the `hello-world` image was used.
- **COMMAND**: `"/hello"`  
  The `/hello` command ran when this container started.
- **CREATED**: `17 minutes ago`  
  This container is a bit older, created 17 minutes ago.
- **STATUS**: `Exited (0) 17 minutes ago`  
  It finished 17 minutes ago with a success code of 0.
- **PORTS**: (Not shown)  
  No network ports are being used.
- **NAMES**: `musing_eibakyan`  
  Docker named this one `musing_eibakyan`.

## How It Works Behind the Scenes

When you run `docker ps -a`, there’s no separate client and server info shown because the command directly talks to the Docker Daemon to fetch the container details. The daemon keeps track of all containers on your system and sends the info back to your terminal in this neat table format. It’s a straightforward way to see what’s going on with your containers, whether they’re still working or have already wrapped up.

### Table of Available Flags for `docker ps`

| **Flag**       | **What It Does**                                                                                                            | **Example**                                                                                                         |
| -------------- | --------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| `-a, --all`    | Shows all containers, not just the running ones—think stopped, exited, or created containers too.                           | `docker ps -a` <br> Lists all containers, like a stopped one named "hello-world".                                   |
| `-f, --filter` | Lets you filter containers based on conditions like status, name, or labels. Super useful for narrowing down your list!     | `docker ps -f "status=running"` <br> Shows only containers that are currently running, like "nginx".                |
| `--format`     | Customizes the output format using Go templates, so you can display just the info you care about in a neat way.             | `docker ps --format "{{.ID}} {{.Names}}"` <br> Outputs something like "a1b2c3d4 web-server".                        |
| `-n`           | Displays the last `n` containers, including all states (running, stopped, etc.). Great for a quick recent history check.    | `docker ps -n 3` <br> Shows the last 3 containers, such as "db", "app", and "nginx".                                |
| `-l, --latest` | Shows the most recently created container, regardless of its state. Handy for checking your newest container.               | `docker ps -l` <br> Displays the latest container, like "my-latest-app".                                            |
| `-q, --quiet`  | Outputs only the container IDs, nothing else—perfect for scripting when you just need the IDs.                              | `docker ps -q` <br> Returns something like "a1b2c3d4".                                                              |
| `-s, --size`   | Adds the size of each container to the output, so you can see how much disk space they’re using.                            | `docker ps -s` <br> Shows a running container like "web-server" with "1.2GB (virtual 1.5GB)".                       |
| `--no-trunc`   | Prevents truncation of the output, so you see the full container IDs, commands, or other fields without them being cut off. | `docker ps --no-trunc` <br> Shows the full container ID like "a1b2c3d4e5f6g7h8i9j0" instead of a shortened version. |

if you wonder what is the difference between virtual size and the size to the left of it, check this out.
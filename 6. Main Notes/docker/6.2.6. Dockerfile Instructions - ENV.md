# 6.2.6. Dockerfile Instructions - ENV

2025-08-09 10:49
Status: #DONE
Tags: [[Docker]]

---

### Mastering the `ENV` Command in Dockerfile

#### Understanding the `ENV` Command with Simple Explanations

The `ENV` command in a Dockerfile is like setting up a rulebook for our toy box that everyone playing with it must follow. Imagine we're building a playhouse and decide the lights should always be blue or the door should stay open—we use `ENV` to set these rules (called environment variables) inside the Docker image. These rules help the toys (our application) know how to behave, like telling them the temperature to use or a special code to unlock features.

For someone new to this, think of it like writing a note on the playhouse door: “Keep the music volume at 5!” The `ENV` command pins that note inside the image, so every time we open the box, the music stays at the right level. It’s a handy way to configure our setup without changing the code.

Technically, the `ENV` instruction sets environment variables that persist in the image and its containers during runtime. These variables can be referenced in subsequent instructions or used by the application. It supports two syntaxes: a key-value pair or multiple variables in a single line. Let’s explore its details with a practical approach.

#### Syntax and Usage of the `ENV` Command

The `ENV` command can be written in two forms. Here’s how it works:

1. **Single Key-Value Pair**
```
ENV MY_VAR=value
```
This sets an environment variable `MY_VAR` to `value`. It’s like labeling the playhouse door with “Color=Blue,” and every toy inside knows to use blue.

2. **Multiple Variables in One Line**
```
ENV MY_VAR=value MY_OTHER_VAR=another_value
```
This sets `MY_VAR` and `MY_OTHER_VAR` in one go. It’s efficient, like writing “Color=Blue Door=Open” on one note instead of two.

#### Key Rules and Behaviors

- **Persistence**: Environment variables set by `ENV` are available during the build process and at runtime in containers. They’re like permanent stickers on our toy box, visible to all who use it.
- **Overwriting**: If we define the same variable multiple times, the last value overwrites the previous one. It’s like updating the note from “Color=Blue” to “Color=Red.”
- **Referencing**: We can use variables in later instructions with `$VARIABLE` or `${VARIABLE}`. For example:
  ```
  ENV DIR_PATH=/app
  WORKDIR $DIR_PATH
  ```
  This sets the working directory to `/app`, leveraging the variable.

- **Scope**: Variables are inherited by layers built after the `ENV` instruction but don’t affect previous layers. It’s like a new rule that only applies to the next rooms we build in the playhouse.

#### Practical Example and Context

Since no specific Dockerfile is provided, let’s construct one based on the context, imagining a alpine-based image with environment variables:

```
FROM alpine:latest
LABEL "maintainer=Arman Ala"
ENV APP_VERSION=1.0 ENV_PATH=/usr/local/app
COPY test.txt $ENV_PATH/
```

- **Explanation**:
  - `FROM alpine:latest` sets the base image, like choosing a pre-built playhouse kit.
  - `LABEL "maintainer=Arman Ala"` adds metadata, like a maker’s tag.
  - `ENV APP_VERSION=1.0 ENV_PATH=/usr/local/app` sets two variables: `APP_VERSION` to `1.0` and `ENV_PATH` to `/usr/local/app`. This is our rulebook, telling the image its version and where to store files.
  - `COPY test.txt $ENV_PATH/` copies `test.txt` to `/usr/local/app/`, using the `ENV_PATH` variable. It’s like placing a toy in the designated storage spot.

- **Build Process**: We run:
  ```
  docker build -t myapp:v1 .
  ```
  This builds the image, and the environment variables are embedded. We can check them in a container with:
```
docker run -it myapp:v1 env
```
  This lists all environment variables, including `APP_VERSION=1.0` and `ENV_PATH=/usr/local/app`.

#### ELI5 Explanation

Networks might seem like magic, but think of them as a toy delivery truck bringing goodies to our playhouse. Sometimes, we need to tell the truck a special address or a secret code to get the right toys. Environment variables set by `ENV` can act like that code, helping our playhouse (container) talk to the truck (network) or set up its own rules, even if we don’t see the truck directly.

Technically, environment variables can influence network-related configurations (e.g., setting a proxy or port), though they don’t directly manage network interfaces. In this example, they help define paths or versions, indirectly supporting network-aware applications by providing runtime context.

#### Additional Considerations

- **Default Values**: Variables can be overridden at runtime with `docker run -e VAR=value`, offering flexibility. It’s like letting a friend adjust the music volume when they play.
- **Security**: Sensitive data (e.g., passwords) should be passed via runtime arguments or secrets management (e.g., Docker secrets) rather than hardcoding in `ENV`, to keep our playhouse safe.
- **Best Practices**: We should use meaningful variable names and document their purpose, ensuring our team knows the rulebook’s intent.

#### Key Takeaways

- The `ENV` command sets persistent environment variables, acting as a configuration rulebook for the image and containers.
- It supports single key-value pairs or multiple variables in one line, with the last value overwriting duplicates.
- Variables can be referenced in later instructions (e.g., `COPY` or `WORKDIR`), enhancing flexibility.
- They persist through the build and runtime, supporting customization while allowing runtime overrides.

By mastering the `ENV` command, we can create adaptable, well-configured Docker images tailored to our development and deployment needs.
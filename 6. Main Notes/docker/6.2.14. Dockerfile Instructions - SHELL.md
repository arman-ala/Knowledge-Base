# 6.2.14. Dockerfile Instructions - SHELL

2025-08-09 10:49
Status: #DONE
Tags: [[Docker]]

---
### Mastering the `SHELL` Command in Dockerfile

#### Understanding the `SHELL` Command with Simple Explanations

The `SHELL` command in a Dockerfile is like choosing the special tool we use to give instructions to our toy box. Imagine we’re building a playhouse and need a magic wand to tell the toys what to do—sometimes we use a shiny wand (like `/bin/sh`), and sometimes a fancier one (like `/bin/bash`). The `SHELL` command lets us pick that wand, so all our “do this” commands (like `RUN` or `CMD`) know how to work together.

For someone new to this, think of it like picking the language you use to talk to your robot toys. If the robot only understands simple words, we use a basic language; if it knows more, we can use a chatty one. The `SHELL` command sets that language for our playhouse instructions.

Technically, the `SHELL` instruction defines the default shell used to execute commands in shell form for `RUN`, `CMD`, and `ENTRYPOINT` instructions. It accepts an array of executable and arguments, overriding the base image’s default shell (e.g., `/bin/sh` for `alpine:latest`). Let’s explore its details with a practical approach.

#### Syntax and Usage of the `SHELL` Command

The `SHELL` command takes an array of the shell executable and its arguments. Here’s how it works based on the context:

1. **Basic `SHELL` with Default Shell**
```
SHELL ["/bin/sh", "-c"]
```
   This sets the shell to `/bin/sh` with the `-c` flag, which executes a string as a command. It’s like picking a simple wand that follows one-line instructions.

2. **Using `SHELL` in a Dockerfile**
```
   FROM centos:latest
   LABEL maintainer="Arman Ala"
   USER root
   COPY test.txt /dir1
   ADD --chown=10:11 myfile* /dir3/
   ENV mypath="/home/dir1"
   WORKDIR $mypath
   SHELL ["/bin/bash", "-c"]
   RUN echo "Hello from $mypath at $(date)" > /output.txt
```
   - `FROM centos:latest` sets the base image, like starting with a pre-built playhouse kit.
   - `LABEL maintainer="Arman Ala"` adds metadata.
   - `USER root` ensures commands run as the superuser.
   - `COPY test.txt /dir1` copies a file.
   - `ADD --chown=10:11 myfile* /dir3/` adds files with specific ownership.
   - `ENV mypath="/home/dir1"` sets an environment variable.
   - `WORKDIR $mypath` changes the working directory.
   - `SHELL ["/bin/bash", "-c"]` switches the shell to `/bin/bash` with `-c` for command execution, overriding CentOS’s default `/bin/sh`.
   - `RUN echo "Hello from $mypath at $(date)" > /output.txt` runs in `/bin/bash`, writing a message with the current date (03:53 AM CEST, Thursday, July 10, 2025) to `/output.txt`.

#### ELI5 Linux Concept Explanation

Linux might sound like a big toy factory, but think of it as the workshop where our playhouse is built. Inside, we have little helpers (shells) that understand our instructions. The `SHELL` command is like picking the smartest helper—maybe a quiet one (`/bin/sh`) or a talkative one (`/bin/bash`)—to carry out our toy-building tasks. It makes sure all our commands speak the same language.

Technically, `SHELL` configures the execution environment within the Linux-based Docker image, defining the shell interpreter for commands in shell form. It uses an array (e.g., `["/bin/bash", "-c"]`) to specify the executable and its flags, impacting how `RUN`, `CMD`, and `ENTRYPOINT` process instructions. This overrides the base image’s default shell, such as `/bin/sh` in `alpine:latest` or `/bin/bash` in `centos:latest`, and is applied to subsequent layers.

#### Key Rules and Behaviors

- **Default Shell Override**: `SHELL` changes the shell for all following instructions in shell form. The base image’s default (e.g., `/bin/sh` for Alpine) is replaced.
- **Array Format**: It requires an array (e.g., `["/bin/bash", "-c"]`), where the first element is the shell and others are arguments.
- **Scope**: Affects only instructions after its declaration in the Dockerfile. It’s like setting a new wand for the rest of the build.
- **Compatibility**: Must match the base image’s available shells (e.g., `/bin/bash` works on `centos:latest` but may need installation on `alpine:latest`).

#### Build and Runtime Process

- **Build**:
```
docker build -t mycentos:v1 .
```
  This builds the image, using `/bin/bash -c` for the `RUN` command, creating `/output.txt` with the message and date.

- **Run**:
```
docker run -it mycentos:v1 cat /output.txt
```
  This starts the container and displays the contents of `/output.txt`, showing “Hello from /home/dir1 at Thu Jul 10 03:53:00 CEST 2025”.

#### Additional Considerations

- **Best Practices**: Use `SHELL` when the base image’s default shell lacks features (e.g., switching to `/bin/bash` for `echo $(date)`). Document the change for team clarity.
- **Performance**: Changing `SHELL` creates a new layer only if it impacts command execution; otherwise, it’s lightweight.
- **Security**: Ensure the shell is secure and available in the image to avoid build failures.

#### Key Takeaways

- The `SHELL` command sets the default shell (e.g., `["/bin/bash", "-c"]`) for `RUN`, `CMD`, and `ENTRYPOINT` instructions in shell form.
- It overrides the base image’s default, enabling tailored command execution with features like variable expansion.
- It applies only to subsequent instructions, requiring careful placement in the Dockerfile.
- Proper usage enhances flexibility and compatibility across different base images.

By mastering the `SHELL` command, we can fine-tune our Docker builds, ensuring commands execute smoothly with the right tools.
We’re diving into the behavior of Docker volumes when multiple containers write to them simultaneously, using the `centos:latest` image to illustrate key concepts. The provided diagram give us a practical example of this scenario, and we’ll explore why data wasn’t lost in this case. Additionally, we’ll revisit the differences between volumes and bind mounts to deepen our understanding of their distinct characteristics.

![[4.9_shared_container.png]]

## Simultaneous Writes to a Volume: Data Consistency Considerations

When two containers write to the same Docker volume at the same time, Docker itself doesn’t provide any built-in mechanisms to prevent data loss or corruption. This responsibility falls to the underlying operating system (OS) or the application logic we implement to manage concurrent access. Let’s break this down with an example.

The screenshot shows two containers, `centos_ping_8888` and `centos_ping_4224`, both writing to the same volume mounted at `/data`. The command used to create these containers is:

```bash
docker run -it --name centos_ping_8888 -v async_write:/data centos:latest
docker run -it --name centos_ping_4224 -v async_write:/data centos:latest
```

Inside each container, a `ping` command is executed, and its output is redirected to a file in the shared volume:

- In `centos_ping_8888`, the command is `ping 8.8.8.8 >> ping.out`.
- In `centos_ping_4224`, the command is `ping 4.2.2.4 >> ping.out`.

The screenshot on the left shows the contents of `ping.out` in the volume (at `/var/lib/docker/volumes/async_write/_data/ping.out`), which contains the output of the `ping 8.8.8.8` command. The right side shows that both containers successfully wrote to the same file (`ping.out`) without apparent data loss. However, this successful outcome isn’t guaranteed by Docker—it’s due to how the OS and the application (`ping` in this case) handled the writes.

![[4.9_data_consistency.png]]

### Why Didn’t We Lose Data?

In this specific example, data wasn’t lost because of how the OS managed the file writes. When two processes (or containers) write to the same file simultaneously, the OS’s filesystem handles the operations. Here’s what likely happened:

- **File Overwrite Behavior**: The `>` operator in the `ping 8.8.8.8 > ping.out` command truncates the file and writes new data. If both containers ran this command at the exact same time, one container’s write would overwrite the other’s. However, the screenshot suggests that the writes were sequential (one container wrote after the other), so the second container’s output (`ping 4.2.2.4`) overwrote the first container’s output (`ping 8.8.8.8`). This is why we only see the `ping 4.2.2.4` output in `ping.out`.
- **OS-Level File Locking**: Some filesystems implement advisory locking or atomic write operations to prevent corruption during concurrent writes. However, the `>` operator doesn’t use locking by default, so the OS simply allowed the second write to overwrite the first.
- **Application Behavior**: The `ping` command writes its output in a streaming manner, and the timing of the writes in this example likely prevented overlap. If the writes had been more complex (e.g., both containers appending to the file with `>>`), we might have seen interleaved or corrupted data.

### The Role of Docker

Docker doesn’t intervene in this process—it simply provides the volume as a shared storage medium. The volume `async_write` is mounted to `/data` in both containers, and Docker ensures that both containers can access the same underlying storage on the host (at `/var/lib/docker/volumes/async_write/_data/`). However, Docker doesn’t manage how the containers interact with the files in the volume. If we need to prevent data loss or corruption during simultaneous writes, we must implement our own controls, such as:

- **File Locking**: Use application-level locking mechanisms (e.g., `flock` in Linux) to ensure only one container writes to a file at a time.
- **Separate Files**: Have each container write to a unique file (e.g., `ping_8888.out` and `ping_4224.out`) to avoid conflicts.
- **Append Mode**: Use `>>` instead of `>` to append data, though this can still lead to interleaved output if writes are concurrent.
- **Synchronization**: Use a coordination mechanism (e.g., a database, message queue, or semaphore) to manage access to shared resources.

The diagram reinforces this setup: Container 1 and Container 2 both mount the same volume from the Docker host’s local storage area (`/var/lib/docker/.../container1_container2`). The shared volume allows both containers to access the same data, but it’s up to us to ensure safe concurrent access.

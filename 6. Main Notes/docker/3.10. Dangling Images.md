# 3.10. Dangling Images

2025-08-09 18:40
Status: #DONE 
Tags: [[Docker]]

---
## Understanding Dangling Images in Docker

#### What Are Dangling Images?
In Docker, a dangling image is an image that doesn’t have a repository name or tag associated with it, so when you list your images with `docker images`, you’ll see it show up as `<none>:<none>`. These images are called "dangling" because they’re no longer referenced by any tag—they’re just hanging around on your system, untagged and unloved. This usually happens when Docker creates a new image with a name and tag that already exists, causing the older image to lose its tag and become dangling. Dangling images still take up disk space, and in most cases, you don’t need them, so it’s a good idea to clean them up to free up space on your system. However, they can sometimes be handy if you need to debug an issue or roll back to a previous version of an image, so it’s worth understanding how they come about before you delete them.

#### How Dangling Images Are Created
Dangling images can pop up in a few different scenarios, often when you’re building or managing images. Here are some common situations where they’re created:

1. **Rebuilding an Image with the Same Name and Tag (e.g., in a CI/CD Pipeline)**  
   Let’s say you’re working on a CI/CD pipeline, and you build an image for your app called `myapp:v2`. You run `docker build -t myapp:v2 .` to create it, and everything looks good. But then you realize you forgot to add a crucial part to your app—like a new dependency in your `Dockerfile`. So, you update the `Dockerfile` and run the same build command again: `docker build -t myapp:v2 .`. What happens? Docker doesn’t complain about the name `myapp:v2` already existing—it just builds a new image and assigns the tag `myapp:v2` to the new image. The old image, which used to have the tag `myapp:v2`, loses that tag and becomes dangling, showing up as `<none>:<none>` in your image list. This is a super common scenario in automated pipelines where you’re repeatedly building images with the same tag.

2. **Intermediate Images in Multi-Stage Builds**  
   Another way dangling images can appear is during a multi-stage build. If you’re using a multi-stage `Dockerfile` to optimize your image (like building your app in one stage and copying the result to a smaller runtime stage), Docker creates intermediate images for each stage. Once the final image is built, those intermediate images are no longer needed and often become dangling if they’re not tagged or referenced. For example, if you build an image with a `Dockerfile` that has a build stage and a runtime stage, the build stage image might end up as `<none>:<none>` after the build is done, unless you explicitly tag it.

3. **Manually Untagging an Image**  
   You can also create a dangling image by removing a tag from an image yourself. If you run `docker rmi myapp:v2` (or `docker image rm myapp:v2`), Docker removes the tag `myapp:v2` from the image. If that image doesn’t have any other tags pointing to it, it becomes dangling. This is less common but can happen if you’re cleaning up tags manually and forget that an image might not have any other references.

#### Why You Might Want to Remove Dangling Images
Dangling images can pile up over time, especially if you’re frequently building images as part of a development or CI/CD workflow. Since they don’t have a tag, they’re not being used by any running containers (unless you specifically reference them by their image ID), and they just sit there taking up disk space. On a busy system, this can add up to gigabytes of wasted storage, which might slow down your Docker operations or fill up your disk. That’s why most people prefer to remove dangling images regularly to keep their system clean and efficient. However, if you think you might need to inspect a dangling image—say, to debug a failed build or roll back to an earlier version—you can always retag it and give it a new name before deleting it.

#### How to Remove Dangling Images
Docker makes it easy to clean up dangling images with a single command. You can run:

```bash
docker image prune
```

This command will find all the dangling images on your system (those with `<none>:<none>`) and delete them, freeing up the disk space they were using. It’s a quick and safe way to tidy up, but be aware that it only removes dangling images—it won’t touch images that have a tag or are being used by a container. If you want to be extra cautious, you can run `docker images -f "dangling=true"` first to see a list of dangling images before pruning them. That way, you can double-check that you’re not deleting something you might need.

#### How to Retag a Dangling Image (Bring It Back to Life)
If you decide you don’t want to delete a dangling image and instead want to give it a new name and tag, you can do that with the `docker tag` command. First, you’ll need to find the image ID of the dangling image by running `docker images` and looking for the `<none>:<none>` entry. The image ID will be a long string like `a1b2c3d4e5f6`. Then, you can retag it with a new name and tag. For example, if you want to name it `app:v2`, you’d run:

```bash
docker tag a1b2c3d4e5f6 app:v2
```

This command takes the dangling image (identified by its image ID) and gives it a new tag, `app:v2`. Now, when you run `docker images`, you’ll see `app:v2` in the list, and the image is no longer dangling—it’s back in action with a proper name and tag. You can then use it to run containers or push it to a registry, just like any other tagged image. This is a great trick if you accidentally made an image dangling but still need it for your project.
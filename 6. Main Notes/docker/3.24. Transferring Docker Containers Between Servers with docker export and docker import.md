# 3.24. Transferring Docker Containers Between Servers with docker export and docker import

2025-08-09 18:47
Status: #DONE 
Tags: [[Docker]]

---
Let’s explore how to transfer a Docker container from one server to another using the `docker export` and `docker import` commands. Unlike `docker save` and `docker load`, which work with images, `docker export` and `docker import` deal directly with containers, allowing us to capture a container’s filesystem and import it as an image on another server. We’ll walk through the process step-by-step, using the `centos_change` container as an example, and include tables listing all possible flags for both commands.

### Step 1: Running the Container and Making Changes

First, we start a container named `centos_change` using the `centos:latest` image. We’ll run it interactively to make some changes that we can verify later.

**Command**:
```bash
docker run -it --name centos_change centos:latest
```

- The `-it` flags allocate an interactive terminal (`-i` for stdin, `-t` for a TTY).
- `--name centos_change` names the container.
- `centos:latest` is the image, which runs `/bin/bash` by default.

Inside the container, we create a file to ensure we can check for its existence after transferring:

```bash
touch /home/test_file.txt
```

We also copy a file from the host to the container to simulate a real-world scenario:

**Command** (run on the host in a separate terminal):
```bash
docker cp host_file.txt centos_change:/home
```

- This copies `host_file.txt` from the host to the `/home` directory inside the `centos_change` container.
- Now, inside the container, we can verify the files:
  ```bash
  ls /home
  ```
  Output:
  ```
  host_file.txt  test_file.txt
  ```

We exit the container to stop it:

```bash
exit
```

The container is now in the `Exited` state, and we can proceed to export it.

### Step 2: Exporting the Container with `docker export`

The `docker export` command allows us to export a container’s filesystem as a tar archive. This includes all the files and directories in the container, but it does not include the container’s metadata (like its configuration, environment variables, or volumes).

**Command**:
```bash
docker export -o centos_change.tar centos_change
```

**second approach**:
```bash
docker export centos_change > centos_change.tar
```

- The `-o` (stands for `--output`) flag specifies the output file (`centos_change.tar`).
- `centos_change` is the name of the container we want to export.

**What Happens**:
- `docker export` creates a tar archive containing the entire filesystem of the `centos_change` container, including the `/home` directory with `test_file.txt` and `host_file.txt`.
- The container doesn’t need to be running—`docker export` works on both running and stopped containers.
- We can verify the tar file exists on the host:
```bash
ls
```
  
  Output might include:
![[3.24_result_ls.png]]

**Insight**:
- The resulting tar file is a flattened snapshot of the container’s filesystem, meaning it doesn’t preserve the image’s layers (unlike `docker save`). This makes the tar file smaller but means we lose some metadata, such as the container’s `CMD`, `ENTRYPOINT`, and environment variables.

### Step 3: Transferring the Tar File to Another Server (Optional)

Now that we have the `centos_change.tar` file on Server X, we need to transfer it to Server Y. We can use a tool like `scp` to copy the file securely:

**Command**:
```bash
scp centos_change.tar user@server-y:/path/to/destination
```

This copies the tar file to Server Y, where we can import it.

the terminal probably looks like below:
![[3.24_sections_1_3.png]]

### Step 4: Importing the Container as an Image with `docker import`

On Server Y, we use the `docker import` command to convert the tar archive back into a Docker image. This image can then be used to run new containers.

**Command**:
```bash
docker import centos_change.tar centos_imported:v1
```

- `centos_change.tar` is the tar file we transferred.
- `centos_imported:v1` is the name and tag we’re giving to the new image.

**What Happens**:
- `docker import` reads the tar file and creates a new image named `centos_imported:v1`.
- The image contains the filesystem from the `centos_change` container, including the `/home` directory with our files.
- We can verify the new image exists on Server Y:
```bash
docker images
```
  
  Output till now:
![[3.24_section_4.png]]
**Insight**:
- Unlike `docker load`, which preserves the image’s metadata and layers, `docker import` creates a new image with a single layer. The new image doesn’t inherit the original image’s `CMD`, `ENTRYPOINT`, or other settings from `centos:latest`. We’ll need to specify these when running a container from the imported image.

### Step 5: Running a New Container and Verifying the Files

Now that we have the `centos_imported:v1` image on Server Y, let’s run a new container to verify that our files are still there.

**Command**:
```bash
docker run -it centos:latest /bin/bash
```

- Since `docker import` doesn’t preserve the original `CMD` (`/bin/bash` in `centos:latest`), we explicitly specify `/bin/bash` to start a shell.

- Inside the container, we check the `/home` directory:
```bash
ls /home
```
  
  Output:
![[3.24_section_5.png]]

The files we created and copied are present, confirming that the transfer was successful.

**Insight**:
- If we didn’t specify `/bin/bash`, the container might fail to start because the imported image has no default command. We could also set a new `CMD` by creating a new image with a Dockerfile or using `docker commit` again after making changes.

### Step 6: Cleaning Up (Optional)

After transferring, we might want to clean up on Server X by removing the original container and tar file:

**Commands**:
```bash
docker rm centos_change
rm centos_change.tar
```

- `docker rm centos_change` removes the stopped container.
- `rm centos_change.tar` deletes the tar file from the host.

### Flags for `docker export`

Here’s a table listing all the flags for the `docker export` command, along with their purposes:

| Option           | Description                                                                                                                                           |
| ---------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| `-o`, `--output` | Specifies the output file for the tar archive. If not set, the output is sent to stdout. Example: `docker export -o centos_change.tar centos_change`. |

**Insight**:
- If you omit the `-o` flag, `docker export` sends the tar archive to stdout, which you can redirect manually. For example:
```bash
docker export centos_change > centos_change.tar
```

### Flags for `docker import`

Here’s a table listing all the flags for the `docker import` command, along with their purposes:

| Option              | Description                                                                                     |
|---------------------|-------------------------------------------------------------------------------------------------|
| `-c`, `--change`    | Applies Dockerfile instructions to the imported image. Can be used multiple times. Example: `docker import -c "CMD /bin/bash" centos_change.tar centos_imported:v1` to set the default command. |
| `-m`, `--message`   | Sets a commit message for the imported image. Example: `docker import -m "Imported from centos_change" centos_change.tar centos_imported:v1`. |

**Insight**:
- The `-c` flag is powerful because it lets you customize the imported image. For example, you can set environment variables, expose ports, or define an entrypoint:
```bash
docker import -c "ENV MY_VAR=value" -c "EXPOSE 80" centos_change.tar centos_imported:v1
```

- The `-m` flag is useful for documentation, as the message appears in the image’s history when you run `docker history centos_imported:v1`.

### Additional Insights

- **Differences from `docker save`/`load`**: While `docker save` and `docker load` transfer images (preserving layers and metadata), `docker export` and `docker import` work with containers and create a new image with a single layer. This means `docker import` is better for transferring a container’s filesystem but not its full configuration.
- **File Ownership**: The files we copied (`host_file.txt`) and created (`test_file.txt`) retain their ownership and permissions in the imported image. Since `centos_change` runs as `root`, these files are owned by `root` (UID 0) in the new container, unless user namespaces are in use.
- **Use Case**: `docker export` and `docker import` are useful for scenarios where you want to capture a container’s exact filesystem state (e.g., for debugging or archiving) without needing the full image metadata. However, for most production use cases, `docker save` and `docker load` are preferred because they preserve the image’s layers and configuration.
- **Compression**: The `docker export` command doesn’t compress the output by default. To reduce the file size for transfer, you can compress the tar file manually:
  ```bash
  docker export centos_change | gzip > centos_change.tar.gz
  ```
 
  On Server Y, you’d decompress before importing:
```bash
gunzip -c centos_change.tar.gz | docker import - centos_imported:v1
```

## Comparing `docker save` and `docker export`

| Aspect              | `docker save`                                                                                  | `docker export`                                                                                |
|---------------------|------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------|
| **Purpose**         | Saves one or more images into a tar archive, preserving all layers and metadata.              | Exports a container’s filesystem into a tar archive, creating a flattened snapshot without metadata. |
| **Input**           | Takes an image (e.g., `docker save -o image.tar mycent:v1`).                                  | Takes a container (e.g., `docker export -o container.tar centos_change`).                     |
| **Output**          | A tar archive containing the image’s layers, metadata, and configuration (e.g., `CMD`, `ENTRYPOINT`). | A tar archive containing the container’s filesystem as a single layer, without configuration. |
| **Preserves Layers** | Yes, maintains the image’s layer structure for efficient storage and reuse.                   | No, flattens the filesystem into a single layer, losing the original layer structure.         |
| **Metadata**        | Preserves all metadata (e.g., environment variables, `CMD`, `ENTRYPOINT`, labels).            | Does not preserve metadata; the resulting image has no `CMD` or `ENTRYPOINT` by default.      |
| **Use Case**        | Ideal for transferring images between servers while retaining their full configuration.        | Useful for capturing a container’s filesystem state (e.g., for debugging or archiving).       |
| **Resulting Action** | Use `docker load` to restore the image, which can then be used to run containers.             | Use `docker import` to create a new image, which needs a `CMD` or `ENTRYPOINT` to run.        |
| **File Size**       | Typically larger due to preserving layers and metadata.                                       | Often smaller because it flattens the filesystem into a single layer.                         |
| **Flags**           | Supports `-o` (output file) and `--quiet` (suppress output).                                  | Supports only `-o` (output file).                                                             |

### Does `docker export` Require Manually Downloading the Image?

When using the `docker export` command, you don’t need to manually download the image because it’s already part of the container you’re exporting. The `docker export` command works directly with a container (not an image), capturing its filesystem into a tar archive. The container, which was created from an image (e.g., `centos:latest`), already has the image’s layers on the host where it was created, so no additional download is needed during the export process. However, when you use `docker import` on another server, you’re creating a new image from the tar file, and no download from a registry is involved—it’s all local.


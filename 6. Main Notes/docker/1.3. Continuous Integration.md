# 1.3. Continuous Integration

2025-06-30 05:32
Status: #DONE 
Tags: [[Docker]]

---
**CI (Continuous Integration)** is a **Best Practice** in the field of software development.  
The goal of CI is to create an infrastructure that allows developers to continuously integrate their code into a shared repository multiple times a day. After integration, **Build** , **Test** , and **Integration** processes are automatically executed. If we can establish such an infrastructure, we can claim that we have successfully implemented **CI** .

In the absence of such an infrastructure, developers are forced to **Build** , **Test** , and **Integrate** their code on their local systems. This approach can lead to issues during the **Deploy** phase by the **Operations** team, often due to environmental inconsistencies.  
For example, an application might run smoothly on a developer's system because of a specific **Dependency** or local configuration, but it may fail on the operational server due to the absence of the same **Dependency** or differences in settings.

By using **CI** , these issues are significantly reduced. In this approach, all dependencies and required configurations are managed in a standardized and automated environment. Tools like **Jenkins** , **GitLab CI/CD** , **CircleCI** , and **Travis CI** are used to implement **CI** . These tools automatically fetch the code from the repository, **Build** it, run automated tests, and prepare it for deployment upon success.

Moreover, **CI** helps reduce **Technical Debt** and improves code quality. By continuously running tests and quality checks, issues are identified and resolved earlier, which reduces maintenance costs and accelerates development speed.

**\* Technical Debt** refers to the implied cost of additional rework caused by choosing an easy (limited) solution now instead of using a better approach that would take longer. It often arises from shortcuts in coding, lack of testing, or poor design decisions, which can accumulate over time and make the software harder to maintain or extend.

---

# **Continuous Integration: Definition, Benefits & Essential Practices**

## The Role of Continuous Integration in Modern Development
Continuous Integration (CI) has become a *cornerstone(سنگ بنای)* of modern software development, *embraced by (پذیرفته شده توسط)* teams worldwide. CI tools like Jenkins automate delivery pipelines, while systems like Kubernetes provide flexibility for managing complex deployments.

## Continuous Integration Defined
Continuous Integration involves practices and principles that enable frequent, reliable code changes. It *enhances (تسهیل کردن) (improve)* workflow, *facilitates (تسهیل کردن)* smoother development processes, and *fosters (پرورش دادن) (to encourage the development or growth of something)* collaboration. CI ensures consistency in the integration process, allowing teams to merge code changes frequently and confidently.

![[1-3_CI_defined.png]]

----

### Importance of Continuous Integration
Without CI, teams risk isolation, leading to communication breakdowns, increased costs, and slower releases. CI promotes *transparency (شفافیت) (clarity)*, aligning development efforts with business goals and ensuring software stability and reliability.

![[1-3_CD.png]]

---
## **Implementing Continuous Integration**
CI is often used with agile development. Tasks are allocated to team members, who work independently and integrate their changes into the CI system. The process includes:

1. **Write Tests for Critical Code**: Ensure core functionality is covered.
2. **Automate Test Execution**: Set up CI to run tests on every code push.
3. **Daily Code Integration**: Encourage frequent integration to catch issues early.
4. **Swift Error Resolution**: Address build failures immediately.
5. **Test Each New Feature**: Write tests for new features and bug fixes.
6. **Monitor and Report**: Use CI tools to monitor builds and generate reports.
7. **Continuous Feedback Loop**: Provide immediate feedback to developers.

![[1-3_CI_implementation.png]]

---
## **Continuous Integration, Continuous Delivery & Continuous Deployment**
CI is part of a *broader (wider)* automated software release pipeline, including Continuous Delivery (CD) and Continuous Deployment (CD).

- **Continuous Integration (CI)**: Regularly merge code changes into a shared repository.
- **Continuous Delivery (CD)**: Build and test software, making it ready for release.
- **Continuous Deployment**: Automatically release software to production environments.

![[1-3_CI-CD-CD.png]]

### Continuous Integration (CI), Continuous Delivery (CD), and Continuous Deployment (CD)

These three concepts—**Continuous Integration (CI)**, **Continuous Delivery (CD)**, and **Continuous Deployment (CD)**—are foundational practices in modern software development and DevOps. While they are closely related and often used together, they serve distinct purposes and address different stages of the software delivery pipeline. Below is a detailed comparison of these concepts:

### 1. **Continuous Integration (CI)**

#### Definition:
**Continuous Integration (CI)** is a development practice where developers frequently integrate their code into a shared repository (e.g., Git). Each integration triggers an automated build and testing process to detect issues early.

#### Key Characteristics:
- **Frequency**: Developers commit code multiple times a day.
- **Automation**: Automated builds and tests ensure that new code integrates smoothly with existing code.
- **Goal**: Detect integration errors as quickly as possible to reduce the time and effort required to fix them.

#### Workflow:
1. A developer writes code and pushes it to a version control system (e.g., GitHub, GitLab).
2. The CI tool (e.g., Jenkins, GitLab CI/CD, CircleCI) detects the change and pulls the latest code.
3. The tool builds the code, runs unit tests, and performs static code analysis.
4. If the build or tests fail, the developer is notified immediately.

#### Benefits:
- **Early Detection of Bugs**: Issues are identified and resolved early in the development cycle.
- **Improved Collaboration**: Frequent integration reduces merge conflicts and encourages teamwork.
- **Faster Feedback**: Developers receive immediate feedback on their code changes.

#### Tools:
- **Jenkins**
- **GitLab CI/CD**
- **CircleCI**
- **Travis CI**
- **Azure DevOps**

### 2. **Continuous Delivery (CD)**

#### Definition:
**Continuous Delivery (CD)** is an extension of **Continuous Integration**. It ensures that code is always in a deployable state, meaning that after passing all tests, the application can be released to production at any time with minimal manual intervention.

#### Key Characteristics:
- **Deployable State**: Code is continuously tested and prepared for release, but the actual deployment to production is triggered manually by a human.
- **Automation**: The entire pipeline from code commit to deployment preparation is automated.
- **Goal**: Reduce the risk of releasing new features by ensuring that every change is ready for production.

#### Workflow:
1. After successful integration in CI, the code moves to the **Delivery** phase.
2. Additional automated tests (e.g., integration tests, end-to-end tests) are run to validate the application.
3. The application is packaged and stored in a repository (e.g., Docker images in a container registry).
4. The application is ready for deployment, but a human operator decides when to release it to production.

![[1-3_Continuous_Delivery.png]]

#### Benefits:
- **Reduced Risk**: Since the code is always in a deployable state, the risk of failed deployments is minimized.
- **Faster Releases**: New features and bug fixes can be released quickly without extensive manual testing.
- **Controlled Deployments**: Human oversight allows for strategic timing of releases (e.g., during low-traffic periods).

![[1-3_CICD.png]]

#### Tools:
- **Jenkins**
- **GitLab CI/CD**
- **CircleCI**
- **AWS CodePipeline**
- **Spinnaker**

### 3. **Continuous Deployment (CD)**

#### Definition:
**Continuous Deployment (CD)** takes **Continuous Delivery** one step further by automating the deployment process. Every change that passes all stages of the production pipeline is automatically deployed to production without human intervention.

#### Key Characteristics:
- **Full Automation**: The entire pipeline, from code commit to production deployment, is fully automated.
- **Immediate Deployment**: Changes are deployed to production as soon as they pass all tests.
- **Goal**: Achieve the fastest possible time-to-market by eliminating manual approval steps.

#### Workflow:
1. After successful integration in CI, the code moves to the **Deployment** phase.
2. Automated tests (unit tests, integration tests, end-to-end tests) are run to validate the application.
3. If all tests pass, the application is automatically deployed to production.
4. No manual intervention is required unless a failure occurs.

#### Benefits:
- **Rapid Feedback**: Users receive updates and new features as soon as they are ready.
- **Increased Efficiency**: Eliminates manual deployment steps, reducing delays and human error.
- **Smaller, Incremental Changes**: Frequent, small deployments reduce the risk of large-scale failures.

#### Risks:
- **Higher Risk of Errors**: Since there is no human oversight, bugs or issues may reach production more easily.
- **Requires Robust Testing**: Extensive automated testing is essential to ensure that only high-quality code is deployed.

#### Tools:
- **Jenkins**
- **GitLab CI/CD**
- **CircleCI**
- **AWS CodeDeploy**
- **Spinnaker**

### Comparison Table: CI vs. Continuous Delivery vs. Continuous Deployment

| Aspect                     | **Continuous Integration (CI)**                          | **Continuous Delivery (CD)**                              | **Continuous Deployment (CD)**                           |
|----------------------------|----------------------------------------------------------|-----------------------------------------------------------|----------------------------------------------------------|
| **Definition**             | Frequent code integration with automated builds and tests | Ensures code is always in a deployable state; manual release | Fully automated deployment to production                |
| **Automation Level**       | Partial automation (builds and tests)                   | High automation (up to deployment preparation)            | Full automation (entire pipeline)                       |
| **Deployment Trigger**     | Manual (no deployment)                                  | Manual (human decides when to deploy)                     | Automatic (every change is deployed)                    |
| **Goal**                   | Early detection of integration issues                   | Reduce risk of failed deployments                         | Achieve the fastest time-to-market                      |
| **Human Involvement**      | Minimal (only code commits)                             | Moderate (manual approval for deployment)                 | None (fully automated)                                  |
| **Risk Level**             | Low (issues caught early)                               | Medium (controlled deployments)                           | High (potential for bugs to reach production)           |
| **Use Case**               | Development teams focusing on code quality              | Teams aiming for frequent, controlled releases            | Teams aiming for rapid, incremental updates             |

![[1-3_CI-CD-CD-2.png]]

![[1-3_CI-CD-CD-3.png]]

### Key Differences Between CI, Continuous Delivery, and Continuous Deployment

1. **Scope**:
   - **CI** focuses on integrating code changes and running automated tests to ensure code quality.
   - **Continuous Delivery** extends CI by preparing the code for deployment but requires manual approval for production releases.
   - **Continuous Deployment** automates the entire pipeline, including deployment to production, without human intervention.

2. **Automation**:
   - **CI** automates the build and testing process.
   - **Continuous Delivery** automates everything up to the point of deployment preparation.
   - **Continuous Deployment** automates the entire process, including deployment to production.

3. **Deployment Timing**:
   - **CI** does not involve deployment.
   - **Continuous Delivery** allows for manual control over when to deploy.
   - **Continuous Deployment** deploys changes automatically as soon as they pass all tests.

4. **Risk Management**:
   - **CI** minimizes integration risks by catching issues early.
   - **Continuous Delivery** reduces deployment risks by ensuring code is always ready for production.
   - **Continuous Deployment** increases the speed of delivery but introduces higher risks due to the lack of human oversight.

![[1-3_CD-2.png]]
### When to Use Each Practice

1. **Continuous Integration (CI)**:
   - Ideal for teams that want to improve code quality and reduce integration issues.
   - Suitable for projects where frequent code changes are made, and early bug detection is critical.

2. **Continuous Delivery (CD)**:
   - Best for teams that want to ensure their code is always ready for production but prefer to control the timing of releases.
   - Useful for organizations that need to balance speed with risk management.

3. **Continuous Deployment (CD)**:
   - Suitable for teams that prioritize rapid delivery and have robust automated testing in place.
   - Best for organizations that can tolerate some level of risk in exchange for faster time-to-market.

### Conclusion

- **Continuous Integration (CI)** is about automating the integration and testing of code changes to catch issues early.
- **Continuous Delivery (CD)** ensures that code is always in a deployable state, with manual control over when to release.
- **Continuous Deployment (CD)** automates the entire pipeline, including deployment to production, for the fastest possible updates.

Each practice serves a specific purpose and can be adopted based on the team's goals, risk tolerance, and maturity level. Many organizations start with **CI**, progress to **Continuous Delivery**, and eventually adopt **Continuous Deployment** as their processes and testing capabilities mature.

----

## Benefits of Continuous Integration
1. **Smaller Batches of Code Changes**: Simplifies integration and testing.
2. **Easier Fault Isolation**: Quickly identify and address issues.
3. **Faster Production and Release Cycle**: Speeds up the release process.
4. **Easier Software Maintenance**: Resolve defects quickly.
5. **Happier Customers**: Deliver high-quality software with enhanced functionality.

![[1-3_CI_list.png]]

---

## Essential Practices in Continuous Integration
1. **Single Source Repository**: Maintain a single shared repository.
2. **Automate Builds and Tests**: Use tools like Jenkins, Maven, and Gradle.
3. **Enable Software Self-Testing**: Include automated tests in the build process.
4. **Fix Errors Immediately**: Address build failures without delay.
5. **Ensure Resource Visibility**: Keep the team informed about the project's state.

![[1-3_CI-workflow.png]]

---

## Continuous Integration Workflow

### Developer
- **Writes Code**: Develops new features or fixes bugs.
- **CI Tool**:
  - **Build Application**: Compiles the code and resolves dependencies.
  - **Run Automated Tests**: Executes unit and integration tests.
  - **Problem Detected**: Notifies the developer of any issues.
- **Changes Needed**: Developer makes necessary changes.

### Everything OK
- **Maintainer or Developer**:
  - **Merge Changes**: Integrates the code into the main branch.
  - **Application Ready for Deployment**: Prepares the application for release.

## Continuous Exploration and Deployment
- **Develop**: Create new features and improvements.
- **Build**: Compile and package the application.
- **Test-End-to-End**: Perform comprehensive testing.
- **Stage**: Prepare the application for production.
- **Continuous Deployment**: Automatically deploy to production.
- **Release on Demand**: Make the application available to users as needed.

## Continuous Delivery and Deployment Pipelines
- **Developers Commit Code**: Push changes to the repository.
- **Build Pipeline**: Automatically build and test the code.
- **Artifact Repository**: Store build artifacts for deployment.
- **Human Approves**: Manual testing and approvals for production.
- **Production**: Deploy the application to live environments.

## Conclusion
Continuous Integration is essential for modern software development, ensuring frequent, reliable code changes and high-quality software. By following best practices and leveraging CI tools, teams can streamline their development process, reduce errors, and deliver software faster.

## Supercharging Your CI/CD with Global App Testing
Global App Testing enhances CI/CD processes with:

- **Rapid Test Execution**: Receive results within six hours.
- **Global Coverage**: Test across thousands of devices and configurations.
- **Seamless Integration**: Integrate with tools like Jira and GitHub.
- **Flexible Testing Options**: Choose manual or exploratory testing.
- **Crowdsourced Testing**: Leverage a global network of testers.
- **Continuous Feedback Loop**: Accelerate iterations and ensure reliable deployments.

By partnering with Global App Testing, you benefit from improved speed, enhanced quality, scalability, and seamless integration with DevOps tools.


---

## Explanation of the Sentences in the Context of **Continuous Delivery/Integration**

#### **1. Continuous Delivery is about putting the release schedule in the hands of the business, not in the hands of IT.**

This sentence highlights a fundamental shift in how software releases are managed in organizations that adopt **Continuous Delivery (CD)**.

- **Traditional Model**: In traditional software development, IT or operations teams often control when software is released to production. This can lead to delays because releases are tied to technical schedules, infrastructure readiness, or manual processes. For example, IT might wait for a "big bang" release that includes multiple features, which can take weeks or months to prepare.

- **Continuous Delivery Approach**: With **Continuous Delivery**, the focus shifts to empowering **business stakeholders** (e.g., product managers, marketing teams, or executives) to decide when and what to release. The software is always in a deployable state, so the business can choose the optimal time for releasing new features, bug fixes, or updates based on market demands, customer feedback, or strategic goals.

  - **Why It Matters**: 
    - **Business Agility**: The business can respond quickly to customer needs or competitive pressures. For example, if a competitor launches a new feature, the business can push a similar feature to production immediately without waiting for IT to "schedule" the release.
    - **Reduced IT Bottlenecks**: By automating the pipeline and ensuring the software is always ready for release, IT no longer becomes a bottleneck. Instead, they focus on maintaining the pipeline and ensuring quality, while the business decides when to deploy.
    - **Alignment Between Teams**: This approach fosters better collaboration between business and IT teams, as both work toward delivering value to customers more efficiently.

---

#### **2. Making sure your software is always production ready throughout its entire lifecycle - that any build could potentially be released to users.**

This sentence emphasizes a core principle of **Continuous Delivery** and **Continuous Integration (CI)**: ensuring that the software is consistently in a state where it can be deployed to production at any time.

- **What Does "Production Ready" Mean?**
  - **Stable Codebase**: Every commit to the code repository should result in a build that passes all automated tests, including unit tests, integration tests, and end-to-end tests. If any test fails, the build is considered broken, and the issue must be resolved before proceeding.
  - **Automated Testing**: A robust suite of automated tests ensures that the software behaves as expected under various scenarios. This reduces the risk of introducing bugs or regressions into production.
  - **Consistent Environments**: Using tools like **Docker** or **Infrastructure as Code (IaC)** ensures that the application runs consistently across development, testing, and production environments. This eliminates the "it works on my machine" problem.
  - **Version Control**: All changes are tracked in version control systems like **Git**, ensuring that any build can be traced back to its source code and dependencies.

- **Why Is This Important?**
  - **Frequent Releases**: If every build is production-ready, the organization can release updates frequently—daily, hourly, or even multiple times a day—without worrying about introducing critical bugs.
  - **Risk Reduction**: Since every build is tested and validated, the risk of deploying faulty code to production is minimized. Even if an issue arises, it can be quickly rolled back or fixed because the changes are small and incremental.
  - **User Confidence**: Users receive high-quality updates more frequently, improving their experience and trust in the product. Additionally, frequent releases allow the organization to gather user feedback faster, enabling continuous improvement.

- **Lifecycle Perspective**:
  - **From Development to Production**: In traditional models, software might only become "production ready" after extensive manual testing and stabilization phases. However, in **Continuous Delivery**, the software is treated as production-ready from the moment it is committed to the repository. This means that developers write code with the assumption that it will be deployed to production immediately after passing all tests.
  - **Continuous Improvement**: Since the software is always in a deployable state, teams can continuously refine and improve it without worrying about large, risky deployments.

### Key Takeaways

1. **Empowering the Business**: **Continuous Delivery** shifts control over release schedules from IT to business stakeholders, allowing organizations to respond more quickly to market demands and customer needs. This improves agility and reduces bottlenecks caused by traditional IT processes.

2. **Always Production Ready**: **Continuous Delivery** ensures that every build is stable, tested, and ready for deployment. This allows organizations to release software frequently and confidently, knowing that each build meets the required quality standards. It also reduces the risk of major failures in production and enables faster feedback loops with users.

### Practical Example

Imagine a company developing a mobile app:

- **Without Continuous Delivery**: Developers work on multiple features for weeks, then hand the code to the IT team for testing and deployment. The IT team finds several issues, requiring developers to fix them. After weeks of back-and-forth, the app is finally released. Meanwhile, competitors have already launched similar features.

- **With Continuous Delivery**: Developers integrate their code daily, and automated tests ensure the app is always stable. The business decides to release a new feature as soon as it passes all tests. The feature is deployed to production within hours of being completed, giving the company a competitive edge.

---

### Conclusion

These two sentences encapsulate the essence of **Continuous Delivery**:

1. **Empowerment**: The business gains control over release schedules, enabling faster and more strategic decision-making.
2. **Reliability**: The software is always in a production-ready state, ensuring high-quality releases and reducing risks.

Together, these principles enable organizations to deliver value to customers faster, more reliably, and with greater alignment between business and technical teams.
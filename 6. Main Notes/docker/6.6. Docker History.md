# 6.6. Docker History

2025-08-09 10:49
Status: #DONE
Tags: [[Docker]]

---
### Understanding Docker History: A Deep Dive into Container Image Layers

When working with Docker, understanding how our images are constructed is crucial for optimizing builds, debugging issues, and managing storage efficiently. One powerful tool at our disposal is the `docker history` command, which provides a detailed history of an image's layers. Let’s break this down step by step, explore its usage, and analyze the output from our example.

#### What is `docker history`?

The `docker history` command allows us to inspect the build history of a Docker image, revealing the layers that make up the image and the commands that created each layer. Think of a Docker image as a stack of building blocks, where each block (layer) represents a step in the Dockerfile or an action that modified the image. The `docker history` command acts like a time machine, showing us how we stacked those blocks over time.

To use it, we simply run:
```
docker history <image_name>
```
For instance, if our image is named `customDockerImage`, we would execute:
```
docker history customDockerImage
```
This command lists all the layers in reverse chronological order (from the most recent to the oldest), including details like the command executed, creation time, size, and comments.

#### Analyzing the Output

Let’s dive into the output provided in our example. The `docker history` output is typically displayed in a tabular format with columns such as `IMAGE`, `CREATED`, `CREATED BY`, `SIZE`, and `COMMENT`. Here’s how we interpret each part based on the data:

![[6.6. Docker History Output for customDockerImage.png]]

**Description goes here**: The image shows the `docker history` output for an image named `customDockerImage` with the tag `python_hello:v1`. The table includes six rows, each representing a layer in the image. The columns provide the following details:
- **IMAGE**: A unique identifier (hash) for each layer, such as `84e12fbf47b`.
- **CREATED**: The timestamp when the layer was created, ranging from 11 hours ago to 6 weeks ago.
- **CREATED BY**: The command or instruction that generated the layer, such as `CMD ["/app/hello-world"]` or `ADD alpine-miniroots-3.22.0-x86_64.tar.gz /...`.
- **SIZE**: The size of each layer, varying from 0B to 8.31MB.
- **COMMENT**: Additional metadata, in this case, consistently labeled as `buildkit.dockerfile.v0`.

#### Detailed Explanation of Each Command in the Output

Let’s walk through each row in the output to understand the commands and their purposes:

1. **Layer with `CMD ["/app/hello-world"]`**
   - **Command**: `CMD ["/app/hello-world"]`
   - **Explanation**: The `CMD` instruction specifies the default command to run when a container starts from this image. Imagine it as telling a toy robot what to do when we press its "start" button. In this case, it runs the `hello-world` executable located at `/app/hello-world`. This is likely the entry point of our Python application.
   - **Size**: 7.35MB
   - **Created**: 11 hours ago

2. **Layer with `RUN /bin/sh -c chmod +x /app/hello-world # buildkit`**
   - **Command**: `RUN /bin/sh -c chmod +x /app/hello-world # buildkit`
   - **Explanation**: The `RUN` instruction executes a command during the image build process. Here, it uses the shell (`/bin/sh -c`) to run `chmod +x`, which changes the permissions of the `hello-world` file at `/app/hello-world` to make it executable. Think of this as giving our toy robot permission to move its arms. The `# buildkit` comment indicates this was processed by BuildKit, Docker’s modern build engine, which optimizes the build process.
   - **Size**: 7.35MB
   - **Created**: 11 hours ago

3. **Layer with `COPY /app/dist/hello-world /app/ # buildkit`**
   - **Command**: `COPY /app/dist/hello-world /app/ # buildkit`
   - **Explanation**: The `COPY` instruction copies files from the build context (our local directory) to the image’s filesystem. Here, it copies the `hello-world` file from `/app/dist/` in the build context to `/app/` in the image. This is like moving a toy part from our toolbox to the robot’s body during assembly.
   - **Size**: 7.35MB
   - **Created**: 11 hours ago

4. **Layer with `WORKDIR /app`**
   - **Command**: `WORKDIR /app`
   - **Explanation**: The `WORKDIR` instruction sets the working directory for subsequent instructions in the Dockerfile. It’s like telling our robot where to stand while we work on it—here, it’s `/app`. Any following `RUN`, `CMD`, or `COPY` commands will operate relative to this directory unless changed.
   - **Size**: 0B (no additional data is added, just a directory change)
   - **Created**: 13 hours ago

5. **Layer with `CMD ["/bin/sh"]`**
   - **Command**: `CMD ["/bin/sh"]`
   - **Explanation**: Another `CMD` instruction, this time setting the default command to `/bin/sh`, a simple shell. This might serve as a fallback if the primary `CMD` fails, acting like a backup plan for our robot to follow basic instructions if the main program doesn’t work.
   - **Size**: 0B
   - **Created**: 6 weeks ago

6. **Layer with `ADD alpine-miniroots-3.22.0-x86_64.tar.gz /...`**
   - **Command**: `ADD alpine-miniroots-3.22.0-x86_64.tar.gz /...`
   - **Explanation**: The `ADD` instruction copies files or archives into the image and can also extract archives. Here, it adds an Alpine Linux minimal root filesystem (a lightweight Linux distribution) from a tarball (`alpine-miniroots-3.22.0-x86_64.tar.gz`) to the root directory (`/`). This is the base layer, like the foundation on which we build our robot. The `...` indicates the full path might be truncated in the output.
   - **Size**: 8.31MB
   - **Created**: 6 weeks ago

#### Why and When Layers are Marked as `missing`?

In the output, some layers are marked as `missing`, such as the first three rows. This occurs for several reasons:

- **Layer Pruning**: Docker may remove unused or intermediate layers to save space, especially if we’ve run `docker image prune` or `docker system prune`. Think of this as cleaning up old toy parts we no longer need after finishing our robot.
- **BuildKit Optimization**: The `# buildkit` comment suggests BuildKit was used, which optimizes builds by merging or discarding intermediate layers. This can result in layers being marked as `missing` if they’re no longer referenced.
- **Image Re-tagging or Rebuilds**: If we rebuild or retag an image without preserving all layers (e.g., using `--no-cache`), older layers might be garbage-collected by Docker, leading to `missing` status.
- **Time Factor**: Layers created long ago (e.g., 6 weeks ago) might be deleted if the image is updated or if storage limits are reached, especially on systems with automatic cleanup.

The `missing` label doesn’t affect the functionality of the current image, as Docker only needs the final layer to run the container. However, it indicates that we can’t inspect or reuse those specific intermediate layers.

#### Comprehensive Table of `docker history` Arguments and Flags

Below is a detailed table covering all arguments and flags for the `docker history` command, including explanations and examples:

| **Argument/Flag**      | **Explanation**                                                                 | **Example**                          | **Default Behavior**            |
|-------------------------|---------------------------------------------------------------------------------|--------------------------------------|---------------------------------|
| `<image>`              | The name or ID of the image to inspect (required argument).                     | `docker history customDockerImage`   | N/A (must be provided)          |
| `--format` or `-f`     | Customizes the output format using a Go template (e.g., JSON, table).           | `docker history --format "{{.CreatedBy}}" customDockerImage` | Tabular output                  |
| `--human`              | Displays sizes in a human-readable format (e.g., MB, GB).                      | `docker history --human customDockerImage` | Enabled by default             |
| `--no-trunc`           | Shows the full length of the `CREATED BY` command instead of truncating it.     | `docker history --no-trunc customDockerImage` | Truncates long commands         |
| `--quiet` or `-q`      | Displays only the image IDs, suppressing other details.                         | `docker history -q customDockerImage` | Shows full table                |
| `--help`               | Displays help information for the command.                                     | `docker history --help`             | N/A                            |

- **`<image>`**: This is the core argument, specifying which image’s history we want to see. For example, `customDockerImage` in our case.
- **`--format`**: Allows us to tailor the output. For instance, `{{.CreatedBy}}` extracts only the commands, useful for scripting.
- **`--human`**: Ensures sizes like 8.31MB are readable, which is already the default in our output.
- **`--no-trunc`**: Useful for seeing the full `ADD alpine-miniroots-3.22.0-x86_64.tar.gz /...` command without the `...` ellipsis.
- **`--quiet`**: Handy for scripts where we only need layer IDs, e.g., to automate layer analysis.
- **`--help`**: Provides a quick reference if we forget the options.

#### Detailed Explanation of Output Values

- **IMAGE**: The unique hash (e.g., `84e12fbf47b`) identifies each layer. This hash is derived from the layer’s content, ensuring immutability. `missing` indicates the layer is no longer available locally.
- **CREATED**: The timestamp (e.g., 11 hours ago, 6 weeks ago) shows when the layer was built, helping us track the image’s evolution.
- **CREATED BY**: The Dockerfile instruction or command that created the layer (e.g., `CMD ["/app/hello-world"]`), providing insight into the build process. The `# buildkit` suffix confirms BuildKit usage.
- **SIZE**: The size of each layer (e.g., 7.35MB, 0B), reflecting the data added. A size of 0B (e.g., for `WORKDIR` or `CMD`) means no new files were added, only metadata or configuration changed.
- **COMMENT**: Metadata like `buildkit.dockerfile.v0` indicates the build tool and version, offering context about how the image was constructed.

#### Practical Insights and Best Practices

- **Optimizing Layers**: Notice that layers like `WORKDIR /app` and `CMD ["/bin/sh"]` have 0B sizes. We can minimize layers by combining commands (e.g., using `&&` in a single `RUN`) to reduce overhead.
- **Debugging**: If a layer is `missing`, we might need to rebuild the image with `--no-cache` to regenerate it:
  ```
  docker build --no-cache -t customDockerImage .
  ```
- **Storage Management**: Regularly pruning unused layers with `docker image prune` helps prevent `missing` layers from cluttering our system.
- **Security**: Ensure sensitive commands or files (e.g., API keys in `COPY`) aren’t exposed in the history by using `.dockerignore` to exclude them.

By mastering `docker history`, we gain a clear window into our image’s construction, enabling us to optimize builds, troubleshoot issues, and maintain efficient container environments.
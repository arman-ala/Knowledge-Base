# 6.2.1. Dockerfile Instructions - FROM

2025-08-09 19:43
Status: #DONE 
Tags: [[Docker]]

---
### Exploring the `FROM` Command in Dockerfile

#### Understanding the `FROM` Command with Simple Explanations

The `FROM` command is like the first step in building a house with Lego bricks. Imagine we’re starting with a big base plate (the base image) that gives us a solid foundation to add our own special pieces (our application). This base plate comes pre-made with some basic tools and materials, and we tell Docker which one to use with the `FROM` command. It’s the starting point for every Dockerfile, telling us what operating system or environment we’re building on top of.

For someone new to this, think of it like choosing a pre-baked cake mix from the store. We pick one (like chocolate or vanilla) and then add our own frosting and decorations. The `FROM` command picks that initial mix. Most of the time, we use it once at the beginning, but in some clever cases, we can use it multiple times to create a multi-stage build, which is like baking two different cakes and then picking the best parts to make one perfect dessert.

Technically, the `FROM` instruction specifies the base image for the build process. It must be the first non-comment instruction in a Dockerfile unless it follows an `ARG` instruction used to define build arguments. The base image provides the runtime environment, including the operating system, libraries, and dependencies. There are two primary forms: the simple single-stage `FROM` and the multi-stage `FROM`, which we’ll explore in detail.

#### Single-Stage `FROM` Command

In its simplest form, the `FROM` command is used once to define a single base image. This is the most common approach for straightforward applications. Let’s look at some examples:

1. **Using Go 1.24**
   ```
   FROM golang:1.24
   ```
   Here, we start with the official Go 1.24 image, which includes the Go programming language environment. This is ideal for building Go-based applications, providing us with the compiler and standard library out of the box.

2. **Using Alpine:latest**
   ```
   FROM alpine:latest
   ```
   Alpine is a lightweight Linux distribution, and `alpine:latest` gives us the most recent version. It’s like choosing a tiny, efficient base plate, perfect for creating small, fast containers when we want to save space.

3. **Using Python 3.13.3**
   ```
   FROM python:3.13.3
   ```
   This selects the Python 3.13.3 image, offering a complete Python runtime. It’s great for Python developers who need a specific version to run their scripts or applications.

4. **Using Nginx:latest**
   ```
   FROM nginx:latest
   ```
   Nginx is a popular web server, and `nginx:latest` provides the latest Nginx environment. This is a good starting point for hosting websites or reverse proxies.

In each case, the `FROM` command pulls the specified image from a registry (usually Docker Hub) and sets it as the foundation. We can then add our custom instructions (like installing packages or copying files) on top.

#### Multi-Stage `FROM` Command

Multi-stage builds allow us to use multiple `FROM` commands to create different build environments within the same Dockerfile. This is like baking a cake in two ovens: one to mix the batter and another to add the frosting, then combining the best results. It’s especially useful for reducing the final image size by separating the build process from the runtime environment. This technique became a best practice after Docker’s architecture evolved, particularly post-2017.

Here are some examples:

1. **Building a Go Application**
   ```
   FROM golang:1.24 AS builder
   WORKDIR /app
   COPY . .
   RUN go build -o myapp
   FROM alpine:latest
   WORKDIR /app
   COPY --from=builder /app/myapp .
   CMD ["./myapp"]
   ```
   - The first `FROM golang:1.24 AS builder` sets up a build environment with Go 1.24 and names it `builder`.
   - We copy the source code, build the application, and create an executable (`myapp`).
   - The second `FROM alpine:latest` starts a new stage with a lightweight Alpine image.
   - We copy the `myapp` executable from the `builder` stage using `COPY --from=builder`, resulting in a small runtime image.

2. **Building a Python Application**
   ```
   FROM python:3.13.3 AS build
   WORKDIR /app
   COPY requirements.txt .
   RUN pip install -r requirements.txt
   FROM alpine:latest
   WORKDIR /app
   COPY --from=build /app /app
   CMD ["python", "/app/main.py"]
   ```
   - The first `FROM python:3.13.3 AS build` creates a build stage with Python 3.13.3.
   - We install dependencies listed in `requirements.txt`.
   - The second `FROM alpine:latest` sets up a runtime stage, copying only the necessary files from the build stage.

3. **Building an Nginx Web Server**
   ```
   FROM nginx:latest AS nginx-base
   WORKDIR /usr/share/nginx/html
   COPY index.html .
   FROM alpine:latest
   COPY --from=nginx-base /usr/share/nginx/html /usr/share/nginx/html
   CMD ["nginx", "-g", "daemon off;"]
   ```
   - The first `FROM nginx:latest AS nginx-base` prepares an Nginx environment.
   - We copy a custom `index.html` file.
   - The second `FROM alpine:latest` creates a minimal runtime image, copying only the HTML files.

4. **Combining Multiple Languages**
   ```
   FROM golang:1.24 AS go-builder
   WORKDIR /go
   COPY go.mod .
   RUN go mod download
   FROM python:3.13.3 AS python-builder
   WORKDIR /python
   COPY requirements.txt .
   RUN pip install -r requirements.txt
   FROM alpine:latest
   COPY --from=go-builder /go /go
   COPY --from=python-builder /python /python
   CMD ["/bin/sh"]
   ```
   - Two build stages (`go-builder` and `python-builder`) handle Go and Python dependencies.
   - The final `FROM alpine:latest` combines the outputs into a lightweight image.

The `AS` keyword assigns a name to each stage, allowing us to reference it with `COPY --from`. This approach eliminates unnecessary build tools and dependencies in the final image, enhancing security and efficiency.

#### Key Takeaways

- The `FROM` command is the cornerstone of a Dockerfile, defining the base image for our build.
- In single-stage builds, we use `FROM` once to set a single base image (e.g., `golang:1.24`, `alpine:latest`, `python:3.13.3`, `nginx:latest`).
- Multi-stage builds use multiple `FROM` commands to separate build and runtime environments, optimizing the final image size and leveraging tools like `COPY --from`.
- Naming stages with `AS` enables flexible copying between stages, a technique widely adopted for modern applications like nginx.

By mastering the `FROM` command in both its forms, we can create efficient, tailored Docker images for any project.
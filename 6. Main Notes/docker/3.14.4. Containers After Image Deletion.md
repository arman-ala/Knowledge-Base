## Why Does the Container Still Exist After Deleting the Image?

![[3.14.4_image-1.png]]

### Understanding the Scenario
The `docker ps -a` output shows a container named `hungry_hopper` (ID `cc2ef23a2aa2`) with the image `hello-world:latest`, which has the status `Exited (0) 2 hours ago`. You then ran `docker rmi hello-world:latest`, and the output confirms the image was deleted:

- `Untagged: hello-world:latest`
- `Untagged: hello-world@sha256:7e1a4e2d11e2ac7a80c3f768d416c2defeb09d2a750b01412b6ea13de1efb19`
- `Deleted: sha256:74cc5e427dc41bb10dc4b2226072d469509f2f2f1a3ce74f4a5961a1d44602`

The `docker images` output after this command no longer lists `hello-world:latest`, confirming the image is gone. However, the `docker ps -a` output still shows the `hungry_hopper` container, which was created from `hello-world:latest`.

### Explanation
**Containers and images are independent entities in Docker.** When you create a container from an image (e.g., with `docker run hello-world:latest`), Docker uses the image to set up the container’s filesystem and configuration. Once the container is created, it becomes a separate entity with its own writable layer, which is stored on disk independently of the image. Here’s why the container persists:

- **Image Deletion Doesn’t Affect Existing Containers**: Deleting an image with `docker rmi` removes the image’s layers and metadata from your system, but it doesn’t automatically delete containers created from that image. The container `hungry_hopper` already has its own copy of the filesystem (based on the `hello-world:latest` image at the time it was created), so it remains intact even after the image is deleted.
  
- **Container State**: The `hungry_hopper` container is in an `Exited` state, meaning it’s stopped but still exists on your system. Docker retains stopped containers until you explicitly remove them with `docker rm`. Since you didn’t remove the container (e.g., with `docker rm hungry_hopper`), it continues to exist, and `docker ps -a` still lists it.

- **Image Reference in Container Metadata**: The `docker ps -a` output still shows the image name `hello-world:latest` for `hungry_hopper` because Docker stores the image name as part of the container’s metadata when the container is created. Even though the image itself is deleted, the metadata reference remains, which is why the container still lists `hello-world:latest` as its image.

### Why the Attempt to Delete the Image Failed Initially
Before successfully deleting the image, you ran `docker rmi hello-world:latest` and got an error:

- `Error response from daemon: conflict: unable to remove repository reference "hello-world:latest" (must force) - container cc2ef23a2aa2`

This error occurred because the container `hungry_hopper` (ID `cc2ef23a2aa2`) was using the `hello-world:latest` image. Docker prevents image deletion if a container (even a stopped one) depends on it, to avoid potential issues with container metadata. You then used `docker rmi -f hello-world:latest`, which forced the removal of the image by also removing the dependency (the stopped container’s reference to the image), allowing the deletion to succeed.

### What You Can Do
To fully clean up:
- **Remove the Container**: Run `docker rm hungry_hopper` to delete the stopped container. Since it’s already stopped, this will work without issues.
- **Automate Cleanup**: If you want to avoid lingering containers, you can use the `--rm` flag when running containers (e.g., `docker run --rm hello-world:latest`), which automatically removes the container when it exits.
- **Prune Stopped Containers**: Use `docker container prune` to remove all stopped containers, which would include `hungry_hopper`, freeing up space and avoiding confusion.

## Why Do I Get "Already Exists" When Pulling `hello-world` After Deleting It?

### Understanding the Scenario
After deleting `hello-world:latest` with `docker rmi -f hello-world:latest`, you likely tried to pull the image again with `docker pull hello-world`. You mentioned getting an "Already exists" message, even though you deleted the image just minutes ago. Let’s break this down.

### Explanation
**Docker’s Layer Caching and Pull Behavior**: When you pull an image with `docker pull`, Docker checks if the image (or its layers) already exists on your system by comparing the image’s digest (a unique hash of its content). Here’s what’s happening:

- **Image Layers Were Not Fully Deleted**: The `docker rmi -f hello-world:latest` command deleted the `hello-world:latest` tag and its associated metadata, as shown in the output (`Untagged` and `Deleted` lines). However, Docker’s storage system uses a layered architecture, and some layers might still be present on your system if they’re shared with other images or containers. The `docker images` output no longer lists `hello-world:latest`, but the underlying layers (e.g., `sha256:74cc5e427dc4...`) might still be cached.

- **Pulling Checks the Digest**: When you ran `docker pull hello-world`, Docker contacted the registry (Docker Hub by default) to fetch the `hello-world:latest` image. The registry provides the image’s digest (e.g., `hello-world@sha256:7e1a4e2d11e...`). Docker then checked its local storage and found that the layers for this digest already exist on your system. Instead of re-downloading, Docker reuses the cached layers and re-tags them as `hello-world:latest`, which is why you see "Already exists" in the pull output.

- **No Network Activity for Cached Layers**: The "Already exists" message typically appears in the `docker pull` output when Docker determines that a layer (or the entire image) is already present locally. For example, the output might look like:

```
latest: Pulling from library/hello-world
7e1a4e2d11e2: Already exists
Digest: sha256:7e1a4e2d11e2ac7a80c3f768d416c2defeb09d2a750b01412b6ea13de1efb19
Status: Image is up to date for hello-world:latest
```

  This indicates that Docker didn’t need to download anything because the layers were already on your system.

- **Why Were the Layers Still There?**: Even though you deleted `hello-world:latest`, the layers might have been retained because:
  - **Shared Layers**: If another image on your system (e.g., another version of `hello-world` or a different image) shares the same layers, Docker keeps those layers to avoid breaking other images.
  - **Incomplete Cleanup**: The `docker rmi` command removes the image’s metadata and unique layers, but shared layers remain. You’d need to use `docker system prune --all` to remove all unused layers, but this can affect other images, so use it cautiously.

**Even If You Force Removal The Image**:
- `docker rmi -f X` will only remove the **image tag** (the human-readable name like `nginx:latest`), <mark style="background: #FFF3A3A6;">but the underlying image layers remain on disk if containers still reference them (now as "dangling" layers)</mark>
### Why the Container Didn’t Cause This
The container `hungry_hopper` (ID `cc2ef23a2aa2`) was created from `hello-world:latest`, but its presence doesn’t directly cause the "Already exists" message. Containers have their own writable layer, and while they reference the image’s layers, they don’t prevent the image’s layers from being deleted unless the container is actively using them (e.g., running). Since `hungry_hopper` is stopped, and you used `docker rmi -f`, the image was removed, but the layers might have been retained due to caching or sharing.

### What You Can Do
To avoid the "Already exists" message and ensure a fresh pull:
- **Force a Fresh Pull**: Use `docker pull --no-cache hello-world` to force Docker to re-download the image, though this flag isn’t always supported for `docker pull`. Alternatively, you can remove all cached layers with `docker system prune --all`, but this will remove all unused images and layers, potentially affecting other images like `nginx` or `centos`.
- **Verify the Image Digest**: After pulling, run `docker images --digests` to see the digest of `hello-world:latest`. If it matches the digest from the registry (e.g., `sha256:7e1a4e2d11e...`), the image is up to date, and the "Already exists" message is just Docker optimizing the pull process.
- **Clean Up Thoroughly**: If you want to ensure no layers are cached, stop and remove all containers using the image, delete the image, and then prune unused layers with `docker system prune`. Be cautious, as this can remove layers used by other images.

## Key Takeaways
- **Containers Persist After Image Deletion**: Deleting an image doesn’t remove containers created from it because containers are independent entities with their own filesystem. Use `docker rm` to clean up stopped containers.
- **"Already Exists" During Pull**: This message appears because Docker reuses cached layers that match the image’s digest, even after you delete the image. This is an optimization to avoid redundant downloads.
- **Managing Disk Space**: To fully clean up, remove containers with `docker rm`, delete images with `docker rmi`, and prune unused data with `docker system prune` or `docker container prune`.

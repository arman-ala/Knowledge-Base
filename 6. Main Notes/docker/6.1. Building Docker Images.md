# 6.1. Building Docker Images

2025-08-09 19:43
Status: #DONE 
Tags: [[Docker]]

---
### Understanding and Building Custom Docker Images

#### Introduction to Docker Images and Dockerfiles

Building a custom Docker image is an essential skill for managing applications efficiently. At its core, a Docker image is a lightweight, portable package that contains everything needed to run an application, including the code, runtime, libraries, and dependencies. To create this image, we use a special text file called a `Dockerfile`. Think of a `Dockerfile` like a recipe for baking a cake: it lists step-by-step instructions to combine different ingredients (or layers) to create the final product.

The process begins with selecting a base image, which serves as the foundation for our custom image. This is similar to starting with a pre-made cake mix before adding our unique flavors. The `Dockerfile` typically starts with a `FROM` instruction to specify this base image, and it may include multiple `FROM` statements in what is known as a multi-stage build. This technique, particularly useful for optimizing images like those used with nginx, was once considered a poor practice but has become a recommended approach since architectural changes in Docker around 2017.

#### Step-by-Step Process of Building a Docker Image

To build a custom image, we rely on the `docker build` command, which constructs an image from a `Dockerfile` and a context. Let’s break this down with an example to make it clear.

Imagine your computer is like a kitchen, and the Docker daemon is like a master chef working in the background. The context is like a box of ingredients we send to the chef. When we run the `docker build` command, the first thing that happens is that we send this entire box (all files in the directory, recursively) to the daemon, not the command-line interface (CLI) itself. This ensures the chef has everything needed to follow the recipe.

Here’s how we do it with the example:

```
cd /docker/myimage && docker build -t mycentos:v1 .
```

- **`cd /docker/myimage && docker build -t mycentos:v1 .`**: This command changes the directory to `/docker/myimage` and then builds the image. The `-t mycentos:v1` option tags the image with the name `mycentos` and version `v1`. The dot (`.`) at the end tells Docker to use the current directory as the context, which contains the `Dockerfile` and any necessary files.

Next, we define the instructions in the `Dockerfile`. For instance:

```
FROM centos:latest
```

- **`FROM centos:latest`**: This line specifies that our custom image will be based on the latest version of the CentOS operating system image. It’s the starting point, like choosing a basic cake mix.

The build process then executes these steps, as shown in the output:

```
Step 1/2 : FROM centos:latest
 ---> 0fe0e7c013bf
Step 2/2 : CMD ["/bin/bash"]
 ---> Running in 5e844557e6a9
Removing intermediate container 5e844557e6a9
 ---> 257c5e169928
Successfully built 257c5e169928
Successfully tagged mycentos:v1
```

- **Build Steps**: The output shows two steps. The first step pulls the `centos:latest` image (identified by its unique ID `0fe0e7c013bf`). The second step adds a `CMD` instruction, which specifies the default command to run when the container starts—in this case, `/bin/bash`, which opens a command-line shell. During this process, Docker creates temporary containers (e.g., `5e844557e6a9`) to build layers and then removes them.
- **Tagging**: The image is successfully tagged as `mycentos:v1` with the ID `257c5e169928`.

Finally, we can run the image to start a container:

```
docker run -it mycentos:v1
```

- **`docker run -it mycentos:v1`**: This command launches a container from the `mycentos:v1` image. The `-it` flags make it interactive, allowing us to type commands directly in the container’s shell, much like sitting down to use the cake we baked.

#### Best Practices for Building Docker Images

To ensure an efficient build process, it is recommended to start with an empty directory as the context and place the `Dockerfile` within it. Only include the files necessary for building the image to avoid sending unnecessary data to the daemon. This is akin to packing only the ingredients we need for the cake, keeping the kitchen tidy and the process smooth.

#### Technical Explanation

From a technical perspective, the `docker build` command initiates a client-server interaction where the Docker CLI sends the build context to the Docker daemon. The daemon, a background service, processes the `Dockerfile` instructions, layering each command to create a new image. The multi-stage build approach, utilizing multiple `FROM` statements, optimizes the final image size by discarding intermediate build artifacts, which is particularly beneficial for production environments like those running nginx. The `CMD` instruction, as seen in the example, defines the executable that runs when the container starts, ensuring the container has a default operational state.

By following these steps and best practices, we can create robust, efficient Docker images tailored to our needs.
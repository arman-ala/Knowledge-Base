# 3.14.1. Deleting a Docker Image

2025-08-09 18:41
Status: #DONE 
Tags: [[Docker]]

---
## Understanding `docker rmi`: Scenarios and Situations Explained

**consider these outputs**:
![[3.14.1_base.png]]

### Situations from the Image

#### 1. Attempting to Remove a Non-Existent Image
**Command**: 

```bash 
docker rmi mycentos:latest
```

**Output**: 

![[3.14.1_img-1.png]]

**Explanation**:  
Here, the user tried to remove an image tagged `mycentos:latest`, but Docker couldn’t find it on the system. The `docker images` output confirms that while there is a `mycentos` repository with a `v2009` tag, there’s no `mycentos:latest`. This error occurs when the specified image tag doesn’t exist. Docker is strict about matching the exact repository and tag, so if the image isn’t present, it throws this error.

#### 2. Attempting to Remove an Image with a Non-Existent Tag
**Command**: 

```bash
docker rmi mycentos:v3
```

**Output**:

![[3.14.1_img-2.png]]

**Explanation**:  
In this case, the user attempted to remove the `mycentos:v3` tag. The `docker images` output doesn’t list `mycentos:v3`, but the earlier `docker inspect` output (from your previous query) showed that the `centos:centos7.9.2009` image also had the tag `mycentos:v3`. When `docker rmi mycentos:v3` is run, Docker removes the `v3` tag from the image, leaving the other tag (`centos:centos7.9.2009`) intact. This is why the output says "Untagged" rather than fully removing the image—because the image itself still exists under a different tag.

#### 3. Attempting to Remove an Image Used by a Running Container
**Command**: 

```bash
docker rmi centos:centos7.9.2009
```

**Output**:

![[3.14.1_img-3.png]]

**Explanation**:  
Here, the user tried to remove the `centos:centos7.9.2009` image, which has the image ID `eeb6ee3f44bd`. However, the `docker ps` output shows a running container (`440b2afc20b0`, named `epic_herschel`) that was created from this image. Docker prevents the removal of an image if a running container depends on it, to avoid breaking the container. The error message suggests using the `--force` (or `-f`) flag to override this protection, but that would also stop and remove the container, which might not be desired.

#### 4. Attempting to Remove an Image by ID While It’s Used by a Running Container
**Command**: 

```bash
docker rmi -f eeb6ee3f44bd
```

**Output**:

![[3.14.1_img-4.png]]

**Explanation**:  
The user tried to force-remove the image with ID `eeb6ee3f44bd` (which corresponds to `centos:centos7.9.2009`) using the `-f` flag. Despite the force flag, Docker still refuses to remove the image because the container `440b2afc20b0` (named `epic_herschel`) is actively running and using this image. Docker’s behavior here is a safety mechanism: even with `--force`, it won’t delete an image if a running container depends on it. You’d need to stop the container first (e.g., with `docker stop 440b2afc20b0`) before removing the image.

#### 5. Successfully Removing an Image with No Dependencies
**Command**: 

```bash
docker rmi hello-world:latest
```  

**Output**:

![[3.14.1_img-5.png]]

**Explanation**:  
In this scenario, the user ran `docker rmi hello-world:latest` to remove the `hello-world:latest` image. The output shows that Docker successfully removed the image because it wasn’t being used by any containers—running or stopped. First, Docker untags the image (Untagged: hello-world:latest), along with its digest reference (hello-world@sha256:7e1...). Then, it deletes the image layers, as indicated by the Deleted lines, which list the layer IDs (sha256:74cc5e4... and sha256:63a4102...). This matches the image ID 74cc5e42e7dc4 seen in the previous docker images output, confirming the image was fully removed. Since `hello-world:latest` was only 10.1 kB, this freed up a small amount of space, and the process completed without issues.

#### 6. Removing an Image Used by a Stopped Container
**Command**: `docker rmi nginx:latest`  
**Expected Output**: `Error response from daemon: conflict: unable to remove repository reference "nginx:latest" (must force) - container <container_id> is using its referenced image 53a18edff809`

**Explanation**:  
The `nginx:latest` image (ID `53a18edff809`) isn’t being used by any running containers, as per the `docker ps` output. However, if there’s a stopped container that was created from this image, Docker will still block the removal with a similar "conflict" error. You can either:
- Use `docker rmi -f nginx:latest` to force the removal, which <mark style="background: #FFF3A3A6;">will also delete the stopped container</mark>.
- Or, manually remove the stopped container first with `docker rm <container_id>`, then run `docker rmi nginx:latest`.

#### 7. Removing Multiple Images at Once
**Command**: `docker rmi hello-world:latest mycentos:v2009`  
**Expected Output**:  
`Untagged: hello-world:latest`  
`Deleted: sha256:74cc5e42e7dc4...`  
`Untagged: mycentos:v2009`  
`Deleted: sha256:53a18edff809...`

**Explanation**:  
You can pass multiple image names or IDs to `docker rmi` to remove them in one go. Here, both `hello-world:latest` and `mycentos:v2009` (ID `53a18edff809`) are not in use by any containers. Docker will remove both images successfully, untagging and deleting their layers. If any of the images were in use, Docker would throw a conflict error for that specific image and continue with the others.

#### 8. Removing an Image with Shared Layers
**Command**: `docker rmi centos:centos7.9.2009` (after stopping the container)  
**Expected Output**: `Untagged: centos:centos7.9.2009`  
`Deleted: sha256:eeb6ee3f44bd...`

**Explanation**:  
Once the container `epic_herschel` is stopped (e.g., with `docker stop 440b2afc20b0`), you can remove the `centos:centos7.9.2009` image. However, if another image on your system shares layers with this image (e.g., another CentOS-based image), Docker will only remove the unique layers and metadata for `centos:centos7.9.2009`. The shared layers will remain on disk to avoid breaking other images, which is why the reported size reduction might be smaller than the image’s total size (204 MB).

#### 9. Using `docker rmi` with a Dangling Image
**Command**: `docker rmi $(docker images -f "dangling=true" -q)`  
**Expected Output**: `Deleted: sha256:<dangling_image_id>...`

**Explanation**:  
Dangling images are those tagged as `<none>`, often created as intermediate images during a build process (e.g., if you rebuild an image with the same tag). The command `docker images -f "dangling=true" -q` lists the IDs of dangling images, and `docker rmi` removes them. Since dangling images are typically not in use, this command usually succeeds without issues, helping you clean up unused images and reclaim space.

#### 10. Permission Issues When Removing an Image
**Command**: `docker rmi nginx:latest`  
**Expected Output**: `Error response from daemon: permission denied`

**Explanation**:  
If you don’t have sufficient permissions to access Docker (e.g., you’re not in the `docker` group or lack root privileges on a Linux system), you might encounter a "permission denied" error. This isn’t directly related to the image’s state but rather to your user’s access rights. To fix this, you can run the command with `sudo` (e.g., `sudo docker rmi nginx:latest`) or ensure your user is added to the `docker` group with `sudo usermod -aG docker $USER`.

### Key Takeaways and Tips
- Always check for running or stopped containers with `docker ps` and `docker ps -a` before removing an image to avoid conflicts.
- Use the `--force` flag cautiously, as it can remove containers (both stopped and running) that depend on the image.
- If you’re cleaning up, consider using `docker image prune` to remove all unused images safely, or `docker system prune` to clean up images, containers, and more in one go.
- Be mindful of shared layers—removing one image might not free up as much space as expected if other images share its layers.
# 3.4.1. The First Process of a Container

2025-08-09 18:39
Status: #DONE 
Tags: [[Docker]]

---
### Understanding Processes and PID 1 in Linux

In all operating systems, processes are responsible for executing tasks. One of the most critical processes in Linux is the one with PID 1. Traditionally known as `init` or, in modern distributions, `systemd`, this process is responsible for initializing and managing other processes in the system. However, the behavior of PID 1 differs significantly in the context of containers.

---

### Running a CentOS Container with Docker

To explore this behavior, we execute the following command to run a container using the CentOS image:

```
docker run centos:centos7.9.2009 /bin/bash
```

This command starts a container based on the `centos:centos7.9.2009` image and launches `/bin/bash` as the entrypoint process.

---

### Inspecting Running Processes in the Container

After the container starts, we run the following command to view the running processes:

```
ps aux
```

![[3.4.1_result_ps_aux.png]]

The output shows only two processes: `/bin/bash` and `ps aux`. The `ps aux` command itself is a temporary process that terminates after displaying the process list, leaving only one process running: `/bin/bash` with PID 1.

---

### Why PID 1 Behaves Differently in Containers

This observation might seem surprising because PID 1 is typically associated with `systemd` or `init` in a full Linux system. However, in a Docker container, PID 1 is assigned to the entrypoint process of the container—in this case, `/bin/bash`. This is a key difference in containerized environments: the process with PID 1 is the main application process defined by the container's entrypoint or command. For example, if you were to run an Nginx image, the `nginx` process itself would take PID 1, not `systemd` or any other init system. Containers are lightweight and do not run a full init system like a traditional OS; instead, they run a single foreground process as PID 1, which explains why `systemd` is not present in this scenario.

---

### Exiting the Container and Observing the Hostname

To exit the container, you can type `exit` or press `Ctrl + D`. Additionally, if you inspect the container's hostname, you'll notice that it is set to the container's unique ID. This is a default behavior in Docker unless a custom hostname is specified.

as you can see the container is now exited:
![[3.4.1_result_docker_ps-1.png]]

To keep the container up but exited, use `ctrl+p+q`.
![[3.4.1_result_docker_ps-2.png]]

---

### Analyzing Container Processes with `ps aux` and `grep`

```bash
ps aux | grep docker
```

![[3.4.1_result_ps_aux 1.png]]
The image shows the output of a `ps aux | grep docker` command, which is used to list processes related to Docker and its components. The goal here is to demonstrate that `containerd` and `dockerd`, which were previously discussed, are running automatically in the background. Additionally, when a container is run in detached mode, it becomes visible as a distinct process. Within the process details, we can also observe components like `shim` and `runc`, whose roles were explained earlier.

```bash
docker run -itd centos:centos7.9.2009
```

```bash
ps aux | grep containerd
```

![[3.4.1_docker_run.png]]

#### Processes Overview

- **dockerd**: The Docker daemon (`dockerd`) is the core process that manages Docker containers, images, networks, and volumes. It listens for Docker API requests and handles container lifecycle operations. In the output, we see multiple `dockerd` processes, such as:
  - `root 1376 0.0 2.9 2264112 58060 ? Ssl 13:19 0:02 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock`
  - This process is the main Docker daemon, running with the `--containerd` flag to communicate with `containerd` via a socket.

- **containerd**: This is a container runtime that manages the lifecycle of containers at a lower level. It is used by `dockerd` to handle container operations. The output shows:
  - `root 1239 0.0 1.5 1800796 27248 ? Ssl 13:19 0:04 /usr/bin/containerd`
  - This indicates that `containerd` is running as a background process, managing container execution.

- **Container Process (shim and runc)**: When a container is run in detached mode (e.g., using `docker run -d`), it appears as a separate process. The output includes:
  - `root 14263 0.4 0.9 1238246 16308 ? S 15:03 0:00 /usr/bin/containerd-shim-runc-v2 -namespace moby -id 6b4a542a0837d4be69533a760d752f31f4ea5309b46d37b2eb89f3eef72e435 -address /run/containerd/containerd.sock`
  - This process represents a running container. The `containerd-shim-runc-v2` (or `shim`) is a small binary that acts as an intermediary between `containerd` and the container's runtime (`runc`). The `shim` ensures that the container process remains running even if `containerd` restarts, and it handles tasks like managing the container's standard input/output streams. The `-id` flag specifies the container's unique ID, and the `-address` flag points to the `containerd` socket for communication.

- **runc**: While `runc` itself is not directly visible in the process list (as it is short-lived), it is the underlying runtime invoked by `containerd-shim-runc-v2`. `runc` is responsible for creating and starting the container by setting up its namespaces, cgroups, and other low-level configurations.

#### Additional Context and tips

The `grep` commands in the output, such as `grep --color=auto docker`, are used to filter and highlight Docker-related processes. The presence of multiple `dockerd` and `containerd` processes might indicate subprocesses or threads spawned by these daemons, which is normal behavior. Additionally, the container's unique ID (`6b4a542a0837d4be69533a760d752f31f4ea5309b46d37b2eb89f3eef72e435`) matches the hostname of the container, as seen in previous examples, which is a default Docker behavior unless overridden.

---

## Modifying the Default Command of a CentOS Container

As observed in the image, the default command of a CentOS container, which is typically to run `/bin/bash`, can be overridden to execute a different task. In the examples shown, the container’s mission is changed in two cases: one to execute `ping 8.8.8.8` and the other to run the `top` command. This demonstrates how Docker allows flexibility in defining the container’s entrypoint command during creation.

#### Case 1: Running a Ping Command
In the first example, the container is launched with the following command:
```bash
docker run -it --name testing_ping centos:centos7.9.2009 ping 8.8.8.8
```

Here, the `ping 8.8.8.8` command replaces the default `/bin/bash` as the container’s entrypoint. The `-it` flag ensures the container runs interactively with a terminal, allowing the user to see the output of the `ping` command. The container is named `testing_ping` using the `--name` flag.

The output shows:
- The `ping` command sends three packets to `8.8.8.8` (Google’s public DNS server).

Since the `ping` command was interrupted by pressing `Ctrl+C`, the container stops immediately after the command terminates. This is because <mark style="background: #FF5582A6;">a Docker container’s lifecycle is tied to its entrypoint process: when the main process (PID 1) exits, the container exits as well. In this case, `ping` was the main process, and its termination caused the container to stop</mark>.

#### Case 2: Running an Empty Container (Default Command)
In the second example, the container is launched with:
```bash
docker run -it --name testing_empty centos:centos7.9.2009
```

No command is specified, so the container uses the default entrypoint defined in the `centos:centos7.9.2009` image, which is `/bin/bash`. The `-it` flag again ensures an interactive terminal session. The user then exits the container (likely by typing `exit` or pressing `Ctrl+D`), as indicated by the `[root@5701c44fbac14 /]# exit` prompt.

When the `/bin/bash` process exits, the container stops because the main process (PID 1) has terminated. This reinforces the principle that a container remains running only as long as its entrypoint process is active.

#### Case 3: Running the `top` Command
In the third example, the container is launched with:
```bash
docker run -it --name testing_top centos:centos7.9.2009 top
```

Here, the `top` command is specified as the entrypoint, replacing the default `/bin/bash`. The `top` command displays real-time system resource usage, including CPU, memory, and running processes.

Since `top` runs interactively, the container remains active until the user exits the `top` command (e.g., by pressing `q`). Once `top` terminates, the container stops because the main process (PID 1) has exited.

![[3.4.1_result_docker_run-2.png]]

![[3.4.1_result_docker_ps-2 1.png]]


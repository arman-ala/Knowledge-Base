# 4.2. Docker Storage Options, Arguments, Permissions, and Examples

2025-08-09 10:49
Status: #DONE
Tags: [[Docker]]

---

# Managing Persistent Data with Docker Volumes

We're working with Docker to manage persistent data for our containerized applications using the `centos:latest` image. In this guide, we'll walk through creating and using Docker volumes, demonstrate their persistence across container lifecycles, and explore best practices. We'll also provide a detailed table of all possible arguments and options for the `docker volume` command, along with example commands for each. Additionally, we'll clarify the differences between named and anonymous volumes to help us make informed decisions.

## Creating a Docker Volume

Let’s start by creating a named volume called `myvol` to store data that needs to persist beyond the lifecycle of a container.

```bash
docker volume create myvol
```

![[4.2_img-1.png]]

After running this command, Docker creates a volume named `myvol`. We can verify its creation by checking the directory where Docker stores volumes on the host, typically at `/var/lib/docker/volumes/`. If we navigate to this directory (e.g., `sudo ls -l /var/lib/docker/volumes/`), we’ll see a subdirectory named `myvol` containing a `_data` folder where the volume’s data is stored. At this point, we’ve only created the volume—we haven’t used it in a container yet.

## Using the Volume in a Container

Now, let’s create a container named `centos_with_vol` using the `centos:latest` image and mount our `myvol` volume to a directory inside the container called `/myPersistentData`.

```bash
docker run -it --name centos_with_vol -v myvol:/myPersistentData centos:latest
```

![[4.2_img-2.png]]

Inside the container, we can navigate to `/myPersistentData` and create a file, say `file1`, using the `touch` command:

```bash
cd /myPersistentData/
touch file1
```

This file is now stored in the `myvol` volume on the host at `/var/lib/docker/volumes/myvol/_data/`. We can confirm this by exiting the container and checking the host directory (e.g., `sudo ls -l /var/lib/docker/volumes/myvol/_data/`), where we’ll see `file1`.

## Demonstrating Volume Persistence

To show that volumes persist even after a container is removed, let’s remove the `centos_with_vol` container:

```bash
docker rm -f centos_with_vol
```

After removing the container, we can check the volume’s data directory on the host again:

```bash
ls -l /var/lib/docker/volumes/myvol/_data/
```

![[4.2_img-3.png]]

We’ll see that `file1` is still there, proving that the volume and its data persist independently of the container.

## Data Propagation
Data propagation refers to how data is shared and synchronized between a container and a volume. When you mount an empty volume to a directory within a container that already contains files, Docker automatically copies those existing files into the newly attached volume. This ensures that the volume starts with the same data as the container's directory, allowing for seamless data sharing or persistence. Additionally, if you specify a volume that does not yet exist when starting a container, Docker will create an empty volume for you. This behavior simplifies data management and facilitates efficient sharing of data across multiple containers.

Now, let’s create a new container named `centos_with_vol_2` and mount the same `myvol` volume to a directory called `/myPersistentData_2`:

```bash
docker run -it --name centos_with_vol_2 -v myvol:/myPersistentData_2 centos:latest
```

Inside this new container, we can navigate to `/myPersistentData_2` and list the contents:

```bash
cd /myPersistentData_2/
ls -l
```

![[4.2_img-4.png]]

We’ll see `file1` from the previous container, confirming that the data persists and is accessible to the new container. Let’s add another file, `file2`, to the volume:

```bash
touch file2
```

Now, the volume contains both `file1` and `file2`, and this data will remain available for any future containers that mount the `myvol` volume.

## Using a Bind Mount (With a Note on Best Practices)

We can also mount a specific host directory into a container using a bind mount. For example, let’s create a container named `centos_custom_vol` and bind-mount the host’s `/home` directory to `/SharedData` inside the container:

```bash
docker run -it --name centos_custom_vol -v /home:/SharedData centos:latest
```

Inside the container, anything in the host’s `/home` directory will be visible at `/SharedData`, and any changes made in `/SharedData` will reflect in `/home` on the host. However, we should be cautious with bind mounts. Unlike volumes, bind mounts are not managed by Docker and can be modified by any process on the host, which might lead to data corruption or unexpected behavior. For this reason, we strongly recommend using Docker volumes for persistent data in production environments, as they offer better isolation and management.

## Table of All Arguments and Options for `docker volume`

The `docker volume` command provides several subcommands to manage volumes, each with its own arguments and options. Below is a comprehensive table listing all possible subcommands, their arguments, options, and example commands.

| **Subcommand**     | **Description**                                                               | **Arguments/Options**                                                                              | **Example Command**                                                                 |
| ------------------ | ----------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| `create`           | Creates a new volume. If no name is provided, Docker generates a random name. | `--driver` (volume driver, e.g., `local`), `--opt` (driver-specific options), `--label` (metadata) | `docker volume create myvol`                                                        |
| `create --driver`  | Specifies a custom volume driver (e.g., for third-party storage like NFS).    | `--driver` (e.g., `local`, `nfs`)                                                                  | `docker volume create --driver local myvol`                                         |
| `create --opt`     | Sets driver-specific options (e.g., for mounting an NFS share).               | `--opt` (e.g., `type=nfs,device=:/path`)                                                           | `docker volume create --driver local --opt type=nfs --opt device=:/nfs/share myvol` |
| `create --label`   | Adds metadata labels to the volume for organization or filtering.             | `--label` (e.g., `env=prod`)                                                                       | `docker volume create --label env=prod myvol`                                       |
| `ls`               | Lists all volumes on the host.                                                | `--filter` (e.g., `name=myvol`), `--format` (output format), `-q` (quiet, IDs only)                | `docker volume ls`                                                                  |
| `ls --filter`      | Filters the list of volumes based on criteria like name or label.             | `--filter` (e.g., `name=myvol`, `label=env=prod`)                                                  | `docker volume ls --filter name=myvol`                                              |
| `ls --format`      | Customizes the output format using Go templates.                              | `--format` (e.g., `{{.Name}}`)                                                                     | `docker volume ls --format "{{.Name}}"`                                             |
| `ls -q`            | Outputs only the volume IDs (useful for scripting).                           | `-q` (quiet mode)                                                                                  | `docker volume ls -q`                                                               |
| `inspect`          | Displays detailed information about a volume (e.g., mount point, driver).     | Volume name(s) (required), `--format` (output format)                                              | `docker volume inspect myvol`                                                       |
| `inspect --format` | Customizes the output format of the inspection using Go templates.            | `--format` (e.g., `{{.Mountpoint}}`)                                                               | `docker volume inspect --format "{{.Mountpoint}}" myvol`                            |
| `rm`               | Removes one or more volumes. Volumes in use by a container cannot be removed. | Volume name(s) (required), `-f` (force removal)                                                    | `docker volume rm myvol`                                                            |
| `rm -f`            | Forces removal of a volume, even if it’s in use (stops containers if needed). | `-f` (force)                                                                                       | `docker volume rm -f myvol`                                                         |
| `prune`            | Removes all unused volumes (those not attached to any container).             | `--filter` (e.g., `label=env=prod`), `-f` (force, no prompt)                                       | `docker volume prune`                                                               |
| `prune --filter`   | Filters which unused volumes to remove based on criteria like labels.         | `--filter` (e.g., `label=env=prod`)                                                                | `docker volume prune --filter label=env=prod`                                       |
| `prune -f`         | Removes unused volumes without prompting for confirmation.                    | `-f` (force)                                                                                       | `docker volume prune -f`                                                            |

### Notes on the `docker volume` Command
- The default volume driver is `local`, which stores volumes on the host filesystem (e.g., `/var/lib/docker/volumes/`). We can use `--driver` to specify alternative drivers like `nfs` or third-party plugins for cloud storage.
- The `--opt` flag is driver-specific. For example, with the `local` driver, we can use `--opt type=nfs` to mount an NFS share as a volume.
- We cannot directly set permissions or ownership during volume creation with `docker volume create`. Permissions must be adjusted after creation, as discussed in previous responses.
- The `prune` subcommand is useful for cleaning up unused volumes but should be used cautiously, as it permanently deletes data.

## Named vs. Anonymous Volumes: A Detailed Comparison

Docker supports two types of volumes: named volumes and anonymous volumes. Understanding their differences helps us choose the right type for our use case.

### Named Volumes
- **Definition**: Named volumes are explicitly created with a name using `docker volume create` or automatically named when specified in a `docker run` command (e.g., `-v myvol:/app`).
- **Storage Location**: Stored on the host at `/var/lib/docker/volumes/<volume-name>/_data/`.
- **Lifecycle**: Persist until explicitly removed with `docker volume rm`. They are not tied to a specific container and can be reused across multiple containers.
- **Management**: Easier to manage because they have a human-readable name. We can list them with `docker volume ls`, inspect them with `docker volume inspect`, and remove them with `docker volume rm`.
- **Use Case**: Ideal for production environments where we need to share data between containers or ensure data persists across container restarts. For example, we used `myvol` to share data between `centos_with_vol` and `centos_with_vol_2`.
- **Example**:
  ```bash
  docker volume create myvol
  docker run -it --name centos_with_vol -v myvol:/app centos:latest
  ```
- **Advantages**:
  - Reusable across containers.
  - Easier to back up, restore, or migrate to another host.
  - Can be labeled for better organization (e.g., `docker volume create --label env=prod myvol`).
- **Disadvantages**:
  - Requires manual cleanup if no longer needed (e.g., `docker volume rm myvol`).

### Anonymous Volumes
- **Definition**: Anonymous volumes are created automatically by Docker when we specify a mount point in a container without naming a volume (e.g., `-v /app`).
- **Storage Location**: Stored on the host at `/var/lib/docker/volumes/<random-id>/_data/`, where `<random-id>` is a unique identifier generated by Docker.
- **Lifecycle**: Persist until the container they are attached to is removed with `docker rm` (and no other containers are using the volume). They are automatically removed if the container is removed with `docker rm -v` or if we run `docker volume prune`.
- **Management**: Harder to manage because they lack a human-readable name. Their random IDs make them difficult to track unless we inspect the container or volume list.
- **Use Case**: Useful for temporary or one-off containers where we don’t need to reuse the volume. For example, we might use an anonymous volume for a container that generates temporary data during a single run.
- **Example**:
  ```bash
  docker run -it --name centos_temp -v /app centos:latest
  ```
- **Advantages**:
  - Automatically created, so less setup is required.
  - Automatically cleaned up with `docker rm -v` or `docker volume prune`, reducing manual cleanup.
- **Disadvantages**:
  - Not reusable across containers without knowing the random ID.
  - Harder to manage due to lack of a name.
  - Not ideal for production, as they can lead to orphaned volumes if not cleaned up properly.

### Key Differences
- **Naming**: Named volumes have a user-defined name; anonymous volumes have a random ID.
- **Reusability**: Named volumes can be easily reused by specifying their name; anonymous volumes are tied to a specific container unless we manually identify and reuse their ID.
- **Cleanup**: Named volumes require manual removal; anonymous volumes are often cleaned up automatically when the container is removed (if using `docker rm -v`).
- **Use Case**: Named volumes are better for persistent, shared data in production; anonymous volumes are better for temporary data in short-lived containers.

### Practical Tip
We can convert an anonymous volume to a named volume by creating a new named volume and copying the data. For example, if we have a container with an anonymous volume at `/app`, we can:
1. Inspect the container to find the volume’s ID (`docker inspect centos_temp`).
2. Create a new named volume (`docker volume create myvol`).
3. Use a temporary container to copy data between the volumes:
```bash
docker run --rm -v <anonymous-volume-id>:/source -v myvol:/dest busybox sh -c "cp -r /source/* /dest/"
```

#### What Does `sh -c` Do?

- **`sh`** :
    - Refers to the shell interpreter (typically `/bin/sh`, which is a minimal shell available in most Linux distributions).
- **`-c`** : 
    - The `-c` flag tells the shell to execute the following string as a command.
    - In this case, the string is `"cp -r /source/* /dest/"`.
- **Combined (`sh -c "cp -r /source/* /dest/"`)** :
    - This tells the shell to interpret and execute the command `cp -r /source/* /dest/` inside the container.
    - The `cp -r` command recursively copies all files and directories from `/source` (mounted from `<anonymous-volume-id>`) to `/dest` (mounted from `myvol`).

By understanding these differences, we can choose the right type of volume for our needs and manage our data effectively.

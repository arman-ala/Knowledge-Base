# 3.20. Lineinfile Module

2025-08-16 07:38
Status: #DONE 
Tags: [[Ansible]]

---
# Mastering Configuration Management with Ansible's Lineinfile Module

## For Beginners: Making Simple Changes to Files

Imagine you have a long document and you want to change just one sentence without rewriting the whole thing. That's what Ansible's lineinfile module does for computer configuration files. Instead of replacing an entire configuration file, you can target specific lines to add, remove, or modify them.

For example, if you're setting up a web server and need to change a port number from 80 to 8080, lineinfile lets you find that specific setting and change only that part. It's like using a search-and-replace function, but with more control over exactly where changes happen.

This module is especially useful when:
- You need to add a new setting to an existing configuration file
- You want to modify a specific line without affecting the rest of the file
- You need to ensure a particular configuration line exists or doesn't exist

The module can look for a specific line in a file and either modify it or add new content before or after it. If it can't find the line you're looking for, it can add your new content at the end of the file by default.

## In-Depth Analysis: The Lineinfile Module

The lineinfile module in Ansible provides a powerful method for managing individual lines within text files. This module is particularly valuable for configuration management where complete file replacement is unnecessary or potentially disruptive.

### Core Functionality

The lineinfile module operates by performing targeted edits to specific lines within a file. It can:
- Insert new lines before or after matching patterns
- Replace existing lines that match a regular expression
- Ensure specific lines are present or absent
- Modify file content without altering the entire file structure

### Key Behavior: Preventing Duplicate Lines

The lineinfile module inherently prevents adding duplicate lines to a file, ensuring idempotent operations regardless of who authored the original content. This means if you attempt to insert a line that already exists in the exact same form elsewhere in the file, Ansible will recognize the duplication and skip the insertion, maintaining file integrity and avoiding redundant configurations. For example, if you run a task to add `server_tokens off;` to an Nginx configuration and that exact line already exists, Ansible won't add a second copy. Similarly, when adding a Redis configuration line like `maxmemory 1gb`, if the file already contains this precise directive, the module will leave the file unchanged. This automatic duplicate detection works regardless of whether the existing line was added manually, by another script, or through a previous Ansible run, making it a reliable safeguard against configuration bloat and potential conflicts.

## Use Cases and Examples

#### Nginx Configuration Management

```yaml
- name: Add custom include directive to nginx
  ansible.builtin.lineinfile:
    path: /etc/nginx/nginx.conf
    insertafter: 'include /etc/nginx/conf.d/*.conf;'
    line: 'include /etc/nginx/conf.d/vhosts/*.conf;'
    backup: yes
```

This example adds a custom include directive to the nginx configuration file after the standard conf.d include. The backup parameter ensures the original file is preserved before modification.

#### PostgreSQL Configuration Adjustment

```yaml
- name: Increase PostgreSQL shared buffers
  ansible.builtin.lineinfile:
    path: /etc/postgresql/12/main/postgresql.conf
    regexp: '^shared_buffers ='
    line: 'shared_buffers = 256MB'
    backup: yes
```

This task modifies the PostgreSQL shared_buffers setting by finding the line that starts with "shared_buffers =" and replacing it with the new value.

#### MySQL Configuration Optimization

```yaml
- name: Optimize MySQL innodb buffer pool size
  ansible.builtin.lineinfile:
    path: /etc/mysql/my.cnf
    regexp: '^innodb_buffer_pool_size'
    line: 'innodb_buffer_pool_size = 2G'
    backup: yes
```

This example adjusts the InnoDB buffer pool size in MySQL's configuration, which can significantly improve database performance.

#### Redis Configuration Update

```yaml
- name: Configure Redis memory limit
  ansible.builtin.lineinfile:
    path: /etc/redis/redis.conf
    regexp: '^maxmemory '
    line: 'maxmemory 1gb'
    backup: yes
```

This task sets the maximum memory limit for Redis to 1GB by finding and replacing the maxmemory configuration line.

#### Golang Application Configuration

```yaml
- name: Set Golang application environment
  ansible.builtin.lineinfile:
    path: /etc/systemd/system/myapp.service
    insertafter: '^Environment='
    line: 'Environment=GODEBUG=x509ignoreCN=0'
    backup: yes
```

This example adds an environment variable to a systemd service file for a Golang application, inserting it after any existing Environment lines.

## Best Practices, Tips, and Tricks

1. **Use Templates for Complex Configurations**: While lineinfile is excellent for simple changes, consider using the template module for complex configuration files where you need more control over the entire file structure.

2. **Always Create Backups**: When modifying critical configuration files, always use the `backup: yes` parameter. This ensures you can revert changes if something goes wrong.

3. **Be Specific with Regular Expressions**: Craft precise regular expressions to avoid unintended matches. Test your regex patterns before deploying them in production.

4. **Use Idempotent Configurations**: Design your tasks to be idempotent by using appropriate parameters. This ensures that running the task multiple times doesn't change the system after the first successful application.

5. **Combine with Validation**: For configuration files that support validation (like nginx), combine lineinfile with a validation command:

```yaml
- name: Update nginx configuration and validate
  ansible.builtin.lineinfile:
    path: /etc/nginx/nginx.conf
    insertafter: 'worker_processes'
    line: 'worker_rlimit_nofile 65535;'
    backup: yes
  notify: restart nginx
  validate: /usr/sbin/nginx -t %s
```

6. **Consider Using Blockinfile for Multi-line Changes**: When you need to insert or replace multiple lines, consider using the blockinfile module instead of multiple lineinfile tasks.

7. **Leverage Tags for Organization**: Use tags to organize related configuration tasks, especially when managing multiple aspects of a single configuration file:

```yaml
- name: Configure PostgreSQL performance settings
  ansible.builtin.lineinfile:
    path: /etc/postgresql/12/main/postgresql.conf
    regexp: '^shared_buffers ='
    line: 'shared_buffers = 256MB'
    backup: yes
  tags: postgres_performance
```

8. **Document Your Changes**: Include comments in your playbooks to explain why specific configuration changes are being made, especially when the reasoning isn't immediately obvious from the change itself.

9. **Use Firstmatch for Critical Changes**: When modifying critical configuration parameters, use `firstmatch: yes` to ensure only the first occurrence is changed, preventing unintended modifications to similar lines elsewhere in the file.

10. **Handle Configuration Files with Sections**: For configuration files with sections (like systemd unit files), use `insertafter` or `insertbefore` with section headers to ensure changes appear in the correct context:

```yaml
- name: Add timeout setting to service file
  ansible.builtin.lineinfile:
    path: /etc/systemd/system/myapp.service
    insertafter: '^\\[Service\\]'
    line: 'TimeoutStartSec=300'
```

11. **Test Changes in Staging**: Always test lineinfile changes in a staging environment before applying them to production systems to ensure they don't cause unexpected behavior.

12. **Use Check Mode for Safety**: Run your playbooks with `--check` flag to see what changes would be made without actually modifying files:

```bash
ansible-playbook playbook.yml --check
```

The lineinfile module provides a precise, targeted approach to configuration management that complements broader configuration strategies. By understanding its capabilities and limitations, you can effectively incorporate it into your configuration management workflows, making targeted changes without disrupting entire configuration files.

## More Examples for the Ansible Lineinfile Module

#### Example 1: Basic Insertion of a Line
**Playbook Task:**
```yaml
- name: Add a line to a file if it doesn't exist
  ansible.builtin.lineinfile:
    path: /etc/motd
    line: "Welcome to our server!"
    state: present
```

**File Before:**
```
Last login: Mon Aug 16 10:30:15 2025 from 192.168.1.100
```

**File After:**
```
Last login: Mon Aug 16 10:30:15 2025 from 192.168.1.100
Welcome to our server!
```

**Explanation:** This task adds the line "Welcome to our server!" to the end of the /etc/motd file if it doesn't already exist. If the line is already present, no changes are made.

#### Example 2: Replacing a Line with Regex
**Playbook Task:**
```yaml
- name: Replace a line matching a regex
  ansible.builtin.lineinfile:
    path: /etc/ssh/sshd_config
    regexp: '^#Port 22'
    line: 'Port 2222'
    backup: yes
```

**File Before:**
```
#Port 22
PermitRootLogin no
```

**File After:**
```
Port 2222
PermitRootLogin no
```

**Explanation:** This task finds the line starting with "#Port 22" and replaces it with "Port 2222". The backup parameter ensures a copy of the original file is saved with a timestamp.

#### Example 3: Inserting a Line Before a Pattern
**Playbook Task:**
```yaml
- name: Insert a line before a matching pattern
  ansible.builtin.lineinfile:
    path: /etc/hosts
    insertbefore: '^127.0.0.1'
    line: '192.168.1.100   server1'
    state: present
```

**File Before:**
```
127.0.0.1   localhost
```

**File After:**
```
192.168.1.100   server1
127.0.0.1   localhost
```

**Explanation:** This task inserts the line "192.168.1.100   server1" before the line that starts with "127.0.0.1".

#### Example 4: Inserting a Line After a Pattern
**Playbook Task:**
```yaml
- name: Insert a line after a matching pattern
  ansible.builtin.lineinfile:
    path: /etc/hosts
    insertafter: '^127.0.0.1'
    line: '192.168.1.101   server2'
    state: present
```

**File Before:**
```
127.0.0.1   localhost
```

**File After:**
```
127.0.0.1   localhost
192.168.1.101   server2
```

**Explanation:** This task inserts the line "192.168.1.101   server2" after the line that starts with "127.0.0.1".

#### Example 5: Removing a Line with Regex
**Playbook Task:**
```yaml
- name: Remove a line matching a regex
  ansible.builtin.lineinfile:
    path: /etc/hosts
    regexp: '^192\.168\.1\.100'
    state: absent
```

**File Before:**
```
127.0.0.1   localhost
192.168.1.100   server1
```

**File After:**
```
127.0.0.1   localhost
```

**Explanation:** This task removes any line that starts with "192.168.1.100" from the /etc/hosts file.

#### Example 6: Using Backreferences in Replacement
**Playbook Task:**
```yaml
- name: Use backreferences in replacement
  ansible.builtin.lineinfile:
    path: /etc/hosts
    regexp: '^(192\.168\.1\.)(\d+)'
    line: '\1\20 \2'
    backup: yes
```

**File Before:**
```
192.168.1.100   server1
```

**File After:**
```
192.168.1.20 0   server1
```

**Explanation:** This task finds a line that matches the regex "^(192\.168\.1\.)(\d+)" and replaces it using backreferences. The first group (192.168.1.) is preserved, the second group (100) is replaced with "20 0".

#### Example 7: Inserting Multiple Lines with Loop
**Playbook Task:**
```yaml
- name: Insert multiple lines
  ansible.builtin.lineinfile:
    path: /etc/motd
    line: "{{ item }}"
    state: present
  loop:
    - "Welcome to our server!"
    - "System uptime: {{ ansible_uptime_seconds }} seconds"
    - "Last updated: {{ ansible_date_time.iso8601 }}"
```

**File Before:**
```
Last login: Mon Aug 16 10:30:15 2025 from 192.168.1.100
```

**File After:**
```
Last login: Mon Aug 16 10:30:15 2025 from 192.168.1.100
Welcome to our server!
System uptime: 12345 seconds
Last updated: 2025-08-16T10:30:15Z
```

**Explanation:** This task uses a loop to insert multiple lines at the end of the /etc/motd file. Each line in the loop is processed independently.

#### Example 8: Inserting When Pattern Doesn't Match (Appends to End)
**Playbook Task:**
```yaml
- name: Insert after non-matching pattern
  ansible.builtin.lineinfile:
    path: /etc/hosts
    insertafter: '^nonexistent'
    line: '192.168.1.102   server3'
    state: present
```

**File Before:**
```
127.0.0.1   localhost
```

**File After:**
```
127.0.0.1   localhost
192.168.1.102   server3
```

**Explanation:** Since the pattern "^nonexistent" doesn't match any line in the file, the new line is appended to the end of the file.

#### Example 9: Inserting Before Non-Matching Pattern (Appends to End)
**Playbook Task:**
```yaml
- name: Insert before non-matching pattern
  ansible.builtin.lineinfile:
    path: /etc/hosts
    insertbefore: '^nonexistent'
    line: '192.168.1.103   server4'
    state: present
```

**File Before:**
```
127.0.0.1   localhost
```

**File After:**
```
127.0.0.1   localhost
192.168.1.103   server4
```

**Explanation:** Since the pattern "^nonexistent" doesn't match any line in the file, the new line is appended to the end of the file.

#### Example 10: Creating File if It Doesn't Exist
**Playbook Task:**
```yaml
- name: Create file if it doesn't exist
  ansible.builtin.lineinfile:
    path: /etc/custom.conf
    line: "custom_setting = value"
    create: yes
    state: present
```

**File Before:**
```
# File doesn't exist
```

**File After:**
```
custom_setting = value
```

**Explanation:** This task creates the file /etc/custom.conf if it doesn't exist and adds the line "custom_setting = value" to it.

#### Example 11: Replacing First Match Instead of Last
**Playbook Task:**
```yaml
- name: Replace first occurrence
  ansible.builtin.lineinfile:
    path: /etc/hosts
    regexp: '^192\.168\.1\.'
    line: '10.0.0.1'
    firstmatch: yes
    backup: yes
```

**File Before:**
```
127.0.0.1   localhost
192.168.1.100   server1
192.168.1.101   server2
```

**File After:**
```
127.0.0.1   localhost
10.0.0.1   server1
192.168.1.101   server2
```

**Explanation:** This task replaces the first line that matches the regex "^192\.168\.1\." with "10.0.0.1". Without firstmatch, it would replace the last matching line.

#### Example 12: Removing a Line
**Playbook Task:**
```yaml
- name: Remove a specific line
  ansible.builtin.lineinfile:
    path: /etc/hosts
    line: '192.168.1.101   server2'
    state: absent
```

**File Before:**
```
127.0.0.1   localhost
192.168.1.100   server1
192.168.1.101   server2
```

**File After:**
```
127.0.0.1   localhost
192.168.1.100   server1
```

**Explanation:** This task removes the exact line "192.168.1.101   server2" from the /etc/hosts file.

#### Example 13: Validating File After Modification
**Playbook Task:**
```yaml
- name: Modify and validate SSH config
  ansible.builtin.lineinfile:
    path: /etc/ssh/sshd_config
    regexp: '^#Port 22'
    line: 'Port 2222'
    validate: '/usr/sbin/sshd -T -f %s'
    backup: yes
```

**File Before:**
```
#Port 22
PermitRootLogin no
```

**File After:**
```
Port 2222
PermitRootLogin no
```

**Explanation:** This task replaces the line starting with "#Port 22" with "Port 2222" and then validates the SSH configuration using the command "/usr/sbin/sshd -T -f %s". If validation fails, the task will fail.

#### Example 14: Creating a Backup
**Playbook Task:**
```yaml
- name: Modify with backup
  ansible.builtin.lineinfile:
    path: /etc/hosts
    regexp: '^127\.0\.0\.1'
    line: '127.0.0.1   localhost.localdomain'
    backup: yes
```

**File Before:**
```
127.0.0.1   localhost
```

**File After:**
```
127.0.0.1   localhost.localdomain
```

**Backup File Created:**
```
/etc/hosts.2025-08-16@10:30:15~
```

**Explanation:** This task replaces the line starting with "127.0.0.1" with "127.0.0.1   localhost.localdomain" and creates a backup file with a timestamp.

#### Example 15: Setting File Permissions
**Playbook Task:**
```yaml
- name: Modify with specific permissions
  ansible.builtin.lineinfile:
    path: /etc/hosts
    line: '192.168.1.104   server5'
    mode: '0644'
    state: present
```

**File Before:**
```
127.0.0.1   localhost
```

**File After:**
```
127.0.0.1   localhost
192.168.1.104   server5
```

**Explanation:** This task adds the line "192.168.1.104   server5" to the /etc/hosts file and sets the file permissions to 0644 (readable by owner and group, readable by others). If the file doesn't exist, it will be created with these permissions.

### Key Parameters

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| path | str | Yes | - | Absolute path to the file to modify |
| line | str | Yes | - | The line to insert/replace or ensure exists |
| regexp | str | No | - | Regular expression to search for in the file |
| state | str | No | present | Whether the line should be present or absent |
| insertafter | str | No | EOF | Insert after the line matching this regex |
| insertbefore | str | No | - | Insert before the line matching this regex |
| backrefs | bool | No | no | Use backreferences in regexp replacement |
| create | bool | No | no | Create file if it doesn't exist |
| backup | bool | No | no | Create backup file before modifying |
| firstmatch | bool | No | no | Modify only the first matching line |
| others | dict | No | - | File attributes like owner, mode, etc. |

### Operational Behavior

The lineinfile module follows a specific operational sequence:

1. If the `regexp` parameter is provided, the module searches for lines matching the pattern.
   - If matches are found, the last matching line is replaced with the content specified in the `line` parameter.
   - If no matches are found, the behavior depends on other parameters:
     - If `insertafter` or `insertbefore` is specified, the module attempts to insert the line relative to the matching pattern.
     - If no insertion point is found or specified, the line is appended to the end of the file.

2. If the `regexp` parameter is not provided:
   - The module checks if the exact content specified in the `line` parameter already exists in the file.
   - If the line exists and `state` is "present", no action is taken.
   - If the line doesn't exist and `state` is "present", the module inserts the line based on `insertafter`, `insertbefore`, or appends it to the end.
   - If the line exists and `state` is "absent", the line is removed.
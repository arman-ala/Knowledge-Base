# 3.7. Script Module

2025-08-13 04:12
Status: #DONE 
Tags: [[Ansible]]

---
### Exploring the Ansible Script Module: A Comprehensive Guide

In the landscape of DevOps automation, Ansible provides a suite of modules for executing tasks on remote hosts, with the `script` module offering a unique approach to running local scripts remotely. This module transfers a script from the control node to the target and executes it, processing through the remote shell environment. It stands out for not requiring Python on the remote system, making it versatile for diverse environments, including Windows. Below, we present a simplified overview for foundational understanding, followed by a detailed dissection of its components, parameters, and applications, enriched with best practices and illustrative examples.

#### Simplified Explanation: Breaking It Down Simply

Envision the `script` module as a courier service for your scripts: you hand it a local script file (perhaps with arguments), and it delivers and runs it on remote machines, just like you'd execute it locally but scaled across your infrastructure. Unlike typing commands directly, this module handles the transfer automatically, runs the script in the remote shell (so features like pipes or redirects work if in the script), and brings back results. It's handy when you have reusable scripts—say, a bash file to configure a service—and want to push them without installing extra tools on targets. For instance, running a script like `setup.sh arg1` would look like:
```bash
ansible.builtin.script: /path/to/setup.sh arg1
```
Keep it simple: Test scripts locally first, and use conditions like "only run if a file exists" to avoid unnecessary executions.

#### In-Depth Analysis: Precise and Comprehensive Coverage

The `ansible.builtin.script` module, integral to `ansible-core`, facilitates the transfer and execution of local scripts on remote nodes without necessitating Python on the targets—similar to the `raw` module. It processes the script via the remote shell, enabling shell-specific features within the script itself. This contrasts with modules like `command` (no shell) or `shell` (direct remote commands), positioning `script` as ideal for portable, pre-written logic. It's platform-agnostic, supporting all OS families, including Windows, and includes an action plugin for seamless integration.

Key attributes include partial `check_mode` support (via `creates` or `removes` for simulated changes), no `diff_mode`, and full `vault` decryption for secure script handling. It avoids raw file operations for safety and uses `raw` parsing for free-form inputs. Notes highlight preferring custom Ansible modules over scripts for maintainability, potential stdout/stderr merging due to pseudo-tty allocation in SSH, and quoting paths with spaces. For non-UTF-8 outputs, encode via `base64` in the script. Windows support broadens its utility, but for pure shell commands, consider `shell` or `win_shell`.

Now, let's examine each parameter in detail, including types, defaults, all possible values, requirements, and interactions. We'll incorporate best practices, tips, tricks, and examples with expected outputs for clarity.

- **chdir**: Specifies a directory on the remote node to change into before script execution. Type: string (valid path). Default: None (uses default remote directory). Possible values: Any absolute or relative path existing on the target (e.g., '/tmp' or './config'). Required: No.

  Best practice: Use absolute paths to prevent issues from varying user contexts. Tip: Combine with `creates` for tasks like script-based deployments in specific folders; trick: Pre-verify path with `stat` module to avoid failures.

  Example: Run script in /opt/app.
  ```yaml
  - name: Execute script in custom directory
    ansible.builtin.script: /local/script.sh
    args:
      chdir: /opt/app
  ```
  Expected output: Script runs in /opt/app; if script echoes "Current dir: $(pwd)", `stdout` might return "Current dir: /opt/app", with `changed: true` if modifications occur. Results include `rc: 0` for success, demonstrating contextual execution.

- **cmd**: Path to the local script plus optional arguments, enhancing readability. Type: string. Default: None. Possible values: Any local path + space-delimited args (e.g., '/path/script.sh arg1 arg2'). Required: No, but one of `cmd` or free-form is needed; mutually exclusive with free-form in some contexts.

  Best practice: Use `cmd` for explicitness in complex playbooks. Tip: Quote paths with spaces; trick: Templatize args with Jinja2 for dynamic inputs.

  Example: Script with args.
  ```yaml
  - name: Run script with parameters
    ansible.builtin.script:
      cmd: /local/setup.sh --user admin --pass secret
  ```
  Expected output: Transfers and runs setup.sh with args; if script creates a file, `changed: true`, `stdout` could include script logs like "User set: admin", and `stderr` any errors. No_log recommended for sensitive args.

- **creates**: Skips execution if a remote file exists, promoting idempotency. Type: string (filename). Default: None. Possible values: Any remote path (e.g., '/etc/config.done'). Required: No. Notes: Checked before `removes`.

  Best practice: Use for one-time setups like initial configurations. Tip: Paths can be globs (e.g., '/tmp/*.log'); trick: Register prior task results to dynamically set this.

  Example: Conditional on file existence.
  ```yaml
  - name: Run if no marker file
    ansible.builtin.script: /local/create_config.sh
    args:
      creates: /remote/config.done
  ```
  Expected output: Runs first time (`changed: true`), creates file via script, subsequent runs skip (`changed: false`). If script fails, `rc: non-zero`, `msg: failed`.

- **decrypt**: Controls Vault decryption of the script source. Type: boolean. Default: true. Possible values: true (decrypt if Vault-encrypted), false (treat as plain). Required: No.

  Best practice: Keep true for secure environments; set false for non-Vault scripts to avoid overhead. Tip: Ensure Vault password file is set; trick: Use with `vault_id` for multi-Vault setups.

  Example: Decrypt encrypted script.
  ```yaml
  - name: Run Vault-encrypted script
    ansible.builtin.script: /local/encrypted_script.sh
    args:
      decrypt: true
  ```
  Expected output: Decrypts and runs; if encrypted, executes normally (`rc: 0`); false would fail if encrypted, with `stderr` indicating decryption error.

- **executable**: Specifies the interpreter for the script on the remote node. Type: string (name or path). Default: None (uses script's shebang or default shell). Possible values: Any valid executable (e.g., 'python3', '/bin/bash', 'powershell.exe' for Windows).

  Best practice: Explicitly set for non-standard interpreters to ensure compatibility. Tip: For Windows, use 'powershell' or 'cmd'; trick: Detect remote OS with facts and conditional `when`.

  Example: Use Python interpreter.
  ```yaml
  - name: Run Python script
    ansible.builtin.script: /local/myscript.py
    args:
      executable: python3
  ```
  Expected output: Runs with python3; if script prints "Hello", `stdout: "Hello"`, `changed: false` if no changes. Without, falls back to shebang.

- **free_form**: Free-form string for script path + args (not a named parameter). Type: string. Default: None. Possible values: Local path + args. Required: Yes if no `cmd`.

  Best practice: Prefer `cmd` for clarity; use free-form for ad-hoc. Tip: Quote spaces in paths.

  Example: Free-form execution.
  ```yaml
  - name: Simple script run
    ansible.builtin.script: /local/script.sh arg1 arg2
  ```
  Expected output: Transfers, runs with args; `stdout_lines` as list of outputs, e.g., ["Line1", "Line2"].

- **removes**: Executes only if a remote file exists. Type: string. Default: None. Possible values: Any remote path. Required: No. Notes: Checked after `creates`.

  Best practice: Use for cleanup scripts. Tip: Combine with `creates` for toggles; trick: Use globs for flexibility.

  Example: Run if file exists.
  ```yaml
  - name: Cleanup if log exists
    ansible.builtin.script: /local/cleanup.sh
    args:
      removes: /remote/old.log
  ```
  Expected output: Runs if old.log present (`changed: true`), skips otherwise (`changed: false`).

In application, the module transfers the script temporarily, executes it, and cleans up, returning values like `changed`, `rc`, `stdout`, `stderr`. For Windows, scripts like .ps1 work seamlessly. Common pitfalls: Stderr merging—use `copy` + `command` for separation. Tip: For templated scripts, pair with `template` module first.



### Additional Examples for the Ansible Script Module

#### Example 1: Using `chdir` with Environment-Specific Paths
```yaml
- name: Run configuration script in application directory
  ansible.builtin.script: /local/scripts/configure_app.sh
  args:
    chdir: "/opt/{{ app_name }}"
    creates: "/opt/{{ app_name }}/config.lock"
```
**Explanation**: This transfers a local configuration script to the remote host and executes it in the application-specific directory defined by the `app_name` variable. The `creates` parameter ensures idempotency by skipping execution if the configuration lock file exists. The script runs in the context of the application directory, allowing it to reference relative paths correctly. Output shows configuration details in `stdout` and `changed: true` on first run, `false` on subsequent runs.

#### Example 2: Using `cmd` with Multiple Arguments
```yaml
- name: Execute deployment script with multiple parameters
  ansible.builtin.script:
    cmd: "/local/scripts/deploy.sh --env {{ env_type }} --version {{ app_version }} --verbose"
    removes: "/tmp/deploy_pending"
```
**Explanation**: This demonstrates using the `cmd` parameter with multiple arguments, including Jinja2 templating for dynamic environment and version values. The `removes` parameter ensures the deployment script only runs when a pending flag file exists, which might be created by a previous process. The script receives all arguments as if run locally, with output showing deployment progress in `stdout` and `changed: true` indicating successful execution.

#### Example 3: Combining `creates` and `removes` for Toggle Behavior
```yaml
- name: Toggle service configuration with script
  ansible.builtin.script: /local/scripts/toggle_service.sh
  args:
    creates: "/etc/service/enabled"
    removes: "/etc/service/disabled"
```
**Explanation**: This creates a toggle mechanism where the script runs only if the service is currently disabled (removes condition) and not already enabled (creates condition). The script would typically handle the actual state change, creating the enabled file and removing the disabled file. This pattern ensures the script only runs when necessary to change state, providing idempotent behavior for toggle operations.

#### Example 4: Using `decrypt` with Vault-Encrypted Scripts
```yaml
- name: Run encrypted database setup script
  ansible.builtin.script: /local/scripts/secure_db_setup.sh
  args:
    decrypt: true
    executable: /bin/bash
  no_log: true
```
**Explanation**: This demonstrates handling a Vault-encrypted script that contains sensitive database configuration. The `decrypt: true` parameter ensures Ansible decrypts the script before transferring it. The `executable` parameter explicitly sets Bash as the interpreter, and `no_log: true` prevents logging of any sensitive output. This approach allows secure distribution and execution of scripts containing credentials or other sensitive data.

#### Example 5: Cross-Platform Script Execution
```yaml
- name: Run appropriate script based on OS family
  ansible.builtin.script: "{{ item }}"
  with_first_found:
    - "scripts/setup_{{ ansible_os_family }}.sh"
    - "scripts/setup_default.sh"
  args:
    executable: "{{ 'powershell.exe' if ansible_os_family == 'Windows' else '/bin/bash' }}"
```
**Explanation**: This demonstrates cross-platform script execution by selecting the appropriate script based on the target OS family. The `with_first_found` loop tries OS-specific scripts first, falling back to a default if needed. The `executable` parameter dynamically selects the appropriate interpreter (PowerShell for Windows, Bash for others). This pattern allows for consistent automation across heterogeneous environments.

#### Example 6: Using `free_form` with Complex Arguments
```yaml
- name: Run backup script with complex arguments
  ansible.builtin.script: /local/scripts/backup.sh --full --compress --destination /backups/{{ inventory_hostname }} --exclude "*.tmp"
  register: backup_result
```
**Explanation**: This uses the free-form approach to pass multiple complex arguments to a backup script. The arguments include flags and paths with templating for host-specific destination directories. The script receives all arguments exactly as specified, with output showing backup progress in `stdout` and `changed: true` indicating files were backed up. The free-form approach is concise but requires careful quoting of paths with spaces.

#### Example 7: Conditional Script Execution with Multiple Parameters
```yaml
- name: Run maintenance script only on weekends
  ansible.builtin.script: /local/scripts/maintenance.sh
  args:
    chdir: /opt/app
    creates: /opt/app/maintenance.log
    executable: /bin/bash
  when: "'Saturday' in ansible_date_time.weekday or 'Sunday' in ansible_date_time.weekday"
```
**Explanation**: This demonstrates conditional script execution based on the day of the week. The maintenance script only runs on weekends, as determined by the `when` condition checking the weekday fact. The script runs in the application directory and creates a log file to prevent re-execution. This pattern is useful for maintenance tasks that should only run during specific time windows.

#### Example 8: Error Handling with Script Execution
```yaml
- name: Run validation script with custom error handling
  ansible.builtin.script: /local/scripts/validate_config.sh
  args:
    chdir: /etc/app
  register: validation_result
  failed_when: validation_result.rc != 0 or "ERROR" in validation_result.stdout
  changed_when: validation_result.rc == 0 and "CHANGED" in validation_result.stdout
```
**Explanation**: This demonstrates custom error handling for script execution. The `failed_when` condition marks the task as failed if the script returns a non-zero exit code or if "ERROR" appears in the output. The `changed_when` condition only reports changes when the script returns success and specifically outputs "CHANGED". This pattern allows for precise control over task status based on script output, which is useful for validation scripts that might detect issues without necessarily failing.

#### Example 9: Using Script with Temporary File Cleanup
```yaml
- name: Run data processing script
  ansible.builtin.script: /local/scripts/process_data.sh
  args:
    chdir: /tmp/data
    removes: /tmp/data/input.raw
  register: process_result
- name: Clean up temporary files
  ansible.builtin.file:
    path: /tmp/data/{{ item }}
    state: absent
  with_items:
    - "temp_1.tmp"
    - "temp_2.tmp"
  when: process_result.rc == 0
```
**Explanation**: This demonstrates a pattern for running a data processing script that creates temporary files, followed by cleanup of those files. The script runs only if the input file exists (removes condition), processes the data, and likely creates temporary files. The subsequent task uses `with_items` to clean up specific temporary files only if the script completed successfully (rc == 0). This pattern ensures proper cleanup of artifacts created during script execution.

#### Example 10: Script Execution with Output Parsing
```yaml
- name: Run monitoring script and parse output
  ansible.builtin.script: /local/scripts/check_health.sh
  args:
    executable: /bin/bash
  register: health_check
- name: Set fact based on health check
  ansible.builtin.set_fact:
    system_healthy: "{{ 'OK' in health_check.stdout }}"
- name: Display health status
  ansible.builtin.debug:
    msg: "System is {{ 'healthy' if system_healthy else 'unhealthy' }}"
```
**Explanation**: This demonstrates executing a health check script and parsing its output to determine system status. The script runs and returns health information, which is captured in the `health_check` variable. The `set_fact` task then creates a boolean variable based on whether "OK" appears in the script output. Finally, a debug task displays the health status in a human-readable format. This pattern is useful for integrating script output into Ansible's variable system for conditional logic in subsequent tasks.

#### Summary Table of Arguments

| Argument Name | Type | Default Value | Possible Values | Required | Notes/Deprecations |
|---------------|------|---------------|-----------------|----------|--------------------|
| chdir        | string | None         | Any valid remote path (e.g., '/tmp', './dir') | No      | Changes remote working directory |
| cmd          | string | None         | Local script path + args (e.g., '/script.sh arg') | No (but needed if no free_form) | Alternative to free_form |
| creates      | string | None         | Any remote filename (e.g., '/config.done') | No      | Skips if exists; checked first |
| decrypt      | boolean | true        | true, false | No      | Controls Vault decryption |
| executable   | string | None         | Any interpreter (e.g., 'python3', '/bin/bash') | No      | Overrides script shebang |
| free_form    | string | None         | Local script path + args | Yes (if no cmd) | Not a named param; free-form input |
| removes      | string | None         | Any remote filename | No      | Runs if exists; checked after creates

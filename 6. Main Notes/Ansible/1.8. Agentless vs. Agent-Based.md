# Agentless vs. Agent-Based

2025-07-31 21:20
Status: #DONE 
Tags: [[Ansible]]

---
### Analysis and Explanation of Agentless vs. Agent-Based Systems

#### 1. Differences Between Agentless and Agent-Based Systems
We distinguish between agentless and agent-based systems based on their operational mechanisms and requirements:
- **Dependencies**: Agent-based systems require the installation of an agent and its specific or third-party dependencies on managed hosts, whereas agentless systems, like Ansible, operate without such installations, relying solely on existing protocols such as SSH.
- **Invocation**: Agent-based systems necessitate invoking the agent to run the configuration management tool, either as a service or cron job, while agentless systems allow remote invocation without local agent activation.
- **Parallel Execution**: In agent-based systems, parallel agent runs may slow down if multiple agents target the same server, limiting concurrent connection processing. Agentless systems may execute faster due to direct communication, though performance might be constrained by the number of SSH connections.
- **Installation & Permissions**: Agent-based systems require careful management of agent installation, permissions, and user configurations, adding complexity. Agentless systems simplify this by using SSH-based remote connections, logging in as a specific user with appropriate permissions.

#### 2. Software List
- **Agent-Based Systems**: We identify tools such as Puppet, Chef, and SaltStack as examples. These require agents (e.g., Puppet Agent, Chef Client) to be installed on managed hosts to facilitate communication and task execution.
- **Agentless Systems**: We recognize Ansible, as well as tools like CFEngine and some uses of SSH-based scripts, as agentless solutions. These leverage existing network protocols without additional software on the target systems.

![[1.8. Agent-based.png]]

#### 3. Architecture of Agent-Based Systems
We detail the architecture of agent-based systems as follows:
- **Central Server**: This serves as the management node, hosting the configuration management tool (e.g., Puppet Master or Chef Server). It polls for changes from a Version Control System (VCS) and maintains the desired state of the infrastructure.
- **Agent (Client)**: Installed on each managed host, the agent communicates with the central server. It polls for updates, checks out configurations, and applies specifications sent by the server. For example, a Puppet Agent regularly syncs with the Puppet Master to enforce policies.
- **VCS Integration**: The central server integrates with a VCS (e.g., Git) to track configuration changes, polling for updates and checking out the latest versions to distribute to agents.
- **Communication**: Agents maintain a persistent or scheduled connection to the central server, often using proprietary protocols, requiring agent-specific ports and authentication mechanisms.
- **Managed Hosts**: These are the target systems where agents execute tasks, such as installing software or updating configurations, based on directives from the central server.

![[1.8. Agentless.png]]

#### 4. Architecture of Agentless Systems (Ansible)
We elaborate on the architecture of agentless systems, focusing on Ansible:
- **Provisioner Machine**: This acts as the control node where Ansible is installed. It polls the VCS for changes and sends configuration specifications to managed hosts. For instance, an Ansible control node might run on a dedicated server or workstation.
- **VCS Integration**: The provisioner machine interfaces with a VCS (e.g., Git) to detect changes (step 1), checking out the latest configurations (step 2) to prepare for deployment.
- **Communication**: Using SSH, the provisioner machine orchestrates tasks across managed hosts (step 3). It sends specifications (step 4) to execute actions without requiring resident agents, relying on the host’s SSH service.
- **Managed Hosts**: These include application servers, database servers, and web servers, managed directly via SSH. Ansible orchestrates their configurations, such as deploying applications or updating databases, without local agent overhead.
- **Orchestration**: The provisioner machine coordinates multi-tier deployments, ensuring sequential or parallel execution across diverse host types, as depicted with application, database, and web servers.

#### 5. Practical Example
Consider a 30-server infrastructure. In an agent-based system like Puppet, we install agents on each server, with a Puppet Master polling a Git repository for changes and distributing updates, potentially slowing if all agents hit the master simultaneously. In an agentless Ansible setup, a single provisioner machine polls the VCS, checks out configurations, and uses SSH to orchestrate updates across all servers—application, database, and web—efficiently, as observed on 07:49 PM CEST on Thursday, July 31, 2025.
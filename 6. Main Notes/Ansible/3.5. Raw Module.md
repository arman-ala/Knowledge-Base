# 3.5. Raw Module

2025-08-13 06:12
Status: #DONE 
Tags: [[Ansible]]

---
### Understanding the Ansible Raw Module and Its Behind-the-Scenes Operation

In the domain of DevOps automation, Ansible's ability to manage diverse systems hinges on its modules, which facilitate task execution on remote hosts. Among these, the `raw` module serves a specialized purpose, particularly for systems lacking Python, a typical prerequisite for most Ansible modules. This document elucidates the functionality of the `raw` module, drawing from the provided resources and documentation, and offers a simplified explanation for foundational understanding, followed by a detailed analysis of its mechanics, including its execution process, parameters, and best practices. The focus includes how Ansible addresses the challenge of Python-less hosts and the module's role in such scenarios.

#### Simplified Explanation: Breaking It Down Simply

Imagine you’re trying to communicate with a device—like a router or an old server—that doesn’t understand your usual instructions because it lacks Python, the language Ansible typically uses. The `raw` module acts like a universal translator: it sends a basic command directly to the device’s native shell (e.g., via SSH) without needing Python, bypassing Ansible’s usual module system. For example, to install Python on such a system, you might use:
```bash
ansible.builtin.raw: yum install -y python
```
Ansible delivers this command, lets the remote shell execute it, collects the results, and cleans up. It’s perfect for bootstrapping Python or managing devices without it, but it’s a blunt tool—use it only when simpler modules like `command` or `shell` won’t work due to the Python absence.

#### In-Depth Analysis: Precise and Comprehensive Coverage

The `ansible.builtin.raw` module, a component of `ansible-core`, is designed to execute low-level SSH commands directly on remote hosts without invoking the Ansible module subsystem. This bypasses the need for Python on the target, making it suitable for bootstrapping Python installations, managing devices like routers, or handling older systems (e.g., Python 2.4 and before requiring `python-simplejson`). Unlike `command`, `shell`, or `script` modules, which rely on Python to process and execute tasks, `raw` passes commands straight through the configured remote shell (e.g., `/bin/sh` via SSH), offering a "dirty" but effective solution. It is supported across all platforms, including Windows, and includes an action plugin for streamlined execution.

The provided resource highlights that Ansible encounters difficulties executing modules on Python-less hosts, as most modules (e.g., `command`, `shell`) depend on a Python interpreter to run their scripts. The `raw` module addresses this by enabling the installation of Python (e.g., `yum install -y python`) or interaction with non-Python devices (e.g., routers). Once Python is installed, subsequent tasks can utilize standard modules. The process—copying, executing, and cleaning up—mirrors other modules but operates at a lower level, as detailed below.

##### 1. **Module Structure and Preparation on the Control Node**

When a `raw` task is defined, Ansible:

- **Parses the Task**: Interprets the task, such as:
  ```yaml
  - name: Install Python on a raw host
    ansible.builtin.raw: yum install -y python
  ```
  The `free_form` command (`yum install -y python`) is identified as the input.

- **Bypasses Module Subsystem**: Unlike other modules, `raw` does not load a Python script from the Ansible library. Instead, it prepares to send the command directly via the connection plugin, avoiding the creation of a module-specific executable.

- **Serializes Command**: The command is formatted as a string, optionally with an `executable` if specified (e.g., `/bin/bash`). No JSON argument serialization occurs, as there’s no module script to interpret it.

**Best Practice**: Use Fully Qualified Collection Name (`ansible.builtin.raw`) to ensure clarity. **Tip**: Disable fact gathering (`gather_facts: no`) in playbooks using `raw` for Python bootstrapping to avoid errors. **Trick**: Test commands locally on the target host’s shell to validate syntax.

##### 2. **Transfer to the Remote Host**

The `raw` module minimizes transfer overhead:

- **No Temporary Script**: Unlike `command` or `script`, `raw` does not create or transfer a Python module script to a temporary directory (e.g., `~/.ansible/tmp/`). Instead, it relies on the connection plugin to execute the command directly.

- **Direct Command Execution**: The command is passed through the SSH connection string. For example, `ssh user@host "yum install -y python"` is constructed and executed. If `executable` is set (e.g., `/bin/bash`), it modifies the shell context (e.g., `ssh user@host "/bin/bash -c 'yum install -y python'"`).

- **Privilege Escalation**: With `become` (e.g., `become: yes`, `become_method: sudo`), a default shell is assigned if `executable` is unspecified, as escalation requires a shell environment.

**Best Practice**: Specify `executable` for non-default shells (e.g., `/bin/bash`) to ensure compatibility. **Tip**: Use `ansible_connection: ssh` with verbose mode (`-v`) to debug command construction. **Trick**: Avoid `environment` with `raw` unless using `become` or `executable`, as it requires a shell.

##### 3. **Execution on the Remote Host**

Execution occurs directly via the remote shell:

- **Command Run**: The command (e.g., `yum install -y python`) is executed by the remote shell without Python interpretation. This leverages the host’s native capabilities, making it ideal for Python-less environments.

- **Output Handling**: Standard output, error output, and return code (`rc`) are captured when available. For instance:
  ```bash
  ansible.builtin.raw: echo "Test raw module" > /home/test
  ```
  Might yield `stdout: "Test raw module"`, `rc: 0`, and no `stderr` if successful.

- **No Change Handler**: Unlike other modules, `raw` lacks change detection (`changed` status), as it does not track system state. This is a limitation, requiring manual idempotency checks.

- **Non-UTF-8 Data**: If the command returns non-UTF-8 data, encoding (e.g., piping through `base64`) is necessary to avoid issues.

**Best Practice**: Use `raw` only for initial setup (e.g., Python installation); switch to `command` or `shell` afterward. **Tip**: Register output with `register` to process results. **Trick**: Use `ignore_errors: true` for commands with expected non-zero `rc` (e.g., partial installs).

##### 4. **Cleanup and Result Reporting**

- **Cleanup**: No temporary files are created, so no cleanup is required beyond the connection teardown. This contrasts with `command` or `script`, which delete temporary directories.

- **Result Processing**: The connection plugin returns `stdout`, `stderr`, and `rc` to the control node. For example:
  ```yaml
  - name: Check system
    ansible.builtin.raw: uname -a
    register: result
  ```
  Might return:
  ```json
  {
    "rc": 0,
    "stdout": "Linux host 5.4.0-42-generic #46-Ubuntu SMP...",
    "stderr": ""
  }
  ```

**Best Practice**: Log sensitive outputs with `no_log: true` if needed. **Tip**: Use `-v` to `-vvvv` for detailed output inspection. **Trick**: Parse `stdout` with `set_fact` for further use.

##### 5. **Special Considerations**

- **Python Bootstrapping**: The primary use case is installing Python (e.g., `dnf install -y python2` for RHEL-based systems). Post-installation, gather facts (`gather_facts: yes`) to enable standard modules.

- **Device Management**: For routers or IoT devices without Python, `raw` sends commands (e.g., Cisco IOS via `enable`, `show version`).

- **Windows Support**: Uses WinRM to execute commands (e.g., `Get-WmiObject -Class Win32_UserAccount`), requiring no Python.

- **Limitations**: No `environment` support without `executable` or `become`, no `check_mode` or `diff_mode`, and no idempotency tracking.

**Example Across Scenarios**:
```yaml
- name: Bootstrap Python on RHEL
  ansible.builtin.raw: yum install -y python
  gather_facts: no

- name: Run Bash-specific command
  ansible.builtin.raw: cat < /tmp/*txt
  args:
    executable: /bin/bash

- name: Query Windows users
  ansible.builtin.raw: Get-WmiObject -Class Win32_UserAccount
```
**Expected Outputs**:
- Bootstrap: `rc: 0`, `stdout` with install logs, enables subsequent Python modules.
- Bash: `stdout` with file contents, `rc: 0` if files exist.
- Windows: `stdout` with user account data, `rc: 0`.

##### 6. **Behind-the-Scenes Nuances**

- **Connection Plugin**: SSH or WinRM executes the command, with pseudo-tty allocation merging `stderr` into `stdout` for `script`-like behavior.
- **Security**: Direct shell execution risks injection; sanitize inputs (e.g., `{{ var | quote }}`).
- **Scalability**: Limited to simple commands; complex tasks should use Python-based modules post-bootstrapping.

**Best Practice**: Transition to `command` or `shell` after Python setup. **Tip**: Use `raw` with `become` for privileged tasks. **Trick**: Chain with `wait_for_connection` to ensure Python availability post-install.

## Additional Examples for the Ansible Raw Module

#### Example 1: Bootstrapping Python on Different Systems
```yaml
- name: Bootstrap Python on Ubuntu/Debian
  ansible.builtin.raw: apt-get update && apt-get install -y python3
  when: ansible_os_family == "Debian"
  register: python_install
  changed_when: "'already installed' not in python_install.stdout"

- name: Bootstrap Python on RHEL/CentOS
  ansible.builtin.raw: yum install -y python3
  when: ansible_os_family == "RedHat"
  register: python_install
  changed_when: python_install.rc == 0 and "Nothing to do" not in python_install.stdout
```
**Explanation**: These tasks demonstrate OS-specific Python bootstrapping. For Debian systems, it updates the package list first, then installs Python3. For RHEL systems, it directly installs Python3. The `changed_when` conditions ensure the task reports changes only when Python was actually installed, not when it was already present. Output shows installation progress in `stdout`, with `rc: 0` indicating success.

#### Example 2: Using `executable` with Bash-Specific Features
```yaml
- name: Execute Bash-specific command with process substitution
  ansible.builtin.raw:
    cmd: 'diff <(cat /etc/hosts) <(cat /etc/hosts.backup) || echo "Files differ"'
    executable: /bin/bash
  register: diff_result
```
**Explanation**: This uses Bash-specific process substitution (`<()`) to compare two files. The `executable` parameter ensures Bash is used instead of the default `/bin/sh`, which doesn't support this feature. The command outputs differences if they exist, or "Files differ" if the diff command fails. Output shows either the differences or the message in `stdout`, with `rc: 0` if files are identical or `rc: 1` if they differ.

#### Example 3: Managing Windows Systems Without Python
```yaml
- name: Check Windows service status
  ansible.builtin.raw: Get-Service -Name Spooler | Select-Object Status
  register: spooler_status
  delegate_to: windows_host

- name: Start Windows service if stopped
  ansible.builtin.raw: Start-Service -Name Spooler
  delegate_to: windows_host
  when: "'Stopped' in spooler_status.stdout"
```
**Explanation**: These tasks manage a Windows service without requiring Python. The first task checks the status of the Spooler service using PowerShell. The second task starts the service if it's stopped. The `delegate_to` parameter targets a Windows host. Output shows service status in `stdout` (e.g., "Running" or "Stopped"), and the service is started only when necessary.

#### Example 4: Interacting with Network Devices
```yaml
- name: Check Cisco IOS version
  ansible.builtin.raw: show version
  register: ios_version
  when: ansible_network_os == 'ios'

- name: Save Cisco configuration
  ansible.builtin.raw: copy running-config startup-config
  when: ansible_network_os == 'ios'
```
**Explanation**: These tasks interact with Cisco IOS devices. The first retrieves version information, while the second saves the current configuration to startup. The `when` conditions ensure they only run on IOS devices. Output shows device version information in `stdout` for the first task, and configuration save confirmation for the second task.

#### Example 5: Using `raw` with Privilege Escalation
```yaml
- name: Install package with sudo
  ansible.builtin.raw: apt-get install -y nginx
  become: yes
  become_method: sudo
  register: nginx_install
```
**Explanation**: This task installs Nginx using sudo for privilege escalation. The `become` and `become_method` parameters ensure the command runs with elevated privileges. Output shows installation progress in `stdout`, with `rc: 0` indicating success. This is useful for systems where Python isn't available initially but sudo access exists.

#### Example 6: Complex Command with Error Handling
```yaml
- name: Check disk space and clean if needed
  ansible.builtin.raw: df -h / | tail -1 | awk '{print $5}' | sed 's/%//'
  register: disk_usage
  failed_when: disk_usage.rc != 0
  changed_when: false

- name: Clean up if disk usage is high
  ansible.builtin.raw: find /tmp -type f -name "*.tmp" -delete
  when: disk_usage.stdout|int > 80
  register: cleanup_result
```
**Explanation**: These tasks check disk usage and clean temporary files if usage exceeds 80%. The first task uses a pipeline of commands to extract the disk usage percentage. The `failed_when` condition ensures the task fails only if the command returns an error. The second task deletes temporary files only when disk usage is high. Output shows disk usage percentage in `stdout` for the first task, and cleanup results for the second task.

#### Example 7: Checking System Status
```yaml
- name: Check system uptime
  ansible.builtin.raw: uptime
  register: system_uptime

- name: Check memory usage
  ansible.builtin.raw: free -m | grep Mem | awk '{printf "%.2f%%", $3/$2 * 100.0}'
  register: memory_usage
```
**Explanation**: These tasks check system uptime and memory usage. The uptime command shows how long the system has been running, while the memory command calculates the percentage of used memory. Output shows uptime information in `stdout` for the first task (e.g., "14:30:15 up 2 days, 3:45") and memory percentage for the second task (e.g., "65.42%").

#### Example 8: File Operations Without Python
```yaml
- name: Create directory if it doesn't exist
  ansible.builtin.raw: mkdir -p /opt/app/data
  register: mkdir_result
  changed_when: mkdir_result.rc == 0

- name: Set file permissions
  ansible.builtin.raw: chmod 755 /opt/app/data
  register: chmod_result
```
**Explanation**: These tasks perform file operations without requiring Python. The first creates a directory with parent directories if needed (`mkdir -p`). The second sets directory permissions. The `changed_when` conditions ensure the tasks report changes only when they actually modify the system. Output shows command execution results, with `rc: 0` indicating success.

#### Example 9: Using Environment Variables with `executable`
```yaml
- name: Run command with custom environment
  ansible.builtin.raw:
    cmd: 'echo $MY_VAR && env | grep MY_VAR'
    executable: /bin/bash
  environment:
    MY_VAR: "custom_value"
  register: env_test
```
**Explanation**: This task demonstrates using environment variables with the raw module. The `executable` parameter is set to `/bin/bash`, which allows environment variable usage. The command both echoes the custom variable and shows it in the environment listing. Output shows "custom_value" in `stdout` for the echo command, and the environment variable listing from the grep command.

#### Example 10: Service Management Without Python
```yaml
- name: Check if service is running
  ansible.builtin.raw: systemctl is-active nginx
  register: nginx_status
  failed_when: nginx_status.rc != 0 and nginx_status.rc != 3
  changed_when: false

- name: Start service if not active
  ansible.builtin.raw: systemctl start nginx
  when: nginx_status.rc != 0
  register: nginx_start
```
**Explanation**: These tasks manage the Nginx service without requiring Python. The first checks if the service is active, with special handling for return codes (0 for active, 3 for inactive). The second starts the service if it's not active. The `failed_when` condition ensures the task only fails for unexpected errors. Output shows service status in `stdout` for the first task (e.g., "active" or "inactive"), and service start results for the second task.

#### Summary Table of Arguments

| Argument Name | Type | Default Value | Possible Values | Required | Notes/Deprecations |
|---------------|------|---------------|-----------------|----------|--------------------|
| executable    | string | None         | Absolute path to shell (e.g., '/bin/bash') | No      | Required with become if no default shell |
| free_form     | string | None         | Any shell command (e.g., 'yum install python') | Yes     | Not a named param; free-form input |

# 2.10.7. Host Variables

2025-08-11 23:08
Status: #DONE 
Tags: [[Ansible]]

---
# Host and Group Variables in Ansible Inventory: A Comprehensive Guide

## Introduction

In Ansible, variables are the cornerstone of flexible configuration management. One of the most powerful features is the ability to define variables at different levels of your inventory hierarchy—from individual hosts to entire groups. This capability allows you to create reusable automation that adapts to different environments, systems, and configurations. This article explores how to effectively assign variables to hosts and groups, understand the merging behavior when hosts belong to multiple groups, and control the precedence order to achieve predictable results.

## In Simple Terms: Host and Group Variables Explained

Imagine you're organizing a school trip with several buses (groups) and many students (hosts). Each student might have specific needs (host variables), like requiring a window seat or having allergies. At the same time, each bus might have shared rules (group variables), like "no eating on the bus" or "keep voices down".

In Ansible:
- **Host variables** are like individual student instructions—specific to one host.
- **Group variables** are like bus rules—shared by all hosts in that group.

When a student is on multiple buses (a host in multiple groups), they need to follow all the rules. If buses have conflicting rules (like one says "no headphones" and another says "headphones required"), there needs to be a way to decide which rule takes priority. Ansible has a specific order for resolving these conflicts, which we'll explore in detail.

## In-Depth Analysis: Host and Group Variables in Ansible

### Assigning Variables to Individual Hosts

You can define variables directly for individual hosts in your inventory file. This is useful for host-specific configurations that don't apply to other systems. Host variables are assigned inline with the host definition and can include connection parameters or custom settings. They are interpreted as Python literals, supporting strings, numbers, booleans, and other types.

**Example 1: Simple host variables**
```ini
[myservers]
192.168.56.2 http_port=80 myvar=2
192.168.56.3 http_port=8080 myvar=3
```

In this example, each host has its own `http_port` and `myvar` values. Host 192.168.56.2 uses port 80 and `myvar=2`, while host 192.168.56.3 uses port 8080 and `myvar=3`. This approach ensures unique port assignments for web servers on different machines.

**Example 2: Connection parameters as host variables**
```ini
[myservers]
192.168.56.2 ansible_connection=ssh ansible_user=arman ansible_become_password=qazwsx
192.168.56.3 ansible_connection=ssh ansible_user=arman_ala ansible_become_password=qaz
```

Here, we're defining connection parameters for each host. Each host has a different user (`arman` and `arman_ala`) and become password, which is a common pattern for environments with different credentials per system. The `ansible_connection` variable specifies the connection type, while `ansible_user` and `ansible_become_password` handle authentication and privilege escalation.

**Example 3: Complex host variables**
```ini
[webservers]
web01.example.com ansible_host=192.168.1.10 http_port=80 max_connections=100 ssl_enabled=true
web02.example.com ansible_host=192.168.1.11 http_port=8080 max_connections=150 ssl_enabled=false
```

This example shows more complex host variables including the actual IP address (using `ansible_host`), configuration parameters, and feature flags. The `ssl_enabled` boolean demonstrates type support, where `true` enables SSL on web01 but disables it on web02, allowing for tailored security configurations.

**Example 4: Inventory aliases with host variables (YAML format)**
```yaml
all:
  hosts:
    jumper:
      ansible_port: 5555
      ansible_host: 192.0.2.50
      custom_setting: enabled
```

In this YAML inventory, `jumper` is an alias for the host at 192.0.2.50, with a non-standard SSH port (5555) and a custom setting. This format is equivalent to INI but offers better readability for complex structures, where `ansible_port` overrides the default SSH port for secure connections.

**Example 5: Host variables for AWS EC2 instances**
```ini
[ec2-instances]
ec2-01 ansible_host=ec2-198-51-100-1.compute-1.amazonaws.com instance_type=t2.micro security_group=web
ec2-02 ansible_host=ec2-198-51-100-2.compute-1.amazonaws.com instance_type=t3.medium security_group=database
```

This assigns AWS-specific variables like `instance_type` and `security_group` to individual EC2 hosts. It allows Ansible to manage cloud resources with host-tailored settings, such as applying different security groups based on roles.

**Example 6: Host variables for backup configuration**
```ini
[backups]
backup01.example.com backup_dir=/mnt/backup retention_days=30 compression=gzip
backup02.example.com backup_dir=/var/backup retention_days=7 compression=bzip2
```

This example defines host-specific backup settings, such as directory paths and retention policies. The `compression` variable allows each backup server to use a different compression algorithm, tailoring resource usage.

**Example 7: Host variables with authentication tokens**
```ini
[apiservers]
api01.example.com api_token=xyz123 rate_limit=1000
api02.example.com api_token=abc456 rate_limit=500
```

Here, each API server has a unique token and rate limit, ensuring secure and optimized API access per host.

### Assigning Variables to Groups

When multiple hosts share the same variable values, you can define these variables once for the entire group rather than repeating them for each host. Group variables are defined in a `:vars` subsection and apply to all members, facilitating shared configurations.

**Example 1: Basic group variables**
```ini
[myservers]
192.168.56.2
192.168.56.3

[myservers:vars]
http_port=80
ntp_server=ntp.arman.example.com
```

In this example, both hosts in the `myservers` group will have `http_port=80` and `ntp_server=ntp.arman.example.com`. This is more efficient than defining the same variables for each host individually, ensuring consistent time synchronization across servers.

**Example 2: Multiple groups with variables**
```ini
[webservers]
web01.example.com
web02.example.com

[webservers:vars]
http_port=80
max_connections=100

[dbservers]
db01.example.com
db02.example.com

[dbservers:vars]
db_port=3306
max_connections=200

[all:vars]
ntp_server=pool.ntp.org
```

Here, we have three groups with their own variables:
- `webservers` group has `http_port` and `max_connections` variables.
- `dbservers` group has `db_port` and `max_connections` variables.
- `all` group (special group that includes all hosts) has `ntp_server` variable.

The `all` group provides a global fallback for NTP configuration, while role-specific groups handle database or web settings.

**Example 3: Nested groups with variables**
```ini
[production]
web01.prod.example.com
db01.prod.example.com

[development]
web01.dev.example.com
db01.dev.example.com

[webservers:children]
production
development

[webservers:vars]
http_port=80
app_environment: "{{ 'production' if 'production' in group_names else 'development' }}"
```

This example shows nested groups where `webservers` includes both `production` and `development` groups. The `app_environment` variable uses a conditional expression to set its value based on the host's group membership, dynamically adapting to the environment.

**Example 4: Group variables for regional settings (YAML format)**
```yaml
atlanta:
  hosts:
    host1:
    host2:
  vars:
    ntp_server: ntp.atlanta.arman.example.com
    proxy: proxy.atlanta.arman.example.com
    region: east_coast
```

This YAML group variable assignment applies regional NTP and proxy settings to hosts in Atlanta, demonstrating how YAML can structure shared variables for location-based configurations.

**Example 5: Group variables with inheritance in nested groups**
```yaml
southeast:
  children:
    atlanta:
      hosts:
        host1:
        host2:
    raleigh:
      hosts:
        host3:
        host4:
  vars:
    some_server: foo.southeast.arman.example.com
    halon_system_timeout: 30
    self_destruct_countdown: 60
    escape_pods: 2
```

Here, the `southeast` parent group defines variables inherited by child groups `atlanta` and `raleigh`, such as emergency settings (`halon_system_timeout`), illustrating inheritance for regional policies.

**Example 6: Group variables for load balancer settings**
```ini
[loadbalancers]
lb01.example.com
lb02.example.com

[loadbalancers:vars]
health_check_interval=10
backend_timeout=30
ssl_cert_path=/etc/ssl/lb.crt
```

This defines shared load balancer configurations, ensuring consistent health checks and SSL settings across all load balancer hosts.

**Example 7: Group variables for logging configuration**
```yaml
logservers:
  hosts:
    log01.example.com:
    log02.example.com:
  vars:
    log_retention_days: 90
    log_level: info
    log_destination: /var/log/app
```

This YAML example sets logging parameters for log servers, standardizing retention and logging levels across the group.

### Variable Merging for Hosts in Multiple Groups

When a host belongs to multiple groups, Ansible merges variables from all those groups. If the same variable is defined in multiple groups, Ansible uses a specific precedence order to determine which value to use. By default, variables are overwritten (hash_behavior=replace), but can be set to merge with ansible.cfg.

**Default Merging Order:**
1. `all` group (lowest precedence)
2. Parent groups
3. Child groups
4. Host-specific variables (highest precedence)

**Example 1: Variable Merging**
```ini
[all:vars]
http_port=80
max_connections=50

[webservers:vars]
http_port=8080
ssl_enabled=true

[production:vars]
max_connections=200
ssl_enabled=false

[webservers]
web01.example.com
web02.example.com

[production]
web01.example.com
db01.example.com
```

For host `web01.example.com` (which is in both `webservers` and `production` groups):
- `http_port` would be `8080` (from `webservers` group, overriding `all` group).
- `max_connections` would be `200` (from `production` group, overriding `all` group).
- `ssl_enabled` would be `false` (from `production` group, overriding `webservers` group).

This merging ensures production overrides take priority for critical settings like SSL.

**Example 2: Merging with package lists**
```ini
[all:vars]
packages=["vim", "git"]

[webservers:vars]
packages=["nginx", "apache2"]

[webservers]
web01

[production:vars]
packages=["mysql-client"]
```

If hash_behavior=merge in ansible.cfg, `packages` for web01 would be `["vim", "git", "nginx", "apache2", "mysql-client"]`, combining lists from all groups. Otherwise, the last definition (`mysql-client`) overrides.

**Example 3: Overriding with host vars**
```ini
[webservers:vars]
db_host=internal-db.example.com

[webservers]
app-server db_host=external-db.example.com
```

For `app-server`, `db_host` is `external-db.example.com` (host var overrides group var), allowing exceptions in shared groups.

**Example 4: Merging with nested groups**
```ini
[us_west:vars]
region="west"
timezone="PST"

[webservers:vars]
http_port=80
log_level=debug

[us_west]
web01.west.example.com

[webservers]
web01.west.example.com
```

For `web01.west.example.com`, variables are:
- `region=west` (from `us_west`).
- `timezone=PST` (from `us_west`).
- `http_port=80` (from `webservers`).
- `log_level=debug` (from `webservers`).

This shows how variables from different groups combine without conflicts.

**Example 5: Host override in nested groups**
```ini
[parent_group:vars]
default_path=/opt/app

[child_group:vars]
default_path=/var/app

[parent_group]
host1 default_path=/custom/app

[child_group]
host1
```

For `host1`, `default_path=/custom/app` (host variable overrides both parent and child group vars), demonstrating host precedence.

### ASCII Order Merging for Groups at Same Level

By default, when groups are at the same level in the hierarchy (neither parent nor child of each other), Ansible merges them in ASCII alphabetical order. The last group loaded overwrites the previous groups.

**Example 1: ASCII Order Merging**
```ini
[alpha:vars]
test_var="alpha_value"

[beta:vars]
test_var="beta_value"

[alpha]
host1

[beta]
host1
```

For `host1` (which is in both `alpha` and `beta` groups):
- Since `beta` comes after `alpha` in ASCII order, `test_var` would be `"beta_value"`. Alphabetical merging ensures consistent override based on group names.

**Example 2: ASCII merging with multiple groups**
```ini
[group_a:vars]
config="a_setting"

[group_b:vars]
config="b_setting"

[group_c:vars]
config="c_setting"

[group_a]
host2

[group_b]
host2

[group_c]
host2
```

For `host2`, `config` is `"c_setting"` (group_c last in ASCII order: a, b, c), demonstrating how naming affects precedence.

**Example 3: ASCII merging with lists**
```ini
[group_x:vars]
tools=["git"]

[group_y:vars]
tools=["docker"]

[group_x]
server1

[group_y]
server1
```

For `server1`, `tools=["docker"]` (group_y overrides group_x in ASCII order), unless `hash_behavior=merge`, then `tools=["git", "docker"]`.

### Changing Merge Order with ansible_group_priority

You can override the default ASCII order merging by setting the `ansible_group_priority` variable for groups. Groups with higher priority values will override groups with lower priority values. The default priority is 1.

**Example 1: Using ansible_group_priority**
```ini
[alpha:vars]
test_var="alpha_value"
ansible_group_priority=10

[beta:vars]
test_var="beta_value"
ansible_group_priority=5

[alpha]
host1

[beta]
host1
```

For `host1`:
- Even though `beta` comes after `alpha` in ASCII order, `alpha` has a higher priority (10 vs 5), so `test_var` would be `"alpha_value"`. This allows explicit control over merging for logically important groups.

**Example 2: Priority in nested environments**
```ini
[staging:vars]
db_backup=false
ansible_group_priority=15

[production:vars]
db_backup=true
ansible_group_priority=10

[staging]
db-host

[production]
db-host
```

For `db-host`, `db_backup=false` (staging has higher priority, 15 > 10), prioritizing staging overrides for safety.

**Example 3: Equal priority fallback**
```ini
[group1:vars]
setting="value1"
ansible_group_priority=5

[group2:vars]
setting="value2"
ansible_group_priority=5

[group1]
host3

[group2]
host3
```

For `host3`, `setting="value2"` (group2 wins due to ASCII order when priorities are equal), showing fallback behavior.

### Best Practices for Host and Group Variables

1. **Organize Variables by Scope**: Place variables at the most appropriate level—use host variables for truly host-specific values and group variables for shared configurations.
2. **Use Group Hierarchy Effectively**: Leverage parent-child relationships in groups to create logical inheritance of variables. For instance, define base settings in parent groups and overrides in children.
3. **Minimize Conflicts**: Avoid defining the same variable in multiple groups when possible to reduce complexity. Use merging (hash_behavior=merge) for combining lists or dictionaries.
4. **Document Your Variable Structure**: Clearly document your group hierarchy and variable assignments to help others understand the precedence. Include comments in inventory files for clarity.
   ```ini
   [webservers:vars]
   http_port=80  # Default web server port
   ```
5. **Use External Variable Files**: For complex configurations, use `group_vars` and `host_vars` directories instead of inline variables to separate concerns and improve maintainability.
   ```yaml
   # group_vars/webservers.yml
   http_port: 80
   ```
6. **Leverage ansible_group_priority**: Use `ansible_group_priority` to explicitly define merge order when ASCII order doesn't match your needs. Set higher values for critical groups.
   ```ini
   [critical:vars]
   security_level=high
   ansible_group_priority=20
   ```
7. **Test Variable Merging**: Verify precedence with hosts in multiple groups using `ansible-inventory --list` to inspect merged variables.
   ```bash
   ansible-inventory --list -i inventory.yml
   ```
8. **Use Special Groups Wisely**: Reserve the `all` group for universal defaults like timezones, avoiding overuse for specific settings.
9. **Enable Merging for Complex Data**: Set `hash_behaviour=merge` in `ansible.cfg` for dictionaries or lists to combine rather than override, preventing data loss.
   ```ini
   [defaults]
   hash_behaviour=merge
   ```
10. **Prefer YAML for Complex Inventories**: Use YAML format for inventories with nested groups or extensive variables for better readability compared to INI.
11. **Secure Sensitive Data**: Use Ansible Vault for sensitive host or group variables (e.g., passwords, tokens).
    ```bash
    ansible-vault create group_vars/secrets.yml
    ```
12. **Validate Variables**: Use the `assert` module to ensure critical variables are defined.
    ```yaml
    - name: Ensure http_port is defined
      assert:
        that: "http_port is defined"
        fail_msg: "http_port must be set"
    ```

## Advanced Example: Complex Variable Merging

Here's a comprehensive example demonstrating all concepts:

```ini
# Inventory file
[all:vars]
global_setting="default_global"
timezone="UTC"

[east:vars]
region="east"
timezone="EST"

[west:vars]
region="west"
timezone="PST"

[webservers:vars]
http_port=80
max_connections=100
ansible_group_priority=10

[dbservers:vars]
db_port=3306
backup_enabled=true
ansible_group_priority=5

[production:vars]
environment="production"
max_connections=200
backup_enabled=false

[development:vars]
environment="development"
max_connections=50
debug_mode=true

[east]
web01.east.example.com
db01.east.example.com

[west]
web01.west.example.com
db01.west.example.com

[webservers]
web01.east.example.com
web01.west.example.com

[dbservers]
db01.east.example.com
db01.west.example.com

[production]
web01.east.example.com
db01.east.example.com

[development]
web01.west.example.com
db01.west.example.com
```

For host `web01.east.example.com`:
- Belongs to groups: `all`, `east`, `webservers`, `production`
- Variable values:
  - `global_setting`: "default_global" (from `all` group)
  - `region`: "east" (from `east` group)
  - `timezone`: "EST" (from `east` group, overriding `all` group)
  - `http_port`: 80 (from `webservers` group)
  - `max_connections`: 200 (from `production` group, overriding `webservers` group due to alphabetical merging or priority)
  - `environment`: "production" (from `production` group)

For host `web01.west.example.com`:
- Belongs to groups: `all`, `west`, `webservers`, `development`
- Variable values:
  - `global_setting`: "default_global" (from `all` group)
  - `region`: "west" (from `west` group)
  - `timezone`: "PST" (from `west` group, overriding `all` group)
  - `http_port`: 80 (from `webservers` group)
  - `max_connections`: 50 (from `development` group, overriding `webservers` group)
  - `environment`: "development" (from `development` group)
  - `debug_mode`: true (from `development` group)

**Advanced Example 2: Merging with external group_vars**
Assume a `group_vars/webservers.yml` file:
```yaml
packages:
  - nginx
  - php
debug: false
```

And `group_vars/production.yml`:
```yaml
packages:
  - mysql-client
debug: true
```

For a host in both, with `hash_behavior=merge`, `packages` becomes `["nginx", "php", "mysql-client"]` and `debug=true` (production overrides). This external approach separates variables from inventory for cleaner management.

**Advanced Example 3: Priority overriding alphabetical order**
```ini
[low_priority_group:vars]
feature_flag=true
ansible_group_priority=1

[high_priority_group:vars]
feature_flag=false
ansible_group_priority=20

[low_priority_group]
multi-host

[high_priority_group]
multi-host
```

For `multi-host`, `feature_flag=false` (higher priority overrides despite alphabetical order), useful for enforcing security features in mixed environments.

**Advanced Example 4: Complex nested groups with external vars**
Assume `group_vars/southeast.yml`:
```yaml
region: southeast
backup_frequency: daily
```

And `group_vars/atlanta.yml`:
```yaml
backup_frequency: hourly
log_level: debug
```

```yaml
southeast:
  children:
    atlanta:
      hosts:
        server1:
        server2:
  vars:
    region: southeast
```

For `server1`, variables are:
- `region=southeast` (from `southeast`).
- `backup_frequency=hourly` (from `atlanta`, overriding `southeast`).
- `log_level=debug` (from `atlanta`).

This demonstrates external variable files and child group overrides.

## Conclusion

Host and group variables in Ansible provide a powerful way to manage configurations across your infrastructure. By understanding how variables are assigned to individual hosts and groups, how they merge when hosts belong to multiple groups, and how to control the precedence order, you can create flexible, maintainable automation that adapts to different environments and requirements.

The key to effective variable management is organizing your variables at the appropriate level of specificity, leveraging group hierarchies for logical inheritance, and using tools like `ansible_group_priority` when the default behavior doesn't match your needs. With these techniques, you can build robust automation solutions that scale with your infrastructure while remaining clear and predictable.

## Summary Table: Host and Group Variables in Ansible

| Concept | Description | Key Features/Precedence | Example |
|---------|-------------|-------------------------|---------|
| Host Variables | Specific to individual hosts; highest precedence, overriding all group vars. | Assigned inline; supports connection params, custom settings; interpreted as Python literals. | `host1 http_port=80 ansible_user=arman` - Sets unique port and user for host1. |
| Group Variables | Shared across all hosts in a group; applied via `:vars` section or `group_vars`. | Medium precedence; overrides `all` but superseded by child groups/hosts; supports nesting. | `[group:vars] ntp_server=ntp.arman.example.com` - Applies NTP to all group members. |
| Variable Merging | Combines vars from multiple groups; last wins by default (replace). | Order: all < parent < child < host; merge option for lists/dicts via ansible.cfg. | Host in two groups: var from later alphabetical group overrides unless priority set. |
| ASCII Order Merging | Default for same-level groups; alphabetical sort determines override. | Last group in ASCII order wins; consistent but name-dependent. | Groups `alpha` and `beta`: `beta` overrides if same var defined. |
| ansible_group_priority | Overrides ASCII merging; higher value = later merge/higher precedence. | Default 1; explicit control for logical priority. | Group with priority 10 overrides group with 5, regardless of name. |
| Nested Groups | Parent-child relationships for inheritance. | Child vars override parent; useful for environments/regions. | `[parent:children] child1 child2` - Parent vars inherited, child overrides possible. |
| External Files | `group_vars`/`host_vars` directories for separation. | Same precedence as inline; better for complex configs. | `group_vars/webservers.yml` - Stores vars outside inventory file. |
| Best Practices | Scope appropriately, minimize conflicts, test merging. | Use YAML for readability; enable merge for data structures; document hierarchy. | Leverage `all` for globals, priorities for critical overrides, Vault for secrets. |
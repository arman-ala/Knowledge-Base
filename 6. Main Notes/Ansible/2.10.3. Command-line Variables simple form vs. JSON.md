# 2.10.3. Command-line Variables simple form vs. JSON

2025-08-10 22:07
Status: #DONE 
Tags: [[Ansible]]

---
In Ansible, the command-line method for passing extra variables using the `--extra-vars` (or `-e`) option supports two primary formats: the key-value pair syntax and the JSON syntax. These approaches allow users to define or override variables at runtime, with the highest precedence in Ansible's variable hierarchy, ensuring they supersede variables defined in playbooks, roles, or inventory files. Below, a detailed explanation of each format is provided, followed by a comparative analysis and specific examples with precise explanations.

The key-value pair format involves specifying variables as space-separated `key=value` assignments within a quoted string passed to `-e`. This method interprets all values as strings, regardless of their intended type, making it straightforward for simple string-based variables but limited for complex data structures. It is best suited for quick overrides of scalar values, such as ports or paths, and does not support native data types like booleans, numbers, lists, or dictionariesâ€”any such input is coerced into a string. For instance, if a value contains spaces or special characters, it must be enclosed in inner quotes to prevent shell interpretation errors. This format is efficient for minimal configurations but can become cumbersome with multiple variables or when precise typing is required. Multiple `-e` options can be used, and each subsequent option overrides previous definitions if the same key is specified.

In contrast, the JSON format enables passing variables as a JSON object enclosed in curly braces `{}` and typically wrapped in single quotes to protect it from shell expansion. This approach preserves native data types, including strings, integers, booleans, arrays (lists), and objects (dictionaries), allowing for more sophisticated and nested structures without type coercion. It is particularly advantageous for scenarios involving complex configurations, such as defining lists of users or multi-level application settings, as Ansible parses the JSON directly into appropriate variable types. However, it requires valid JSON syntax, which can introduce errors if not properly formatted, and may necessitate escaping certain characters in values. This format offers greater flexibility and is recommended when non-string types or hierarchical data are needed. Like the key-value format, multiple `-e` options can be specified, with later ones overriding earlier definitions, and it also supports referencing external files via `@filename` for larger datasets.

Comparing the two formats, the key-value pair method excels in simplicity and speed for basic, string-only use cases, requiring less syntactic overhead and being easier to type inline without tools for JSON validation. However, it lacks support for type preservation and nesting, potentially leading to runtime errors if a playbook expects a non-string type (e.g., a boolean `true` becomes the string `"true"`, which evaluates differently in conditionals). The JSON format, while more verbose and prone to syntax mistakes, provides superior flexibility, type accuracy, and support for complex data, making it scalable for enterprise-level automation where variables might include arrays or dictionaries. In terms of precedence and behavior, both formats operate identically at runtime, but JSON is preferable for avoiding implicit string conversion issues. Additionally, the key-value format cannot handle values with embedded equals signs without additional quoting, whereas JSON treats such content as part of the value string. For large or reusable variable sets, neither is ideal inline; instead, both can reference external files via `@filename`, where the file contains YAML or JSON, but this falls outside the direct command-line forms discussed here.

To illustrate, consider the following examples. For the key-value format: `ansible-playbook site.yml -e "http_port=8080 max_clients=200 debug_mode=true"`. Here, `http_port` is set to the string `"8080"`, `max_clients` to `"200"`, and `debug_mode` to `"true"`; if a task in the playbook uses `debug_mode` in a conditional like `when: debug_mode | bool`, it would evaluate to `true` only because Ansible can filter the string, but numeric comparisons on `http_port` might require explicit conversion (e.g., `http_port | int`). This command is simple for overriding basic server settings but treats everything as strings, potentially necessitating filters in playbooks for type handling.

For the JSON format: `ansible-playbook site.yml -e '{"http_port":8080, "max_clients":200, "debug_mode":true, "allowed_users":["admin","guest"]}'`. In this case, `http_port` is an integer `8080`, `max_clients` an integer `200`, `debug_mode` a boolean `true`, and `allowed_users` a list `["admin", "guest"]`; these types are preserved natively, allowing direct use in tasks without conversion (e.g., looping over `allowed_users` or numeric operations on `http_port`). This enables more robust configurations, such as defining multi-user access lists, but requires careful JSON formatting to avoid parsing errors during execution.

| Aspect                  | Key-Value Pair Format                                                                 | JSON Format                                                                    |
|-------------------------|---------------------------------------------------------------------------------------|-----------------------------------------------------------------------------|
| Syntax                  | Space-separated `key=value` pairs, e.g., `-e "key1=value1 key2=value2"`              | JSON object, e.g., `-e '{"key1":"value1", "key2":"value2"}'`                   |
| Data Type Support       | Limited to strings; all values coerced to strings                                     | Supports strings, numbers, booleans, lists, dictionaries                       |
| Complex Structures      | Not supported; requires workarounds like string representation                        | Fully supported with native parsing                                            |
| Ease of Use             | Simple for basic scalars; quick to type                                               | More verbose; requires valid JSON syntax                                       |
| Limitations             | Cannot handle nested data; values with spaces or equals signs need careful quoting   | Prone to syntax errors; inline can be unwieldy for large data                  |
| Precedence/Behavior     | Highest precedence; multiple `-e` options override previous; string interpretation   | Highest precedence; multiple `-e` options override previous; type preservation |
| Best Use Cases          | Quick overrides of simple string variables                                            | Passing non-strings or complex structures like lists/dictionaries              |
| Pros                    | Minimal overhead; easy for single values                                              | Flexible; preserves types; suitable for hierarchical data                      |
| Cons                    | Type coercion issues; limited expressiveness                                          | Error-prone syntax; less convenient for manual input                           |
| Best Practices          | Use quotes for values with spaces; avoid for non-strings                              | Validate JSON beforehand; use `@file.json` for large sets                      

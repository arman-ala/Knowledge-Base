# 2.7. Ansible Playbook Structure

2025-08-08 12:46
Status: #DONE 
Tags: [[Ansible]]

---
### Mastering Ansible Project Structure: A Guide to Organized Automation

#### Introduction
As a DevOps enthusiast, you know Ansible is a game-changer for automating server setups and deployments. But without a solid project structure, things can quickly turn into a chaotic mess—think of a kitchen with ingredients scattered everywhere! This article dives into crafting an organized Ansible project layout, drawing from practical insights and community best practices. We’ll explore this in two ways: a simple breakdown for those just starting out and a detailed, technical deep dive for seasoned pros.

#### Simple Breakdown: Getting the Lay of the Land
Picture Ansible as a master chef preparing a feast. To keep things smooth, the chef needs a clear workspace with a recipe book (the playbook), a list of restaurants to cook for (inventory), and organized stations for ingredients (files), cooking steps (tasks), and special sauces (variables). Start by setting up a main folder, like `/home/ansible/provision`, where you stash a main plan file (e.g., `project.yml`) and a `Hosts` file to track your servers. Then, create a `roles` area with subfolders for specific jobs—like setting up a Postgres database or a Golang app—each with its own tools and instructions. This setup keeps everything neat, making it easy to find what you need and work with a team.

#### Detailed Exploration: The Anatomy of an Ansible Project

![[2.7. Ansible playbook structure.png]]

##### Core Project Structure
The foundation of an Ansible project is a well-defined root directory, typically `/home/ansible/provision`, which houses all key components. This structure is built using specific commands to ensure consistency and scalability.

- **Root Directory Setup**:
  - **Command**: 
```bash
mkdir -p /home/ansible/provision
```
  - **Explanation**: The `-p` flag creates the directory and any missing parent directories without throwing errors, ensuring a clean start. This becomes the central hub for your project.
  - **Purpose**: Serves as the base where all Ansible files reside, making it easy to navigate and share.

- **Main YAML File**:
  - **Command**: 
```bash
nano /home/ansible/provision/project.yml
```
  - **Explanation**: Opens a text editor to create `project.yml`, the entry-point playbook that orchestrates the automation process. You can name it something descriptive like `deploy_golang_app.yml` for clarity.
  - **Purpose**: Acts as the high-level plan, linking roles and hosts without diving into task details (which we’ll cover later).
  - **Best Practice**: Keep it version-controlled (e.g., in Git) and use meaningful names to reflect its intent.

- **Inventory Directory**:
  - **Command**: 
```bash
mkdir /home/ansible/provision/inventory
nano /home/ansible/provision/inventory/Hosts
```
  - **Explanation**: Creates an `inventory` folder and a `Hosts` file to list servers and groups (e.g., `[dbservers]` or `[web]`). The `nano` command lets you edit this file to define your target machines.
  - **Purpose**: Provides Ansible with the target landscape, essential for knowing where to apply changes. The `inventory` directory will be used for all of your projects.
  - **Tip**: For cloud setups, consider a dynamic inventory script (e.g., AWS EC2) instead of a static file.

- **Roles Directory**:
  - **Command**: 
```bash
mkdir /home/ansible/provision/roles
mkdir /home/ansible/provision/roles/project
```
  - **Explanation**: Establishes a `roles` directory with a subfolder `project` (or a role-specific name like `postgres_setup`). This is where reusable automation units live.
  - **Purpose**: Encapsulates all role-specific logic, promoting modularity. The `roles` directory will be used for all of your projects.
  - **Best Practice**: Name roles based on their function (e.g., `golang_app`, `redis_cluster`) for clarity.

##### Role Subdirectory Breakdown
Each role (e.g., `project`) contains subdirectories, each with a specific role in the automation process. Here’s a detailed look:

- **defaults**:
  - **Command**: 
    ```bash
    mkdir /home/ansible/provision/roles/project/defaults
    nano /home/ansible/provision/roles/project/defaults/main.yml
    ```
  - **Explanation**: Holds `main.yml` with default variables (e.g., `postgres_port: 5432`). These have the lowest precedence and can be overridden.
  - **Purpose**: Provides baseline settings that apply unless changed elsewhere.
  - **Tip**: Use for optional configurations that teams can tweak.

- **files**:
  - **Command**: 
    ```bash
    mkdir /home/ansible/provision/roles/project/files
    ```
  - **Explanation**: Stores static files (e.g., a Redis config file) to copy to remote hosts without modification.
  - **Purpose**: Houses assets that don’t need templating.
  - **Best Practice**: Organize by file type or role purpose (e.g., `redis.conf`, `golang_binary`).

- **vars**:
  - **Command**: 
    ```bash
    mkdir /home/ansible/provision/roles/project/vars
    nano /home/ansible/provision/roles/project/vars/main.yml
    ```
  - **Explanation**: Contains `main.yml` with variables (e.g., `mysql_root_password: securepass`) that override defaults, offering higher precedence.
  - **Purpose**: Manages role-specific, environment-sensitive data.
  - **Tip**: Encrypt sensitive data using Ansible Vault.

- **tasks**:
  - **Command**: 
    ```bash
    mkdir /home/ansible/provision/roles/project/tasks
    nano /home/ansible/provision/roles/project/tasks/main.yml
    ```
  - **Explanation**: Holds `main.yml` with the core tasks (e.g., install Postgres, start Redis), defining what the role does.
  - **Purpose**: Drives the role’s execution logic.
  - **Best Practice**: Keep tasks modular and focused (e.g., one task per major action).

- **handlers**:
  - **Command**: 
    ```bash
    mkdir /home/ansible/provision/roles/project/handlers
    nano /home/ansible/provision/roles/project/handlers/main.yml
    ```
  - **Explanation**: Contains `main.yml` with handlers (e.g., `restart redis`) triggered by task notifications.
  - **Purpose**: Manages state changes (e.g., service restarts) efficiently.
  - **Tip**: Use sparingly for critical updates only.

- **templates**:
  - **Command**: 
    ```bash
    mkdir /home/ansible/provision/roles/project/templates
    nano /home/ansible/provision/roles/project/templates/File.j2
    ```
  - **Explanation**: Stores Jinja2 templates (e.g., `golang_config.j2`) for dynamic file generation using variables.
  - **Purpose**: Enables customizable file deployment.
  - **Best Practice**: Embed variables (e.g., `{{ golang_version }}`) for flexibility.

- **meta**:
  - **Command**: 
    ```bash
    mkdir /home/ansible/provision/roles/project/meta
    nano /home/ansible/provision/roles/project/meta/main.yml
    ```
  - **Explanation**: Holds `main.yml` with role metadata, including dependencies (e.g., requiring a `base` role).
  - **Purpose**: Defines role relationships and documentation.
  - **Tip**: Clearly list dependencies to avoid runtime errors.

##### Advanced Structure Enhancements
Drawing from community insights (e.g., Medium articles and Ansible documentation), consider these additions:

- **Group and Host Variables**:
  - Structure: 
    ```
    inventory/
    ├── group_vars/
    │   ├── all.yml
    │   └── dbservers.yml
    └── host_vars/
        ├── db1.example.com.yml
    ```
  - **Purpose**: Customizes settings for groups (e.g., all servers) or individual hosts (e.g., `db1`).
  - **Tip**: Use `all.yml` for global defaults.

- **Environment Separation**:
  - Structure:
    ```
    environments/
    ├── prod/
    │   ├── group_vars/
    │   └── inventory/
    └── staging/
        ├── group_vars/
        └── inventory/
    ```
  - **Purpose**: Isolates production and staging configurations.
  - **Best Practice**: Mirror the main structure in each environment.

- **Custom Modules and Plugins**:
  - Structure:
    ```
    library/          # Custom modules
    module_utils/     # Shared code
    filter_plugins/   # Jinja2 filters
    ```
  - **Purpose**: Extends Ansible with tailored functionality.
  - **Tip**: Test custom modules in a sandbox first.

##### Real-World Example: Golang and Redis Deployment
For a Golang app with Redis:
```
golang_redis_deploy/
├── deploy_app.yml
├── inventory/
│   ├── production
│   └── staging
├── group_vars/
│   ├── all.yml
│   └── app_servers.yml
└── roles/
    ├── golang_app/
    │   ├── tasks/main.yml
    │   └── templates/app_config.j2
    └── redis_setup/
        ├── tasks/main.yml
        └── files/redis.conf
```
- **Explanation**: `golang_app` handles app deployment, while `redis_setup` manages the database, with templates and files tailored to each.

##### Best Practices and Tips
- **Best Practice**: Use Git for version control, excluding sensitive files with `.gitignore`.
- **Tip**: Add a `README.md` in each role to document its purpose and usage.
- **Best Practice**: Keep roles granular but not overly fragmented (e.g., one `postgres` role vs. separate install/config roles).
- **Tip**: Test the structure with `ansible-playbook --syntax-check` to catch errors early.

#### Conclusion
Mastering Ansible’s project structure transforms your automation from a haphazard effort into a streamlined process. By setting up a root directory with a main playbook, inventory, and role-based subdirectories—enhanced with group vars, environments, and custom plugins—you gain control over complex deployments like Golang apps or Redis clusters. Leveraging best practices from the community ensures your setup is maintainable, scalable, and team-friendly, setting the stage for deeper automation techniques in future discussions.
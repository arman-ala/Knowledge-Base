# 3.8. Copy Module

2025-08-13 06:20
Status: #DONE 
Tags: [[Ansible]]

---
## Understanding the Ansible Copy Module: A Comprehensive Guide

In the field of DevOps automation, Ansible's ability to manage file transfers across remote hosts is fundamental to configuration management and deployment workflows. The `ansible.builtin.copy` module stands as a versatile tool for copying files or directories from the local or remote machine to a specified location on the target host, with options to set permissions, ownership, and other attributes. This article explores the module in detail, incorporating insights from its official documentation and practical examples, such as the one depicted in the provided resource where a file is copied with specific ownership, mode, backup, and force options. We begin with a simplified overview for basic comprehension, followed by a thorough analysis of its parameters, including all possible values, best practices, and illustrative examples.

#### Simplified Explanation: Breaking It Down Simply

Think of the `copy` module as a reliable delivery service for your files: you specify what to send (a file or folder from your machine or another remote one), where it goes on the target host, and any special instructions like "set permissions to read-only" or "make a backup first." It ensures the file arrives intact, creating directories if needed, and can even validate the transfer. For instance, in the example shown, copying `myfile` to `/home/TestDir2` with root ownership, mode 0644, backup enabled, and force to overwrite demonstrates how it handles transfers securely. It's safer than manual SCP for automation, as it checks changes and supports idempotency—meaning it won't unnecessarily recopy files.

#### In-Depth Analysis: Precise and Comprehensive Coverage

The `ansible.builtin.copy` module, part of `ansible-core`, facilitates the transfer of files or directories to remote locations, allowing the application of meta-information such as permissions, ownership, and SELinux contexts. It operates recursively for directories but is not optimized for large numbers of files (hundreds or more), where alternatives like `synchronize` may perform better. Unlike the `template` module, which supports variable interpolation, `copy` is best for static content; using variables with `content` can lead to unpredictable results. For Windows targets, the equivalent is `ansible.windows.win_copy`. The module supports an action plugin for controller-side execution of some options and is designed for POSIX platforms, with attributes enabling safe file operations, vault decryption, and diff/check modes.

To use the module effectively, one must understand its parameters comprehensively. Below, each parameter is dissected, including its purpose, type, default value, all possible values, requirements, and interactions. Explanations incorporate best practices, tips, and tricks, along with examples drawn from documentation and the provided resource, complete with expected outputs and detailed reasoning.

- **attributes** (aliases: attr): Specifies extended attributes for the resulting filesystem object, as per the `chattr` command. Type: string. Default: None. Possible values: Any valid attribute string in `lsattr` order (e.g., 'e' for extent format, '+a' to add append-only, '-i' to remove immutable). Required: No. Notes: Assumes '=' by default; include '+' or '-' for modifications.

  Best practice: Use sparingly for specific security needs, like making files immutable. Tip: Check supported flags with `man chattr` on the target; trick: Combine with `mode` for comprehensive file hardening.

  Example: Set immutable attribute.
  ```yaml
  - name: Copy file with attributes
    ansible.builtin.copy:
      src: /local/important.conf
      dest: /etc/important.conf
      attributes: '+i'
  ```
  Expected output: File copied and set immutable (`changed: true` if modified); `lsattr` on remote shows '----i--------'; return values include `dest: /etc/important.conf`, `mode: 0644` (default), `checksum` for validation.

- **backup**: Creates a timestamped backup of the destination file if it exists and is modified. Type: boolean. Default: false. Possible values: true (enable backup), false (no backup). Required: No.

  Best practice: Enable for critical files to allow rollback. Tip: Backups are named like `file.2025-08-13@12:34~`; trick: Use with `register` to capture `backup_file` path for cleanup tasks.

  Example from resource: Backup enabled.
  ```yaml
  - name: Copy with backup
    ansible.builtin.copy:
      src: myfile
      dest: /home/TestDir2
      owner: root
      group: root
      mode: 0644
      backup: yes
      force: yes
      tags: [copy_mod]
  ```
  Expected output: If `/home/TestDir2/myfile` exists and differs, creates backup (e.g., `/home/TestDir2/myfile.2025-08-13@10:00~`), copies new file (`changed: true`); return: `backup_file: /home/TestDir2/myfile.<timestamp>~`, `checksum` matches src.

- **checksum**: SHA1 checksum for validating the transferred file. Type: string. Default: None (uses local src checksum). Possible values: Any valid SHA1 hash (40 hexadecimal characters). Required: No.

  Best practice: Provide for integrity checks in untrusted networks. Tip: Generate with `sha1sum src`; trick: Use with `validate` for double verification.

  Example: Validate with checksum.
  ```yaml
  - name: Copy with checksum
    ansible.builtin.copy:
      src: /local/data.bin
      dest: /remote/data.bin
      checksum: "abc123def456ghi789jkl012mno345pqr678stu9"
  ```
  Expected output: Transfers if checksum mismatches or file absent (`changed: true`); fails if post-copy checksum differs; return: `checksum: abc123def456ghi789jkl012mno345pqr678stu9`.

- **content**: Sets the file contents directly instead of using src. Type: string. Default: None. Possible values: Any string (e.g., text, config lines). Required: No (mutually exclusive with src). Notes: Only for files; creates if dest absent; avoid variables—use `template` instead.

  Best practice: Use for small, static content like placeholders. Tip: Escape special characters; trick: Combine with `mode` for secure configs.

  Example: Inline content.
  ```yaml
  - name: Copy inline content
    ansible.builtin.copy:
      content: '# This file was moved to /etc/other.conf'
      dest: /etc/mine.conf
  ```
  Expected output: Creates/updates `/etc/mine.conf` with content (`changed: true` if modified); return: `dest: /etc/mine.conf`, `size: content length`, no `src` since inline.

- **decrypt**: Controls decryption of vault-encrypted src files. Type: boolean. Default: true. Possible values: true (decrypt), false (treat as plain). Required: No. Notes: Does not work with `remote_src: yes`.

  Best practice: Keep true for secure workflows; set false for non-vault files. Tip: Ensure vault password is available; trick: Use with `vault_id` in playbooks.

  Example: Disable decryption.
  ```yaml
  - name: Copy without decryption
    ansible.builtin.copy:
      src: /local/encrypted.conf
      dest: /etc/encrypted.conf
      decrypt: false
  ```
  Expected output: Copies encrypted file as-is (`changed: true` if needed); fails if decryption expected but disabled.

- **dest**: Remote path for the copied file/directory. Type: path. Default: None. Possible values: Any absolute or relative path. Required: Yes. Notes: Creates directory if ends with '/' or src is directory; fails if parent absent for files.

  Best practice: Use absolute paths for consistency. Tip: Relative paths use remote user's cwd; trick: Pre-create parents with `file` module.

  Example: From resource, dest as directory.
  ```yaml
  - name: Copy to directory
    ansible.builtin.copy:
      src: myfile
      dest: /home/TestDir2
  ```
  Expected output: Copies to `/home/TestDir2/myfile` (`changed: true` if new); return: `dest: /home/TestDir2/myfile`.

- **directory_mode**: Permissions for newly created directories during recursive copy. Type: any (mode value). Default: None (system defaults). Possible values: Octal (e.g., 0755), symbolic (e.g., 'u+rwx,g+rx,o+rx'). Required: No. Notes: Affects only new directories; existing unchanged.

  Best practice: Set to restrict access (e.g., 0750). Tip: Matches `mode` syntax; trick: Use with recursive src for structured deployments.

  Example: Recursive with directory mode.
  ```yaml
  - name: Copy directory
    ansible.builtin.copy:
      src: /local/dir/
      dest: /remote/dir
      directory_mode: '0755'
  ```
  Expected output: Copies dir structure, sets new dirs to 0755 (`changed: true` per file); return: `gid`, `mode` for files/dirs.

- **follow**: Follows symlinks in dest during copy. Type: boolean. Default: false. Possible values: true (follow, overwrite target), false (replace link with file). Required: No.

  Best practice: Set true to update linked files. Tip: Avoid for security-sensitive links; trick: Check with `stat` first.

  Example: Follow symlink.
  ```yaml
  - name: Follow link
    ansible.builtin.copy:
      src: /etc/foo.conf
      dest: /path/to/link  # symlink to /path/to/file
      follow: yes
  ```
  Expected output: Overwrites target file (`changed: true` if differs); return: `dest: /path/to/link` (but affects linked file).

- **force**: Determines overwrite behavior. Type: boolean. Default: true. Possible values: true (replace if contents differ), false (copy only if dest absent). Required: No.

  Best practice: Set false for append-only scenarios. Tip: Influences `remote_src`; trick: Use with `checksum` for precise control.

  Example from resource: Force yes.
  ```yaml
  - name: Force copy
    ansible.builtin.copy:
      src: myfile
      dest: /home/TestDir2
      force: yes
  ```
  Expected output: Overwrites if differs (`changed: true`); no copy if identical (`changed: false`).

- **group**: Group ownership of dest. Type: string. Default: None (current user's group or preserves if root). Possible values: Any group name. Required: No.

  Best practice: Set for shared access (e.g., 'users'). Tip: Use with `owner`; trick: Verify with `stat`.

  Example from resource: Group root.
  ```yaml
  - name: Set group
    ansible.builtin.copy:
      src: myfile
      dest: /home/TestDir2
      group: root
  ```
  Expected output: Sets group to root (`changed: true` if changed); return: `group: root`, `gid: 0`.

- **local_follow**: Follows symlinks in src tree. Type: boolean. Default: true. Possible values: true (follow source links), false (copy links as-is). Required: No.

  Best practice: Set false to preserve symlinks. Tip: Useful for recursive copies; trick: Test locally with `cp -rL` vs `cp -r`.

  Example: No follow local.
  ```yaml
  - name: Preserve local links
    ansible.builtin.copy:
      src: /local/symlink_dir/
      dest: /remote/dir
      local_follow: false
  ```
  Expected output: Copies symlinks as links (`changed: true`); return: `state: link` for symlinks.

- **mode**: Permissions of dest. Type: any. Default: None (umask for new, existing unchanged). Possible values: Octal (e.g., 0644, quoted '0644' or 0o644), symbolic (e.g., 'u+rwx,g=r,o=r'), 'preserve' (match src). Required: No. Notes: Explicit setting recommended for security (CVE-2020-1736).

  Best practice: Always specify for predictability (e.g., 0600 for secrets). Tip: Use symbolic for readability; trick: 'preserve' for mirroring src perms.

  Example from resource: Mode 0644.
  ```yaml
  - name: Set mode
    ansible.builtin.copy:
      src: myfile
      dest: /home/TestDir2
      mode: 0644
  ```
  Expected output: Sets permissions to 0644 (`changed: true` if altered); return: `mode: 0644`.

- **owner**: User ownership of dest. Type: string. Default: None (current user or preserves if root). Possible values: Any user name (numeric as UID, but avoid). Required: No.

  Best practice: Set for service accounts (e.g., 'www-data'). Tip: Numeric UIDs possible but use names; trick: Combine with `become` for root changes.

  Example from resource: Owner root.
  ```yaml
  - name: Set owner
    ansible.builtin.copy:
      src: myfile
      dest: /home/TestDir2
      owner: root
  ```
  Expected output: Sets owner to root (`changed: true`); return: `owner: root`, `uid: 0`.

- **remote_src**: Indicates if src is on remote host. Type: boolean. Default: false (local src). Possible values: true (remote src), false. Required: No. Notes: Supports recursive since 2.8; `mode=preserve` only; no decryption.

  Best practice: Use true for remote-to-remote copies. Tip: Avoid for vault files; trick: Use with `fetch` for pull-push workflows.

  Example: Remote src.
  ```yaml
  - name: Copy remote file
    ansible.builtin.copy:
      src: /etc/sudoers
      dest: /etc/sudoers.edit
      remote_src: yes
      validate: /usr/sbin/visudo -csf %s
  ```
  Expected output: Copies from remote src to dest (`changed: true` if differs); validates with visudo; return: `src: /etc/sudoers` (remote).

- **selevel**: SELinux MLS/MCS level. Type: string. Default: None. Possible values: Any level (e.g., 's0'), '_default' (policy default). Required: No.

  Best practice: Set in SELinux environments for policy compliance. Tip: Use with other se* params; trick: Check with `semanage fcontext`.

  Example: Set SELinux level.
  ```yaml
  - name: Copy with SELinux
    ansible.builtin.copy:
      src: /local/config
      dest: /etc/config
      selevel: s0
  ```
  Expected output: Applies SELinux context (`changed: true`); return: no specific SELinux fields, but `state: file`.

- **serole**: SELinux role. Type: string. Default: None. Possible values: Any role (e.g., 'system_r'), '_default'. Required: No.

  Similar to selevel; best practice: Align with system policies.

- **setype**: SELinux type. Type: string. Default: None. Possible values: Any type (e.g., 'httpd_sys_content_t'), '_default'. Required: No.

- **seuser**: SELinux user. Type: string. Default: None. Possible values: Any user (e.g., 'system_u'), '_default'. Required: No.

- **src**: Source path for copy. Type: path. Default: None. Possible values: Any local/remote path or directory (ends with '/' for dirs). Required: No (if content used). Notes: Mutually exclusive with content; remote_src affects interpretation.

  Best practice: Use absolute paths; tip: For dirs, end with '/'; trick: Use wildcards with caution.

  Example from resource: Src myfile.
  Expected output: Copies myfile to dest.

- **unsafe_writes**: Allows unsafe writes to block devices/pipes. Type: boolean. Default: false. Possible values: true (enable), false. Required: No. Notes: Subject to race conditions; use cautiously.

  Best practice: Avoid unless necessary (e.g., pipes). Tip: Test in check mode; trick: Use for special devices.

  Example: Unsafe write.
  ```yaml
  - name: Copy to pipe
    ansible.builtin.copy:
      src: /local/data
      dest: /dev/fd/0
      unsafe_writes: true
  ```
  Expected output: Writes to pipe (`changed: true`); potential risks if raced.

- **validate**: Command to validate file before final copy. Type: string. Default: None. Possible values: Any command with '%s' for temp file (e.g., 'visudo -csf %s'). Required: No. Notes: Securely passed, no shell features.

  Best practice: Use for configs (e.g., syntax checks). Tip: %s required; trick: Chain with `failed_when` for custom handling.

  Example: Validate sudoers.
  ```yaml
  - name: Validate copy
    ansible.builtin.copy:
      src: /mine/sudoers
      dest: /etc/sudoers
      validate: /usr/sbin/visudo -csf %s
  ```
  Expected output: Validates temp file; copies if ok (`changed: true`); fails if invalid.

## Additional Examples for the Ansible Copy Module

#### Example 1: Using `content` with Multi-line Configuration
```yaml
- name: Create configuration file with multi-line content
  ansible.builtin.copy:
    content: |
      [database]
      host = localhost
      port = 3306
      name = myapp
      
      [cache]
      provider = redis
      host = 127.0.0.1
      port = 6379
    dest: /etc/myapp/config.ini
    mode: 0640
    owner: myapp
    group: myapp
```
**Explanation**: This creates a configuration file with multi-line content directly in the playbook. The `content` parameter allows specifying the file contents inline, which is useful for small configuration files. The file is created with specific permissions and ownership. Output shows `changed: true` on first run, `false` on subsequent runs, with return values including `dest`, `mode`, `owner`, and `group`.

#### Example 2: Recursive Directory Copy with Preserved Permissions
```yaml
- name: Copy website directory with preserved permissions
  ansible.builtin.copy:
    src: /local/website/
    dest: /var/www/html/
    mode: preserve
    directory_mode: 0755
    owner: www-data
    group: www-data
    remote_src: no
```
**Explanation**: This copies an entire website directory recursively while preserving the original file permissions (`mode: preserve`). The `directory_mode` sets permissions for newly created directories to 0755. The ownership is set to the web server user. Output shows `changed: true` for each file/directory that was copied or modified, with return values including the count of files processed.

#### Example 3: Using `validate` with Configuration Files
```yaml
- name: Copy Nginx configuration with validation
  ansible.builtin.copy:
    src: /local/nginx.conf
    dest: /etc/nginx/nginx.conf
    validate: /usr/sbin/nginx -t -c %s
    backup: yes
  register: nginx_config
```
**Explanation**: This copies an Nginx configuration file and validates it using the `nginx -t` command before finalizing the copy. The `backup` parameter ensures the original configuration is saved if changes are made. If validation fails, the task will fail and the original file remains unchanged. Output shows `changed: true` if the file was updated and valid, with `backup_file` path if a backup was created.

#### Example 4: Using `remote_src` for Remote-to-Remote Copy
```yaml
- name: Copy configuration template to production location
  ansible.builtin.copy:
    src: /etc/myapp/template.conf
    dest: /etc/myapp/production.conf
    remote_src: yes
    force: no
```
**Explanation**: This copies a file from one location to another on the same remote host using `remote_src: yes`. The `force: no` parameter ensures the copy only happens if the destination doesn't exist. This is useful for deploying configuration files from a template location to the active location. Output shows `changed: true` only if the destination file was created.

#### Example 5: Using `attributes` for File Security
```yaml
- name: Copy sensitive file with immutable attribute
  ansible.builtin.copy:
    src: /local/sensitive_data
    dest: /etc/sensitive/sensitive_data
    mode: 0600
    attributes: +i
  register: immutable_file
```
**Explanation**: This copies a sensitive file and sets the immutable attribute (`+i`) to prevent accidental changes or deletion. The file is also given restrictive permissions (0600). This is useful for protecting critical files. Output shows `changed: true` if the file was copied or attributes were set, with return values including the file's attributes.

#### Example 6: Using `checksum` for File Integrity Verification
```yaml
- name: Copy binary with checksum verification
  ansible.builtin.copy:
    src: /local/app.bin
    dest: /usr/local/bin/app.bin
    checksum: "d41d8cd98f00b204e9800998ecf8427e"
    mode: 0755
```
**Explanation**: This copies a binary file and verifies its integrity using the specified SHA1 checksum. The file is made executable with mode 0755. If the checksum doesn't match after copying, the task will fail. This ensures the file wasn't corrupted during transfer. Output shows `changed: true` if the file was copied and verified, with return values including the checksum.

#### Example 7: Using `backup` and `force` Together
```yaml
- name: Update configuration with backup and forced overwrite
  ansible.builtin.copy:
    src: /local/new_config.conf
    dest: /etc/app/config.conf
    backup: yes
    force: yes
    owner: appuser
    group: appgroup
  register: config_update
```
**Explanation**: This updates a configuration file, forcing an overwrite even if the destination exists (`force: yes`). A backup of the original file is created before overwriting (`backup: yes`). The ownership is set to the application user. This is useful for critical configuration updates where you need to ensure the change is applied but want to preserve the original for rollback. Output shows `changed: true` if the file was updated, with `backup_file` path in the return values.

#### Example 8: Using `local_follow` to Preserve Symlinks
```yaml
- name: Copy directory while preserving symlinks
  ansible.builtin.copy:
    src: /local/app/
    dest: /opt/app/
    local_follow: no
    directory_mode: 0755
```
**Explanation**: This copies a directory tree while preserving symbolic links as links rather than following them to their targets (`local_follow: no`). This is useful when you want to maintain the exact structure of the source directory, including its symlinks. Output shows `changed: true` for each file or directory copied, with symlinks copied as links rather than the files they point to.

#### Example 9: Using `unsafe_writes` for Special Files
```yaml
- name: Write to a device file
  ansible.builtin.copy:
    src: /local/device_config
    dest: /dev/mapper/mydevice
    unsafe_writes: yes
```
**Explanation**: This writes a configuration to a device file, enabling unsafe writes (`unsafe_writes: yes`) which is necessary for certain special files like block devices or pipes. This parameter should be used with caution as it can lead to data corruption in case of concurrent access. Output shows `changed: true` if the write was successful.

#### Example 10: Using SELinux Context Parameters
```yaml
- name: Copy web content with SELinux context
  ansible.builtin.copy:
    src: /local/web_content/
    dest: /var/www/html/
    setype: httpd_sys_content_t
    seuser: system_u
    serole: object_r
    selevel: s0
    mode: preserve
```
**Explanation**: This copies web content to the web server's document root and sets the SELinux context appropriately for web content. The `setype` is set to `httpd_sys_content_t`, which is the correct type for files served by the web server. The SELinux user, role, and level are also set. This ensures the content is accessible by the web server while maintaining SELinux security policies. Output shows `changed: true` for files that were copied or had their SELinux context modified.

#### Summary Table of Arguments

| Argument Name | Type | Default Value | Possible Values | Required | Notes/Deprecations |
|---------------|------|---------------|-----------------|----------|--------------------|
| attributes | string | None | Valid chattr strings (e.g., '+a', '-i') | No | Aliases: attr |
| backup | boolean | false | true, false | No | - |
| checksum | string | None | SHA1 hash (40 hex chars) | No | - |
| content | string | None | Any string | No | Mutually exclusive with src |
| decrypt | boolean | true | true, false | No | Not with remote_src: yes |
| dest | path | None | Any path | Yes | - |
| directory_mode | any | None | Mode values (octal/symbolic) | No | Only new dirs |
| follow | boolean | false | true, false | No | Dest links |
| force | boolean | true | true, false | No | - |
| group | string | None | Group name | No | - |
| local_follow | boolean | true | true, false | No | Src links |
| mode | any | None | Octal/symbolic/'preserve' | No | Recommend explicit |
| owner | string | None | User name/UID (avoid numeric) | No | - |
| remote_src | boolean | false | true, false | No | Recursive since 2.8 |
| selevel | string | None | SELinux level/'_default' | No | - |
| serole | string | None | SELinux role/'_default' | No | - |
| setype | string | None | SELinux type/'_default' | No | - |
| seuser | string | None | SELinux user/'_default' | No | - |
| src | path | None | Any path/dir | No | Mutually exclusive with content |
| unsafe_writes | boolean | false | true, false | No | Risky; race conditions |
| validate | string | None | Command with %s | No | No shell expansion

# 3.21. Replace Module

2025-08-16 19:54
Status: #DONE 
Tags: [[Ansible]]

---
# Understanding Ansible's Replace Module: A DevOps Essential for Configuration Management

As a DevOps engineer who's spent countless hours automating infrastructure, I've found Ansible's replace module to be a reliable tool for making targeted changes in configuration files. Whether you're tweaking server settings or ensuring consistency across environments, this module handles string replacements with precision using regular expressions. In this article, I'll break it down first in straightforward terms, then dive into the technical depths, complete with examples tailored to common technologies like NGINX, PostgreSQL, MySQL, Redis, and Golang-related configs. I'll also share best practices and tips to help you use it effectively.

## In Simple Terms: The Basics of the Replace Module

Imagine you have a bunch of text files—like configuration settings for your servers or databases—and you need to update specific parts without rewriting everything from scratch. The replace module is like a smart find-and-replace tool in a word processor, but powered by patterns (called regular expressions) that let you match complex text. It scans a file, finds matches to your pattern, swaps them out with new text, and saves the changes. You can even limit changes to certain sections of the file or create backups automatically.

For instance, if your NGINX config has an old port number you want to update everywhere, this module can do it in one go. It's idempotent if used carefully—meaning running it multiple times won't keep changing things unnecessarily—but you have to design your patterns to avoid that. Think of it as a scalpel for file edits in your automation workflows.

## In-Depth Explanation: Parameters, Usage, and Advanced Features

The ansible.builtin.replace module is designed to replace all instances of a specified pattern in a file using back-referenced regular expressions. It operates on the file's contents, allowing for precise modifications while supporting features like backups, ownership changes, and validation. Importantly, it does not inherently ensure idempotence; users must craft patterns that won't match already-replaced text to prevent repeated alterations.

### Key Parameters and Their Functions

The module accepts several parameters to customize its behavior. Here's a detailed breakdown:

- **path** (required, type: path): Specifies the file to modify. This is the target where replacements occur. Aliases include 'dest', 'destfile', or 'name' for backward compatibility.

- **regexp** (required, type: string): The regular expression pattern to search for in the file. It uses Python's re module with MULTILINE mode enabled (so ^ and $ match line starts/ends), but not DOTALL (meaning . does not match newlines unless specified).

- **replace** (type: string, default: ""): The string to insert in place of matches. Supports backreferences like \1 or \g<1> to reuse parts of the matched text. If omitted or empty, matches are simply removed.

- **after** (type: string): Limits replacements to content after this matching pattern. Uses Python regex with DOTALL (so . matches newlines) but not MULTILINE.

- **before** (type: string): Limits replacements to content before this matching pattern. Similar regex behavior as 'after'.

- **backup** (type: boolean, default: false): If true, creates a backup of the original file with a timestamp suffix (e.g., filename.2023-01-01@12:00:00~) for easy rollback.

- **encoding** (type: string, default: "utf-8"): Sets the character encoding for reading/writing the file, useful for non-ASCII configs.

- **owner**, **group**, **mode** (types: string/string/any): Control ownership and permissions of the modified file. 'mode' can be octal (e.g., 0644) or symbolic (e.g., u+rwx).

- **attributes** (type: string): Manages extended attributes on the filesystem object, viewable with lsattr.

- **seuser**, **serole**, **setype**, **selevel** (types: string): Handle SELinux contexts for the file.

- **unsafe_writes** (type: boolean, default: false): Enables non-atomic writes as a fallback (e.g., in containerized environments), but risks data corruption—use sparingly.

- **validate** (type: string): Runs a command (with %s as placeholder for the temp file) to validate changes before applying, e.g., for syntax checks.

Notes from the documentation highlight version-specific behaviors: Combined 'before' and 'after' work correctly since Ansible 2.7.10, and the 'follow' option was removed in 2.5 as it's irrelevant here.

### Return Values

Upon execution, the module returns:
- **backup_file** (string): Path to the backup if created.
- **changed** (boolean): Indicates if modifications were made.

### Requirements and Compatibility

This module is bundled in ansible-core, requiring no additional installations. It works across Ansible versions, with aliases for older parameter names.

## Practical Examples with Detailed Explanations

Let's explore real-world applications, adapting to technologies like NGINX for web serving, PostgreSQL and MySQL for databases, Redis for caching, and Golang for application configs. Each example includes a complete Ansible task, step-by-step reasoning, and the command to run it.

### Example 1: Updating Listen Port in NGINX Configuration

Suppose you need to change the default listen port from 80 to 8080 in /etc/nginx/nginx.conf, but only in the server block, and create a backup.

```yaml
- name: Update NGINX listen port
  ansible.builtin.replace:
    path: /etc/nginx/nginx.conf
    regexp: 'listen\s+80\s+default_server;'
    replace: 'listen 8080 default_server;'
    after: 'server {'
    before: '}'
    backup: yes
```

**Detailed Explanation**: 
- The 'regexp' matches "listen 80 default_server;" accounting for whitespace.
- 'replace' inserts the new port.
- 'after' and 'before' restrict changes to within the server block (assuming it starts with 'server {' and ends with '}').
- 'backup: yes' ensures a timestamped copy for recovery.
- To run: Save in a playbook (e.g., update_nginx.yml) and execute with:
```bash
ansible-playbook update_nginx.yml
```
This is idempotent if the regexp doesn't match the new text. Tip: Test regex with tools like regex101.com before applying.

### Example 2: Modifying PostgreSQL Connection Limits

In postgresql.conf, increase max_connections from 100 to 200, removing any comments around it.

```yaml
- name: Increase PostgreSQL max connections
  ansible.builtin.replace:
    path: /etc/postgresql/14/main/postgresql.conf
    regexp: '^#?\s*max_connections\s*=\s*100'
    replace: 'max_connections = 200'
    backup: yes
    validate: '/usr/lib/postgresql/14/bin/pg_ctl check -D %s'
```

**Detailed Explanation**:
- 'regexp' matches lines like "# max_connections = 100" or "max_connections = 100", using ^ for line start and ? for optional comment.
- 'replace' sets the new value without comment.
- 'validate' uses pg_ctl to check config syntax on the temp file.
- Backup is enabled for safety.
- Run via playbook as above. Best practice: Combine with a service restart task to apply changes.

### Example 3: Securing MySQL Bind Address

Change bind-address from 0.0.0.0 to 127.0.0.1 in my.cnf for local-only access.

```yaml
- name: Secure MySQL bind address
  ansible.builtin.replace:
    path: /etc/mysql/my.cnf
    regexp: 'bind-address\s*=\s*0\.0\.0\.0'
    replace: 'bind-address = 127.0.0.1'
    after: '[mysqld]'
    backup: yes
```

**Detailed Explanation**:
- 'regexp' targets the exact bind-address line.
- 'after' limits to the [mysqld] section.
- No 'before' needed if the section is self-contained.
- Backup protects against errors. Tip: Use 'mode: 0600' to set secure permissions post-replacement.

### Example 4: Adjusting Redis Max Memory

In redis.conf, update maxmemory from 2gb to 4gb, using backreferences for units.

```yaml
- name: Update Redis maxmemory
  ansible.builtin.replace:
    path: /etc/redis/redis.conf
    regexp: 'maxmemory\s+(\d+)gb'
    replace: 'maxmemory 4gb'
    backup: yes
```

**Detailed Explanation**:
- 'regexp' captures the number with (\d+), but here we ignore it and hardcode 4gb—adjust if needing dynamic.
- For backreferences: Change to 'replace: 'maxmemory \g<1>mb'' to convert units.
- No section limits, as it's global. Run and restart Redis. Trick: Chain with 'notify' handler for service reload.

### Example 5: Tweaking Golang App Config (e.g., Environment Variables in a .env File)

For a Golang service config.env, replace database URL from dev to prod.

```yaml
- name: Update Golang app DB URL
  ansible.builtin.replace:
    path: /app/config.env
    regexp: '^DB_URL=postgres://user:pass@dev-host:5432/db'
    replace: 'DB_URL=postgres://user:pass@prod-host:5432/db'
    owner: golanguser
    group: golanggroup
    mode: '0640'
    backup: yes
```

**Detailed Explanation**:
- 'regexp' matches the full line starting with DB_URL.
- 'replace' updates to production.
- Ownership and mode ensure security for the app user.
- Backup for rollback. Tip: Use 'validate' with a custom script if the file needs parsing checks.

## Additional Examples for Ansible's Replace Module

### Example 6: Updating Apache HTTP Server DocumentRoot
Change the DocumentRoot in Apache's configuration from /var/www/html to /var/www/newsite.
```yaml
- name: Update Apache DocumentRoot
  ansible.builtin.replace:
    path: /etc/apache2/sites-available/000-default.conf
    regexp: 'DocumentRoot\s+/var/www/html'
    replace: 'DocumentRoot /var/www/newsite'
    backup: yes
    validate: '/usr/sbin/apache2ctl -t -f %s'
```
**Detailed Explanation**:
- The 'regexp' matches the DocumentRoot directive with the original path, accounting for whitespace.
- 'replace' updates the path to the new directory.
- 'backup: yes' creates a timestamped backup of the original configuration.
- 'validate' uses apache2ctl to check the configuration syntax before applying changes.
- After running this task, you should restart Apache with a handler to apply changes.

### Example 7: Modifying PHP Memory Limit
Increase PHP's memory_limit from 128M to 256M in php.ini.
```yaml
- name: Increase PHP memory limit
  ansible.builtin.replace:
    path: /etc/php/7.4/apache2/php.ini
    regexp: '^memory_limit\s*=\s*128M'
    replace: 'memory_limit = 256M'
    backup: yes
```
**Detailed Explanation**:
- The 'regexp' targets the memory_limit line, using ^ to match the beginning of the line.
- The pattern accounts for optional whitespace around the equals sign.
- 'replace' sets the new memory limit to 256M.
- A backup is created for safety.
- After modification, the web server needs to be restarted to apply the new PHP settings.

### Example 8: Configuring Docker Daemon Storage Driver
Change Docker's storage driver from overlay2 to devicemapper in daemon.json.
```yaml
- name: Change Docker storage driver
  ansible.builtin.replace:
    path: /etc/docker/daemon.json
    regexp: '"storage-driver":\s*"overlay2"'
    replace: '"storage-driver": "devicemapper"'
    backup: yes
    validate: 'docker --config-file %s config 2>&1 || exit 1'
```
**Detailed Explanation**:
- The 'regexp' matches the storage-driver configuration line, accounting for whitespace.
- 'replace' updates the storage driver to devicemapper.
- 'backup: yes' ensures a backup is created.
- 'validate' checks if the JSON configuration is valid using Docker's config command.
- After this change, the Docker daemon needs to be restarted for the new setting to take effect.

### Example 9: Securing SSH Server Configuration
Disable root login and change SSH port in sshd_config.
```yaml
- name: Secure SSH configuration
  ansible.builtin.replace:
    path: /etc/ssh/sshd_config
    regexp: '{{ item.regexp }}'
    replace: '{{ item.replace }}'
  with_items:
    - { regexp: '^#?PermitRootLogin\s+yes', replace: 'PermitRootLogin no' }
    - { regexp: '^#?Port\s+22', replace: 'Port 2222' }
  backup: yes
  validate: '/usr/sbin/sshd -t -f %s'
```
**Detailed Explanation**:
- This task uses a loop to make two separate replacements in the SSH configuration.
- The first item disables root login by changing PermitRootLogin to 'no'.
- The second item changes the SSH port from 22 to 2222.
- Both regexps account for commented lines using #?.
- 'backup: yes' creates a backup of the original configuration.
- 'validate' uses sshd -t to check the configuration syntax.
- After these changes, the SSH service must be restarted.

### Example 10: Updating Systemd Service File Timeout
Increase the timeout for a systemd service from 30 seconds to 120 seconds.
```yaml
- name: Update systemd service timeout
  ansible.builtin.replace:
    path: /etc/systemd/system/myservice.service
    regexp: '^TimeoutStartSec=\d+'
    replace: 'TimeoutStartSec=120'
    backup: yes
  notify: reload systemd
```
**Detailed Explanation**:
- The 'regexp' matches the TimeoutStartSec line with any numeric value.
- 'replace' sets the timeout to 120 seconds.
- 'backup: yes' creates a backup of the service file.
- The 'notify' triggers a handler to reload systemd configuration after changes.
- After modifying a systemd service file, you need to run 'systemctl daemon-reload' to apply changes.

### Example 11: Modifying Log Rotation Configuration
Change the rotation schedule for a specific log file in logrotate.conf.
```yaml
- name: Update log rotation schedule
  ansible.builtin.replace:
    path: /etc/logrotate.d/nginx
    regexp: '^(\s*)daily'
    replace: '\1weekly'
    backup: yes
    validate: '/usr/sbin/logrotate -d %s'
```
**Detailed Explanation**:
- The 'regexp' matches lines starting with 'daily', with optional leading whitespace captured in group 1.
- 'replace' uses backreference \1 to preserve the original indentation and changes 'daily' to 'weekly'.
- 'backup: yes' creates a backup of the logrotate configuration.
- 'validate' uses logrotate -d to perform a dry run and check for configuration errors.
- This change will take effect on the next logrotate run.

### Example 12: Updating Environment Variables in a Shell Script
Change the JAVA_HOME path in a shell script.
```yaml
- name: Update JAVA_HOME in shell script
  ansible.builtin.replace:
    path: /opt/app/start.sh
    regexp: 'export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64'
    replace: 'export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64'
    backup: yes
```
**Detailed Explanation**:
- The 'regexp' matches the exact line setting JAVA_HOME to Java 8.
- 'replace' updates the path to Java 11.
- 'backup: yes' creates a backup of the shell script.
- This change will take effect the next time the script is executed.
- Consider using a handler to restart the application if it depends on this script.

### Example 13: Modifying Tomcat JVM Heap Size
Increase the maximum heap size for Tomcat from 2GB to 4GB.
```yaml
- name: Increase Tomcat max heap size
  ansible.builtin.replace:
    path: /etc/default/tomcat9
    regexp: '^JAVA_OPTS="-Xmx\d+[gm] '
    replace: 'JAVA_OPTS="-Xmx4g '
    backup: yes
```
**Detailed Explanation**:
- The 'regexp' matches the JAVA_OPTS line with an Xmx setting of any size (in GB or MB).
- 'replace' sets the maximum heap size to 4GB.
- 'backup: yes' creates a backup of the configuration file.
- After this change, Tomcat needs to be restarted for the new JVM settings to take effect.
- Note that this simple replacement assumes a specific format for JAVA_OPTS; more complex scenarios might require additional patterns.

### Example 14: Updating DNS Zone Record
Change the IP address for a host in a DNS zone file.
```yaml
- name: Update DNS record IP
  ansible.builtin.replace:
    path: /var/named/example.com.zone
    regexp: '^www\s+IN\s+A\s+192\.168\.1\.10'
    replace: 'www IN A 192.168.1.20'
    backup: yes
    validate: '/usr/sbin/named-checkzone example.com %s'
```
**Detailed Explanation**:
- The 'regexp' matches the www host record with the old IP address.
- 'replace' updates the IP address to the new value.
- 'backup: yes' creates a backup of the zone file.
- 'validate' uses named-checkzone to verify the zone file syntax.
- After this change, you need to reload the DNS server or increment the serial number in the SOA record.

### Example 15: Modifying Firewall Rules
Change a port in an iptables rule.
```yaml
- name: Update firewall rule port
  ansible.builtin.replace:
    path: /etc/iptables/rules.v4
    regexp: '--dport 8080'
    replace: '--dport 8443'
    backup: yes
    validate: '/sbin/iptables-restore --test %s'
```
**Detailed Explanation**:
- The 'regexp' matches the destination port 8080 in any rule.
- 'replace' updates the port to 8443.
- 'backup: yes' creates a backup of the firewall rules.
- 'validate' uses iptables-restore --test to check the rules syntax.
- After this change, the firewall rules need to be reloaded for the update to take effect.

### Example 16: Updating Network Interface Configuration
Change the static IP address for a network interface.
```yaml
- name: Update network interface IP
  ansible.builtin.replace:
    path: /etc/network/interfaces
    regexp: 'address\s+192\.168\.1\.100'
    replace: 'address 192.168.1.101'
    backup: yes
```
**Detailed Explanation**:
- The 'regexp' matches the address line with the old IP.
- 'replace' updates the IP address to the new value.
- 'backup: yes' creates a backup of the network configuration.
- After this change, the network interface needs to be restarted for the new IP to take effect.
- Consider using a handler to restart networking or the specific interface.

### Example 17: Modifying Cron Job Schedule
Change the execution time of a cron job.
```yaml
- name: Update cron job schedule
  ansible.builtin.replace:
    path: /etc/cron.d/myscript
    regexp: '^0 2 \* \* \* root /opt/scripts/myscript.sh'
    replace: '0 3 * * * root /opt/scripts/myscript.sh'
    backup: yes
```
**Detailed Explanation**:
- The 'regexp' matches the exact cron job line that runs at 2 AM.
- 'replace' changes the execution time to 3 AM.
- 'backup: yes' creates a backup of the cron file.
- Cron automatically detects changes to its configuration files, so no restart is needed.
- The change will take effect at the next cron refresh (usually within a minute).

### Example 18: Updating System Limits Configuration
Increase the file descriptor limit for a specific user.
```yaml
- name: Update system file descriptor limit
  ansible.builtin.replace:
    path: /etc/security/limits.conf
    regexp: '^myuser\s+soft\s+nofile\s+\d+'
    replace: 'myuser soft nofile 65536'
    backup: yes
```
**Detailed Explanation**:
- The 'regexp' matches the soft nofile limit for myuser, regardless of the current value.
- 'replace' sets the new limit to 65536.
- 'backup: yes' creates a backup of the limits configuration.
- This change takes effect when the user logs in again or when processes are restarted.
- For system services, a restart of the service is required.

### Example 19: Modifying PAM Configuration
Add a new PAM module to the SSH authentication stack.
```yaml
- name: Add PAM module for SSH
  ansible.builtin.replace:
    path: /etc/pam.d/sshd
    regexp: '^(auth\s+required\s+pam_unix.so)'
    replace: 'auth required pam_google_authenticator.so\n\1'
    backup: yes
```
**Detailed Explanation**:
- The 'regexp' captures the line with pam_unix.so for authentication.
- 'replace' adds a new line with pam_google_authenticator.so before the captured line.
- 'backup: yes' creates a backup of the PAM configuration.
- This change takes effect immediately for new SSH connections.
- Be careful with PAM configuration as errors can lock you out of the system.

### Example 20: Updating Nginx SSL Certificate Path
Change the SSL certificate path in an Nginx server block.
```yaml
- name: Update Nginx SSL certificate path
  ansible.builtin.replace:
    path: /etc/nginx/sites-available/example.com
    regexp: 'ssl_certificate\s+/etc/ssl/certs/example.com.crt;'
    replace: 'ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;'
    after: 'server {'
    before: '}'
    backup: yes
    validate: '/usr/sbin/nginx -t -c %s'
```
**Detailed Explanation**:
- The 'regexp' matches the ssl_certificate directive with the old path.
- 'replace' updates the path to the new Let's Encrypt certificate.
- 'after' and 'before' limit the replacement to within a server block.
- 'backup: yes' creates a backup of the Nginx configuration.
- 'validate' uses nginx -t to check the configuration syntax.
- After this change, Nginx needs to be reloaded to apply the new certificate.

### Example 21: Modifying MongoDB Configuration
Change MongoDB's bind IP address and port.
```yaml
- name: Update MongoDB bind address and port
  ansible.builtin.replace:
    path: /etc/mongod.conf
    regexp: '{{ item.regexp }}'
    replace: '{{ item.replace }}'
  with_items:
    - { regexp: '^\s*bindIp:\s+127\.0\.0\.1', replace: '  bindIp: 0.0.0.0' }
    - { regexp: '^\s*port:\s+27017', replace: '  port: 27018' }
  backup: yes
```
**Detailed Explanation**:
- This task uses a loop to make two separate replacements in the MongoDB configuration.
- The first item changes the bind IP from localhost to all interfaces.
- The second item changes the port from 27017 to 27018.
- The regexps account for YAML indentation using \s*.
- 'backup: yes' creates a backup of the configuration file.
- After these changes, MongoDB needs to be restarted for the new settings to take effect.

### Example 22: Updating RabbitMQ Configuration
Change RabbitMQ's default user and password in rabbitmq.conf.
```yaml
- name: Update RabbitMQ default user credentials
  ansible.builtin.replace:
    path: /etc/rabbitmq/rabbitmq.conf
    regexp: '{{ item.regexp }}'
    replace: '{{ item.replace }}'
  with_items:
    - { regexp: '^default_user\s*=\s*guest', replace: 'default_user = admin' }
    - { regexp: '^default_pass\s*=\s*guest', replace: 'default_pass = securepassword' }
  backup: yes
```
**Detailed Explanation**:
- This task uses a loop to update both the default username and password.
- The regexps match the default_user and default_pass lines, accounting for whitespace.
- 'replace' sets the new username to 'admin' and password to 'securepassword'.
- 'backup: yes' creates a backup of the configuration file.
- After these changes, RabbitMQ needs to be restarted for the new settings to take effect.
- Note: Storing passwords in plain text is not recommended for production environments.

### Example 23: Modifying Elasticsearch Configuration
Change Elasticsearch's cluster name and node settings.
```yaml
- name: Update Elasticsearch cluster configuration
  ansible.builtin.replace:
    path: /etc/elasticsearch/elasticsearch.yml
    regexp: '{{ item.regexp }}'
    replace: '{{ item.replace }}'
  with_items:
    - { regexp: '^#cluster\.name:\s+my-application', replace: 'cluster.name: production-cluster' }
    - { regexp: '^#node\.name:\s+node-1', replace: 'node.name: data-node-1' }
  backup: yes
```
**Detailed Explanation**:
- This task uses a loop to update both the cluster name and node name.
- The regexps match the commented-out default settings.
- 'replace' sets the new cluster name to 'production-cluster' and node name to 'data-node-1'.
- 'backup: yes' creates a backup of the configuration file.
- After these changes, Elasticsearch needs to be restarted for the new settings to take effect.
- Note that changing the cluster name of a running node will cause it to form a new cluster.

### Example 24: Updating Kubernetes Manifest
Change the replica count in a Kubernetes deployment manifest.
```yaml
- name: Update Kubernetes deployment replica count
  ansible.builtin.replace:
    path: /opt/kubernetes/deployments/myapp-deployment.yaml
    regexp: 'replicas:\s+\d+'
    replace: 'replicas: 5'
    backup: yes
```
**Detailed Explanation**:
- The 'regexp' matches the replicas line with any numeric value.
- 'replace' sets the replica count to 5.
- 'backup: yes' creates a backup of the deployment manifest.
- After this change, you need to apply the manifest to the cluster using kubectl.
- Consider using a handler to automatically apply the manifest after changes.

### Example 25: Modifying HAProxy Configuration
Change the backend server port in an HAProxy configuration.
```yaml
- name: Update HAProxy backend server port
  ansible.builtin.replace:
    path: /etc/haproxy/haproxy.cfg
    regexp: '^(\s*)server app1\s+192\.168\.1\.10:8080'
    replace: '\1server app1 192.168.1.10:8081'
    backup: yes
    validate: '/usr/sbin/haproxy -c -f %s'
```
**Detailed Explanation**:
- The 'regexp' matches the server line for app1 with the old port, capturing the indentation in group 1.
- 'replace' uses backreference \1 to preserve the original indentation and updates the port to 8081.
- 'backup: yes' creates a backup of the HAProxy configuration.
- 'validate' uses haproxy -c to check the configuration syntax.
- After this change, HAProxy needs to be reloaded for the new configuration to take effect.

### Example 26: Updating Systemd Environment File
Change the Java options in a systemd environment file.
```yaml
- name: Update Java options in systemd environment file
  ansible.builtin.replace:
    path: /etc/systemd/system/myservice.d/environment.conf
    regexp: '^JAVA_OPTS="-Xmx1g'
    replace: 'JAVA_OPTS="-Xmx2g'
    backup: yes
```
**Detailed Explanation**:
- The 'regexp' matches the JAVA_OPTS line with the old heap size.
- 'replace' updates the maximum heap size from 1g to 2g.
- 'backup: yes' creates a backup of the environment file.
- After this change, you need to reload the systemd daemon and restart the service.
- Consider using a handler to automatically restart the service after changes.

### Example 27: Modifying Samba Configuration
Change the workgroup name in smb.conf.
```yaml
- name: Update Samba workgroup name
  ansible.builtin.replace:
    path: /etc/samba/smb.conf
    regexp: '^workgroup\s*=\s*MYGROUP'
    replace: 'workgroup = EXAMPLE'
    backup: yes
    validate: '/usr/bin/testparm -s %s'
```
**Detailed Explanation**:
- The 'regexp' matches the workgroup line with the old name, accounting for whitespace.
- 'replace' sets the new workgroup name to 'EXAMPLE'.
- 'backup: yes' creates a backup of the Samba configuration.
- 'validate' uses testparm to check the configuration syntax.
- After this change, Samba needs to be restarted for the new setting to take effect.

### Example 28: Updating FTP Server Configuration
Change the passive port range in vsftpd.conf.
```yaml
- name: Update FTP passive port range
  ansible.builtin.replace:
    path: /etc/vsftpd.conf
    regexp: '^pasv_min_port=\d+'
    replace: 'pasv_min_port=50000'
    backup: yes
```
**Detailed Explanation**:
- The 'regexp' matches the pasv_min_port line with any numeric value.
- 'replace' sets the minimum passive port to 50000.
- 'backup: yes' creates a backup of the FTP configuration.
- After this change, the FTP server needs to be restarted for the new setting to take effect.
- You would typically also update pasv_max_port to define a range.

### Example 29: Modifying Syslog Configuration
Change the syslog server address in rsyslog.conf.
```yaml
- name: Update syslog server address
  ansible.builtin.replace:
    path: /etc/rsyslog.conf
    regexp: '^\*.\*\s+@@syslog-old:514'
    replace: '*.* @@syslog-new:514'
    backup: yes
    validate: '/usr/sbin/rsyslogd -N1 -f %s'
```
**Detailed Explanation**:
- The 'regexp' matches the line forwarding logs to the old syslog server.
- 'replace' updates the server address to 'syslog-new'.
- 'backup: yes' creates a backup of the syslog configuration.
- 'validate' uses rsyslogd -N1 to check the configuration syntax.
- After this change, rsyslog needs to be restarted for the new setting to take effect.

### Example 30: Updating GitLab Configuration
Change the external URL in gitlab.rb.
```yaml
- name: Update GitLab external URL
  ansible.builtin.replace:
    path: /etc/gitlab/gitlab.rb
    regexp: '^external_url\s+[\'"]http://gitlab.example.com[\'"]'
    replace: "external_url 'https://gitlab.example.com'"
    backup: yes
```
**Detailed Explanation**:
- The 'regexp' matches the external_url line with the old HTTP URL, accounting for single or double quotes.
- 'replace' updates the URL to use HTTPS.
- 'backup: yes' creates a backup of the GitLab configuration.
- After this change, you need to reconfigure GitLab using gitlab-ctl reconfigure.
- Consider using a handler to automatically reconfigure GitLab after changes.

## Best Practices, Tips, and Tricks

- **Idempotence First**: Design regexps that only match the original text, e.g., include specific old values.
- **Testing**: Use --check mode in Ansible playbooks to simulate changes without applying.
- **Sectioning**: Combine 'after' and 'before' for multi-section files, but test thoroughly as pre-2.7.10 versions had bugs.
- **Backups Always**: Enable 'backup: yes' in production to avoid disasters—timestamps help track changes.
- **Validation for Safety**: For configs like NGINX or PostgreSQL, use 'validate' with tools like nginx -t or pg_ctl check.
- **Regex Tips**: Escape special chars (e.g., \. for dots), use MULTILINE-aware patterns, and avoid greedy matches that span unintended areas.
- **Error Handling**: Monitor 'changed' return to trigger notifications or rollbacks.
- **Alternatives**: For simpler string replaces, consider 'lineinfile'; for wholesale file management, use 'template'.
- **Performance**: In large files, narrow scope with 'after'/'before' to reduce processing time.
- **Security**: When handling sensitive data (e.g., MySQL creds), pair with 'no_log: true' in tasks.

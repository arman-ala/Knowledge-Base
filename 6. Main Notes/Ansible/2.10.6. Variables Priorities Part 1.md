# 2.10.6. Variables Priorities

2025-08-11 04:22
Status: #DONE 
Tags: [[Ansible]]

---
# Understanding Variable Precedence in Ansible: A Comprehensive Guide for DevOps Practitioners

Variables in Ansible are the cornerstone of creating flexible, reusable, and maintainable automation workflows. They allow you to store and reference data dynamically, making your playbooks adaptable to various environments and use cases. For DevOps engineers, mastering variable precedence—understanding which variable definition takes priority over others—is critical for predictable and robust automation. In this article, we’ll explore Ansible’s variable precedence through a beginner-friendly explanation and a detailed technical analysis, incorporating a new playbook that demonstrates all common variable definition methods, including inventory variables and role defaults. We’ll also provide practical examples, explain the provided outputs, and offer best practices to help you navigate variable precedence like a seasoned pro.

## Simplified Explanation: Variables and Their Pecking Order

Imagine you’re organizing a party, and you’re deciding on the menu. You have a default plan (e.g., pizza), but your friend suggests tacos, your roommate insists on sushi, and your boss, who’s crashing the party, demands a gourmet steak dinner. Who wins? In Ansible, variables work similarly—different sources (like playbooks, roles, or the command line) compete to set a value, and there’s a clear “pecking order” determining which one takes precedence. For example, you might define a server port as `8080` in a default setting, but a command-line override can change it to `9090` for a specific run. Understanding this order ensures your automation does exactly what you expect, without surprises. By keeping variable names clear and organized, you make it easy to see who’s “calling the shots” in your playbook.

## In-Depth Analysis: Variable Precedence in Ansible

Ansible’s variable precedence hierarchy determines which variable definition is used when the same variable is defined in multiple locations. The hierarchy, from highest to lowest precedence, includes command-line extra variables, task-level variables (e.g., `set_fact`), role variables, external variable files (`vars_files`), playbook variables, inventory variables, and role defaults. Below, we analyze each method, provide a new playbook incorporating inventory variables and role defaults, and explain the provided outputs to illustrate how precedence works in practice.

### New Playbook Structure

To demonstrate variable precedence comprehensively, we’ve created a new playbook structure that includes all relevant variable definition methods. The structure is as follows:

```
.
├── inventory
│   └── hosts.yml
├── project.yml
├── vars
│   ├── vars1.yml
│   └── vars2.yml
└── roles
    └── myrole
        ├── defaults
        │   └── main.yml
        ├── tasks
        │   └── main.yml
        └── vars
            └── main.yml
```

### File Contents with Descriptive Values

**inventory/hosts.yml:**
```yaml
all:
  hosts:
    localhost:
      ansible_connection: local
  vars:
    app_status: "inventory_defined_status"
```
**Explanation**: Defines the `app_status` variable at the inventory level with a descriptive value, indicating it’s set for the `all` group. Inventory variables are host- or group-specific and have higher precedence than role defaults but lower than other sources.

**project.yml:**
```yaml
---
- name: Test variable precedence
  hosts: localhost
  connection: local
  gather_facts: no

  # Define in playbook vars
  vars:
    app_status: "playbook_defined_status"

  # Include external variable files
  vars_files:
    - vars/vars1.yml
    - vars/vars2.yml

  roles:
    - myrole

  tasks:
    - name: Display final value of app_status
      debug:
        msg: "Final value of app_status: {{ app_status }}"
      tags: var_priority
```
**Explanation**: The playbook defines `app_status` as `playbook_defined_status` in the `vars` section and includes two external variable files. The `debug` task outputs the final value of `app_status`, tagged for selective execution. Playbook `vars` override inventory variables and role defaults but are superseded by higher-precedence sources.

**vars/vars1.yml:**
```yaml
app_status: "vars1_defined_status"
```
**Explanation**: Defines `app_status` with a value specific to the first external file. This is loaded first in the `vars_files` list, so it has lower precedence than `vars2.yml` for conflicting definitions.

**vars/vars2.yml:**
```yaml
app_status: "vars2_defined_status"
```
**Explanation**: Defines `app_status` with a value for the second external file. As the last file in the `vars_files` list, it overrides `vars1.yml` for the same variable, demonstrating the precedence of later-loaded files.

**roles/myrole/defaults/main.yml:**
```yaml
app_status: "default_defined_status"
```
**Explanation**: Defines `app_status` in the role’s defaults, which has the lowest precedence. This value is used only if no other sources define `app_status`, making it ideal for fallback settings.

**roles/myrole/vars/main.yml:**
```yaml
app_status: "role_vars_defined_status"
```
**Explanation**: Defines `app_status` in the role’s variables, which has higher precedence than defaults, playbook `vars`, and `vars_files`, but lower than task-level or command-line variables.

**roles/myrole/tasks/main.yml:**
```yaml
---
- name: Set app_status with set_fact
  set_fact:
    app_status: "set_fact_defined_status"

- name: Display app_status in role tasks (after set_fact)
  debug:
    msg: "app_status in role tasks: {{ app_status }}"
  tags: var_priority
```
**Explanation**: Uses `set_fact` to define `app_status` dynamically during execution, overriding role `vars`, `vars_files`, playbook `vars`, and defaults. The `debug` task outputs the task-level value, tagged for selective execution.


```bash
❯ ansible-playbook -i inventory/arman_hosts myproject.yml  --tags var_priority -e "variable='running'"

PLAY [Test Debug Tasks] ***************************************************************************************************
TASK [myproject : ---- variable final value ----] *************************************************************************ok: [127.0.0.1]

TASK [---- Displaying the final value of variable ---] ********************************************************************ok: [127.0.0.1] => {
    "msg": "variable: running"
}

PLAY RECAP ****************************************************************************************************************127.0.0.1                  : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   

❯ ansible-playbook -i inventory/arman_hosts myproject.yml  --tags var_priority

PLAY [Test Debug Tasks] ***************************************************************************************************
TASK [myproject : ---- variable final value ----] *************************************************************************ok: [127.0.0.1]

TASK [---- Displaying the final value of variable ---] ********************************************************************ok: [127.0.0.1] => {
    "msg": "variable: tasks value"
}

PLAY RECAP ****************************************************************************************************************127.0.0.1                  : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   

❯ sudo vim roles/myproject/tasks/main.yml #commented the task section
❯ ansible-playbook -i inventory/arman_hosts myproject.yml  --tags var_priority

PLAY [Test Debug Tasks] ***************************************************************************************************
TASK [---- Displaying the final value of variable ---] ********************************************************************ok: [127.0.0.1] => {
    "msg": "variable: inside roles/vars/main.yml"
}

PLAY RECAP ****************************************************************************************************************127.0.0.1                  : ok=1    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   

❯ sudo vim roles/myproject/vars/main.yml
❯ ansible-playbook -i inventory/arman_hosts myproject.yml  --tags var_priority #commented roles section

PLAY [Test Debug Tasks] ***************************************************************************************************
TASK [---- Displaying the final value of variable ---] ********************************************************************ok: [127.0.0.1] => {
    "msg": "variable: variable value in vars2.yml which was at the end of the list"
}

PLAY RECAP ****************************************************************************************************************127.0.0.1                  : ok=1    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   

❯ sudo vim myproject.yml # commenting vars_files
❯ ansible-playbook -i inventory/arman_hosts myproject.yml  --tags var_priority

PLAY [Test Debug Tasks] ***************************************************************************************************
TASK [---- Displaying the final value of variable ---] ********************************************************************ok: [127.0.0.1] => {
    "msg": "variable: My main yml variable"
}

PLAY RECAP ****************************************************************************************************************127.0.0.1                  : ok=1    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
```

### Analysis of Provided Outputs

The provided outputs demonstrate how Ansible’s precedence rules determine the final value of the `variable` (renamed to `app_status` in the new playbook for clarity). Below, we analyze each run and explain the observed behavior, mapping it to the new playbook structure. Be aware that in our example, there was no variable definition in defaults/main.yml or in the inventory file, but below they will be covered.

1. **Run 1: Command-Line Extra Variable**
   ```bash
   ansible-playbook -i inventory/hosts.yml project.yml --tags var_priority -e "app_status='command_line_defined_status'"
   ```
   **Output**: `Final value of app_status: command_line_defined_status`
   **Explanation**: The command-line extra variable `-e "app_status='command_line_defined_status'"` has the highest precedence, overriding all other definitions (task-level `set_fact`, role `vars`, `vars_files`, playbook `vars`, inventory, and defaults). The `debug` task in `project.yml` reflects this value, showing that command-line variables are ideal for temporary overrides, such as testing or environment-specific tweaks.

2. **Run 2: No Command-Line Extra Variable**
   ```bash
   ansible-playbook -i inventory/hosts.yml project.yml --tags var_priority
   ```
   **Output**: `app_status in role tasks: set_fact_defined_status`
   **Explanation**: Without a command-line override, the `set_fact` definition in `roles/myrole/tasks/main.yml` (`app_status: "set_fact_defined_status"`) takes precedence. Task-level variables, including those set by `set_fact`, override role `vars`, `vars_files`, playbook `vars`, inventory, and defaults due to their dynamic, runtime evaluation. The `debug` task in the role confirms this value.

3. **Run 3: After Editing `tasks/main.yml`**
   ```bash
   ansible-playbook -i inventory/hosts.yml project.yml --tags var_priority
   ```
   **Output**: `Final value of app_status: role_vars_defined_status`
   **Explanation**: After removing or commenting out the `set_fact` task in `roles/myrole/tasks/main.yml`, the role variable in `roles/myrole/vars/main.yml` (`app_status: "role_vars_defined_status"`) becomes the highest-precedence definition. Role `vars` override `vars_files`, playbook `vars`, inventory, and defaults, as they are specific to the role’s context. The `debug` task in `project.yml` reflects this value.

4. **Run 4: After Editing `vars/main.yml`**
   ```bash
   ansible-playbook -i inventory/hosts.yml project.yml --tags var_priority
   ```
   **Output**: `Final value of app_status: vars2_defined_status`
   **Explanation**: With the role `vars/main.yml` definition removed or commented out, the last-loaded external variable file in the `vars_files` list (`vars/vars2.yml`, with `app_status: "vars2_defined_status"`) takes precedence. Within `vars_files`, the order matters—later files override earlier ones, so `vars2.yml` supersedes `vars1.yml`. This overrides playbook `vars`, inventory, and defaults, as `vars_files` have higher precedence.

5. **Run 5: After Editing `project.yml`**
   ```bash
   ansible-playbook -i inventory/hosts.yml project.yml --tags var_priority
   ```
   **Output**: `Final value of app_status: playbook_defined_status`
   **Explanation**: After removing or commenting out the `vars_files` directive in `project.yml`, the playbook’s `vars` section (`app_status: "playbook_defined_status"`) becomes the highest-precedence definition. Playbook `vars` override inventory variables and role defaults but are superseded by `vars_files`, role `vars`, task-level vars, and command-line extras. The `debug` task in `project.yml` outputs this value.

6. **Additional Run: Inventory Variables**
   ```bash
   ansible-playbook -i inventory/hosts.yml project.yml --tags var_priority
   ```
   **Assumed Modification**: Remove or comment out `vars`, `vars_files`, role `vars`, and `set_fact` definitions.
   **Expected Output**: `Final value of app_status: inventory_defined_status`
   **Explanation**: With all higher-precedence sources removed, the inventory variable in `inventory/hosts.yml` (`app_status: "inventory_defined_status"`) takes effect. Inventory variables override role defaults but are superseded by playbook `vars`, `vars_files`, role `vars`, task-level vars, and command-line extras.

7. **Additional Run: Role Defaults**
   ```bash
   ansible-playbook -i inventory/hosts.yml project.yml --tags var_priority
   ```
   **Assumed Modification**: Remove or comment out `vars`, `vars_files`, role `vars`, `set_fact`, and inventory variable definitions.
   **Expected Output**: `Final value of app_status: default_defined_status`
   **Explanation**: With all other sources removed, the role default in `roles/myrole/defaults/main.yml` (`app_status: "default_defined_status"`) is used. Defaults have the lowest precedence and serve as fallback values when no other definitions exist.

### Variable Precedence Table

| Variable Source | Precedence Level (Highest to Lowest) | Description and Override Behavior | Example from Playbook | Observed/Expected Output |
|-----------------|--------------------------------------|-----------------------------------|-----------------------|--------------------------|
| Command-line extra vars (`-e`) | Highest | Overrides all other sources; ideal for temporary or runtime-specific changes. Cannot be overridden except by another `-e` in the same command (last one wins). | `-e "app_status='command_line_defined_status'"` | `command_line_defined_status` (Run 1) |
| Task vars (`set_fact`, registered vars) | High | Defined dynamically in tasks; overrides role vars, vars_files, playbook vars, inventory, and defaults. Scoped to the play or task. | `set_fact: app_status: "set_fact_defined_status"` | `set_fact_defined_status` (Run 2) |
| Role vars (`vars/main.yml`) | Medium-High | Overrides vars_files, playbook vars, inventory, and defaults; specific to the role and overridden by task-level or command-line vars. | `app_status: "role_vars_defined_status"` | `role_vars_defined_status` (Run 3) |
| Play vars_files | Medium | Loaded files override playbook vars, inventory, and defaults; within the list, later files override earlier ones. Overridden by role vars, tasks, and extras. | `vars2.yml: app_status: "vars2_defined_status"` | `vars2_defined_status` (Run 4) |
| Play vars | Medium-Low | Defined in playbook; overrides inventory vars and role defaults but is superseded by vars_files, role vars, tasks, and extras. | `vars: app_status: "playbook_defined_status"` | `playbook_defined_status` (Run 5) |
| Inventory vars | Low | Defined in inventory or host_vars/group_vars; overrides role defaults but is superseded by playbook vars, vars_files, role vars, tasks, and extras. | `app_status: "inventory_defined_status"` | `inventory_defined_status` (Additional Run) |
| Role defaults (`defaults/main.yml`) | Lowest | Fallback values; easily overridden by all other sources listed above. | `app_status: "default_defined_status"` | `default_defined_status` (Additional Run) |

### Best Practices and Tips for Managing Variable Precedence

1. **Use Descriptive Names**: Choose clear, snake_case variable names like `app_status` instead of generic ones like `variable`. This improves readability and reduces confusion.
   ```yaml
   # Good
   app_status: "production_ready"
   # Avoid
   variable: "production_ready"
   ```
2. **Leverage Precedence Intentionally**: Use command-line extras (`-e`) for temporary overrides, `set_fact` for runtime calculations, and defaults for stable fallbacks. Avoid defining the same variable in multiple places unless necessary.
3. **Test Precedence**: Use tags (e.g., `var_priority`) to run specific tasks and verify which variable source wins.
   ```bash
   ansible-playbook -i inventory/hosts.yml project.yml --tags var_priority
   ```
4. **Document Sources**: Add comments to indicate where variables are defined, especially in complex projects.
   ```yaml
   # vars/vars1.yml
   app_status: "vars1_defined_status"  # Environment-specific status
   ```
5. **Control vars_files Order**: List `vars_files` in order of increasing specificity to ensure the desired override (last file wins).
   ```yaml
   vars_files:
     - vars/common.yml  # Base settings
     - vars/production.yml  # Environment overrides
   ```
6. **Secure Sensitive Variables**: Use Ansible Vault for sensitive inventory or role variables (e.g., API keys) instead of plain text.
   ```bash
   ansible-vault encrypt vars/secrets.yml
   ```
7. **Validate Variables**: Use the `assert` module to ensure critical variables are defined correctly.
   ```yaml
   - name: Ensure app_status is defined
     assert:
       that: "app_status is defined"
       fail_msg: "app_status must be set"
   ```
8. **Minimize Redundancy**: Define variables at the appropriate scope (e.g., defaults for stable values, `vars_files` for environment-specific settings) to avoid conflicts.
9. **Use Inventory for Host-Specific Data**: Store host- or group-specific settings like IP addresses or hostnames in `inventory/hosts.yml` or `host_vars`/`group_vars`.
   ```yaml
   # inventory/hosts.yml
   all:
     vars:
       app_status: "inventory_defined_status"
   ```
10. **Debug with Verbosity**: Use `-v` or higher verbosity (`-vvv`) to trace variable resolution during playbook execution.
    ```bash
    ansible-playbook -i inventory/hosts.yml project.yml --tags var_priority -vvv
    ```

### Conclusion

Mastering variable precedence in Ansible is essential for building predictable and flexible automation workflows. By understanding the hierarchy—from command-line extra variables at the top to role defaults at the bottom—you can control which values are applied in your playbooks. The provided outputs and new playbook demonstrate how each source (command-line, tasks, role vars, vars_files, playbook vars, inventory, and defaults) interacts, with higher-precedence sources overriding lower ones. By following best practices like clear naming, intentional scoping, and thorough testing, you can ensure your automation is robust and adaptable to diverse environments. Stay tuned for future discussions on crafting effective playbooks and advanced Ansible techniques!
# 3.9. Fetch Module

2025-08-13 17:07
Status: #DONE 
Tags: [[Ansible]]

---
## Understanding the Ansible Fetch Module: A Comprehensive Guide

In the realm of DevOps automation, Ansible's capability to manage file operations across remote and local environments is a cornerstone of effective configuration management. The `ansible.builtin.fetch` module complements this by enabling the retrieval of files from remote nodes and storing them locally, organized by hostname. This document provides a detailed exploration of the module, drawing from its official documentation and the provided resource, which includes examples of fetching files with various destination configurations. It begins with a simplified overview for foundational understanding, followed by an in-depth analysis of its parameters, including all possible values, best practices, and illustrative examples with expected outputs.

#### Simplified Explanation: Breaking It Down Simply

Imagine the `fetch` module as a courier that collects files from remote computers and delivers them to your local machine, neatly sorting them into folders based on the remote host's name. You tell it which file to grab (e.g., `/etc/hosts`) and where to store it locally (e.g., `/backup`), and it handles the transfer, even overwriting local copies if they differ. For instance, fetching `/tmp/somefile` from `host.example.com` to `/tmp/fetched` places it at `/tmp/fetched/host.example.com/tmp/somefile`. It’s like a reverse `copy`—useful for backups or gathering logs—ensuring you get the latest version safely.

#### In-Depth Analysis: Precise and Comprehensive Coverage

The `ansible.builtin.fetch` module, part of `ansible-core`, serves as the inverse of the `ansible.builtin.copy` module, facilitating the retrieval of files from remote nodes to the control node. Files are organized in a directory structure under the specified `dest`, prefixed with the inventory hostname (e.g., `/backup/host.example.com/etc/profile`). It overwrites local files if they differ from the remote source, supports Windows targets, and includes an action plugin for controller-side execution. Unlike `copy`, it does not support directories (recursive fetching is planned for future releases) and focuses on individual files.

The module leverages the `ansible.builtin.slurp` module when `become` is used to compute remote checksums, which can double transfer size and risk memory exhaustion (`MemoryError`) for large files. This makes it advisable to avoid `become` unless necessary. Since Ansible 2.5, `fail_on_missing` defaults to `true`, failing if the remote file is unreadable (e.g., permissions issues), a change from earlier behavior where only missing files triggered failure. Playbook authors can use `fail_when` or `ignore_errors` for custom handling, or set `fail_on_missing` to `false` for legacy behavior.

Each parameter is analyzed below, detailing its purpose, type, default value, all possible values, requirements, and interactions. Best practices, tips, and tricks are included, with examples from the documentation and reasoning about expected outcomes.

- **dest**: Specifies the local directory to save the fetched file. Type: string. Default: None. Possible values: Any local directory path (e.g., `/backup`, `special/`). Required: Yes. Notes: Creates a subdirectory with the inventory hostname; if `flat: yes`, uses basename or direct path.

  Best practice: Use absolute paths for clarity (e.g., `/path/to/backups`). Tip: Ensure write permissions on `dest`; trick: Use `{{ inventory_hostname }}` dynamically.

  Example from resource: Basic fetch.
  ```yaml
  - name: Store file into /tmp/fetched/host.example.com/tmp/somefile
    ansible.builtin.fetch:
      src: /tmp/somefile
      dest: /tmp/fetched
  ```
  Expected output: Fetches `/tmp/somefile` from remote, saves to `/tmp/fetched/host.example.com/tmp/somefile` (`changed: true` if new/different); return: `dest: /tmp/fetched/host.example.com/tmp/somefile`, `checksum` matches remote.

- **fail_on_missing**: Determines behavior when the remote file is unreadable. Type: boolean. Default: true (since 2.5). Possible values: true (fail on any read failure), false (continue if missing). Required: No. Notes: Pre-2.5, only missing files failed; use `fail_when` for custom logic.

  Best practice: Set false for robust workflows with optional files. Tip: Combine with `ignore_errors` for non-critical fetches; trick: Check file existence with `stat` first.

  Example: Allow missing files.
  ```yaml
  - name: Fetch with tolerance
    ansible.builtin.fetch:
      src: /tmp/optional.txt
      dest: /tmp/backups
      fail_on_missing: false
  ```
  Expected output: Skips if missing (`changed: false`, no failure); fetches if present (`changed: true`); return: `msg: "file not found"` if absent.

- **flat**: Overrides the hostname/path structure, using `dest` directly or basename. Type: boolean. Default: false. Possible values: true (flatten structure), false (use hostname/path). Required: No. Notes: Overwrites if multiple hosts share filenames; `dest` ending with '/' uses basename.

  Best practice: Use true for single-host or unique filenames. Tip: Avoid with overlapping names across hosts; trick: Append `{{ inventory_hostname }}` manually if needed.

  Example from resource: Flat fetch.
  ```yaml
  - name: Specifying a path directly
    ansible.builtin.fetch:
      src: /tmp/somefile
      dest: /tmp/prefix-{{ inventory_hostname }}
      flat: yes
  ```
  Expected output: Saves as `/tmp/prefix-host.example.com` (`changed: true` if differs); return: `dest: /tmp/prefix-host.example.com`, no subdirectory.

- **src**: The remote file to fetch. Type: string. Default: None. Possible values: Any remote file path (e.g., `/etc/hosts`). Required: Yes. Notes: Must be a file, not a directory; no recursive support yet.

  Best practice: Use absolute paths for precision. Tip: Verify with `stat` module; trick: Use wildcards cautiously with future recursive support.

  Example from resource: Src definition.
  Expected output: Fetches specified file to `dest` structure.

- **validate_checksum**: Verifies source and destination checksums post-fetch. Type: boolean. Default: true. Possible values: true (validate), false (skip validation). Required: No. Notes: Ensures integrity; uses `slurp` with `become`.

  Best practice: Keep true for data integrity. Tip: Disable for speed on trusted networks; trick: Log mismatches with `register`.

  Example: Validate checksum.
  ```yaml
  - name: Fetch with validation
    ansible.builtin.fetch:
      src: /etc/hosts
      dest: /tmp/backups
      validate_checksum: yes
  ```
  Expected output: Fetches and checks; fails if checksums mismatch (`changed: true` if successful); return: `checksum` matches remote.

### Practical Examples and Expected Outcomes

1. **Basic Fetch with Hostname Structure**:
   ```yaml
   - name: Fetch system file
     ansible.builtin.fetch:
       src: /etc/hosts
       dest: /tmp/backups
   ```
   Outcome: Saves to `/tmp/backups/host.example.com/etc/hosts` (`changed: true` if new/different); return: `dest`, `checksum`, `size`.

2. **Flat Fetch with Dynamic Path**:
   ```yaml
   - name: Fetch to custom path
     ansible.builtin.fetch:
       src: /tmp/log.txt
       dest: /tmp/logs-{{ inventory_hostname }}
       flat: yes
   ```
   Outcome: Saves as `/tmp/logs-host.example.com` (`changed: true`); overwrites if same name across hosts.

3. **Tolerant Fetch**:
   ```yaml
   - name: Fetch optional file
     ansible.builtin.fetch:
       src: /tmp/nonexistent.txt
       dest: /tmp/backups
       fail_on_missing: false
       ignore_errors: yes
   ```
   Outcome: Skips if absent (`changed: false`, no failure); fetches if present.

### Best Practices and Considerations

- **Performance**: Avoid `become` for large files to prevent memory issues; use `fetch` without privilege escalation where possible.
- **Idempotency**: Overwrites differing files; use `validate_checksum` to ensure accuracy.
- **Security**: Limit `dest` access; avoid `flat` with overlapping filenames across hosts.
- **Troubleshooting**: Use `-v` to debug transfers; check `slurp` usage with `become`.

## Additional Examples for the Ansible Fetch Module

#### Example 1: Fetching Multiple Files with Pattern Matching
```yaml
- name: Fetch all log files from /var/log
  ansible.builtin.find:
    paths: /var/log
    patterns: "*.log"
  register: log_files

- name: Fetch each log file
  ansible.builtin.fetch:
    src: "{{ item.path }}"
    dest: "/tmp/logs/{{ inventory_hostname }}/"
  loop: "{{ log_files.files }}"
```
**Explanation**: This example first uses the `find` module to locate all `.log` files in `/var/log` on the remote host, then iterates through each file to fetch it. The fetched files are stored in `/tmp/logs/hostname/` preserving the directory structure. This is useful for collecting logs from multiple servers for centralized analysis. Output shows `changed: true` for each file that was successfully fetched, with return values including the destination path and checksum.

#### Example 2: Fetching Files with Conditional Logic
```yaml
- name: Fetch configuration if it exists
  ansible.builtin.stat:
    path: /etc/app/config.yml
  register: config_stat

- name: Fetch configuration file
  ansible.builtin.fetch:
    src: /etc/app/config.yml
    dest: /tmp/backups/
    flat: yes
  when: config_stat.stat.exists
```
**Explanation**: This example first checks if the configuration file exists using the `stat` module, then only fetches the file if it exists. The `flat: yes` parameter stores the file directly in `/tmp/backups/` without creating hostname subdirectories. This approach is useful for conditional file retrieval, especially when dealing with optional configuration files. Output shows `changed: true` only if the file exists and was fetched, otherwise the task is skipped.

#### Example 3: Fetching Files with Custom Naming
```yaml
- name: Fetch file with timestamp in filename
  ansible.builtin.fetch:
    src: /var/log/app.log
    dest: "/tmp/logs/{{ inventory_hostname }}-app-{{ ansible_date_time.iso8601_basic }}.log"
    flat: yes
  register: fetched_log
```
**Explanation**: This example fetches a log file and names it with the hostname and timestamp, making it easy to track when the file was retrieved. The `flat: yes` parameter ensures the file is stored directly in `/tmp/logs/` with the custom name. This is particularly useful for creating timestamped backups or for tracking changes over time. Output shows `changed: true` with the custom destination path in the return values.

#### Example 4: Fetching Files with Validation and Error Handling
```yaml
- name: Fetch and validate SSL certificate
  ansible.builtin.fetch:
    src: /etc/ssl/certs/server.crt
    dest: /tmp/certs/
    validate_checksum: yes
  register: cert_fetch
  failed_when: cert_fetch.failed or 'checksum' not in cert_fetch
```
**Explanation**: This example fetches an SSL certificate and validates its checksum to ensure integrity. The `failed_when` condition provides custom error handling, marking the task as failed if the fetch fails or if the checksum is missing from the return values. This approach is useful for security-sensitive files where integrity verification is critical. Output shows `changed: true` if the certificate was successfully fetched and validated, with the checksum in the return values.

#### Example 5: Fetching Files with Flat Structure and Unique Naming
```yaml
- name: Fetch file with unique naming to avoid conflicts
  ansible.builtin.fetch:
    src: /etc/hosts
    dest: "/tmp/backups/hosts-{{ inventory_hostname }}-{{ ansible_date_time.epoch }}"
    flat: yes
```
**Explanation**: This example fetches the hosts file and names it uniquely using the hostname and epoch timestamp to avoid conflicts when fetching from multiple hosts. The `flat: yes` parameter stores the file directly in `/tmp/backups/` with the custom name. This is useful when you want to avoid the default hostname subdirectory structure while still maintaining unique filenames. Output shows `changed: true` with the unique destination path in the return values.

#### Example 6: Fetching Files with Tolerance for Missing Files
```yaml
- name: Attempt to fetch optional configuration file
  ansible.builtin.fetch:
    src: /etc/app/optional.conf
    dest: /tmp/configs/
    fail_on_missing: false
  register: optional_config
  ignore_errors: yes

- name: Create default configuration if missing
  ansible.builtin.copy:
    content: "# Default configuration\n"
    dest: "/tmp/configs/{{ inventory_hostname }}/etc/app/optional.conf"
  when: optional_config.msg is defined and "file not found" in optional_config.msg
```
**Explanation**: This example attempts to fetch an optional configuration file, tolerating cases where it doesn't exist (`fail_on_missing: false`). If the file is missing, it creates a default configuration file locally. This approach is useful for handling optional configuration files that might not exist on all hosts. Output shows `changed: true` only if the file was fetched or if the default was created, with appropriate return values for each case.

#### Example 7: Fetching Files with Checksum Validation and Custom Directory Structure
```yaml
- name: Fetch configuration with custom directory structure
  ansible.builtin.fetch:
    src: /etc/app/app.conf
    dest: "/tmp/backups/{{ ansible_distribution }}/{{ inventory_hostname }}/"
    validate_checksum: yes
```
**Explanation**: This example fetches a configuration file and organizes it by OS distribution and hostname. The `validate_checksum: yes` parameter ensures the file integrity is verified. This approach is useful for organizing fetched files by system characteristics, making it easier to manage configurations across different operating systems. Output shows `changed: true` with the destination path organized by distribution and hostname, with the checksum in the return values.

#### Example 8: Fetching Files with Become and Memory Considerations
```yaml
- name: Fetch protected file without become to avoid memory issues
  ansible.builtin.fetch:
    src: /root/protected_file.txt
    dest: /tmp/protected/
  become: no
  register: protected_fetch
```
**Explanation**: This example fetches a protected file without using `become` to avoid potential memory issues with large files. When `become` is used with the fetch module, it uses the `slurp` module which can cause memory exhaustion for large files. This approach is useful for fetching large protected files when you have the necessary permissions without privilege escalation. Output shows `changed: true` if the file was successfully fetched, with a warning if access was denied.

#### Example 9: Fetching Files with Flat Structure and Directory Creation
```yaml
- name: Ensure backup directory exists
  ansible.builtin.file:
    path: /tmp/backups
    state: directory
    mode: 0755

- name: Fetch file to flat structure
  ansible.builtin.fetch:
    src: /etc/app/app.conf
    dest: /tmp/backups/
    flat: yes
```
**Explanation**: This example first ensures the backup directory exists, then fetches a file to that directory using a flat structure. The `flat: yes` parameter stores the file directly in `/tmp/backups/` without creating hostname subdirectories. This approach is useful when you want to store all fetched files in a single directory, particularly when dealing with unique filenames across hosts. Output shows `changed: true` if the file was successfully fetched, with the destination path in the return values.

#### Example 10: Fetching Files with Conditional Overwrite
```yaml
- name: Fetch file only if local version is older
  ansible.builtin.stat:
    path: "/tmp/backups/{{ inventory_hostname }}/etc/app/app.conf"
  register: local_file

- name: Fetch remote file if local is older
  ansible.builtin.fetch:
    src: /etc/app/app.conf
    dest: /tmp/backups/
  when: not local_file.stat.exists or local_file.stat.mtime < ansible_date_time.epoch|int - 86400
```
**Explanation**: This example checks if a local version of the file exists and if it's older than one day (86400 seconds). If the local file doesn't exist or is older than one day, it fetches the remote file. This approach is useful for maintaining up-to-date backups without unnecessary transfers when the remote file hasn't changed. Output shows `changed: true` only if the file was fetched, with the destination path and modification time in the return values.

#### Summary Table of Arguments

| Argument Name | Type | Default Value | Possible Values | Required | Notes/Deprecations |
|---------------|------|---------------|-----------------|----------|--------------------|
| dest | string | None | Any directory path | Yes | Hostname subdirectory unless flat |
| fail_on_missing | boolean | true | true, false | No | Default true since 2.5 |
| flat | boolean | false | true, false | No | Overrides hostname/path |
| src | string | None | Any file path | Yes | No directories yet |
| validate_checksum | boolean | true | true, false | No | Uses slurp with become |

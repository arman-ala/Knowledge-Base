# 2.10.9. Multiple Inventories and Variables

2025-08-12 05:02
Status: #DONE 
Tags: [[Ansible]]

---
# Multiple Inventory Sources and Variable Priority in Ansible: A DevOps Guide

## Introduction

In the world of infrastructure automation, Ansible shines for its flexibility in managing complex environments. One of its key strengths is the ability to use multiple inventory sources, allowing you to separate configurations for different environments, like staging and production, or combine static and dynamic inventories. However, when you’re juggling multiple inventories, understanding how Ansible merges variables and prioritizes them is critical to avoid unexpected behavior. This article dives into the mechanics of using multiple inventory sources, focusing on how the order of specification impacts variable precedence. We’ll break it down in a simple, human-like way and then go deep with technical details, enriched examples, and practical tips to help you master this powerful feature.

## For Beginners: Multiple Inventories Made Simple

Think of Ansible inventories as cookbooks for your servers. Imagine you’re planning a big dinner and you have two cookbooks—one for everyday meals with basic recipes (like spaghetti) and another for fancy holiday feasts (like roasted lamb). You decide to use both, but some recipes overlap, like how to season a dish. If the everyday cookbook says “add salt” and the holiday one says “add rosemary,” which do you pick? The one you read last gets the final say.

In Ansible, inventories work the same way:
- **Multiple inventories** are like having different cookbooks for different scenarios (e.g., staging vs. production).
- **Variables** are the ingredients or instructions (like port numbers or server settings).
- **Order matters**: The last cookbook (inventory) you specify wins if there’s a conflict, just like choosing rosemary over salt if you read the holiday book last.

This setup lets you mix and match configurations, but you need to know which cookbook comes last to get the flavor you want!

## In-Depth Analysis: Multiple Inventory Sources and Variable Priority

### Understanding Multiple Inventory Sources

Ansible allows you to specify multiple inventory sources using the `-i` option on the command line, enabling you to combine configurations from different files or scripts. This is particularly useful for:
- **Environment separation**: Managing staging, production, or development setups.
- **Static and dynamic inventories**: Combining fixed host lists with cloud-based dynamic inventories (e.g., AWS EC2).
- **Layered configurations**: Applying base settings with environment-specific overrides.
- **Shared configurations**: Reusing common variables across multiple environments.

### Basic Syntax for Multiple Inventory Sources

```bash
ansible-playbook -i staging_inventory.yml -i production_inventory.yml playbook.yml
```

This command tells Ansible to load both `staging_inventory.yml` and `production_inventory.yml`, merging their hosts and variables. The order of `-i` options determines precedence for conflicting definitions.

### Variable Merging Behavior

When multiple inventories are used, Ansible follows these rules:
1. **Host Definitions**: Hosts from all inventories are combined. If a host appears in multiple inventories, its variables are merged based on precedence.
2. **Variable Precedence**: For conflicting variables, the last inventory specified overrides earlier ones.
3. **Group Variables**: If the same group exists in multiple inventories, group variables from the last inventory take precedence.
4. **Host Variables**: Host-specific variables from the last inventory override those from earlier inventories.
5. **Group Hierarchy**: Within each inventory, group variable precedence is `all` < parent groups < child groups < host variables. Across inventories, the last inventory’s definitions dominate.

### Effect of Inventory Order on Variable Priority

The order of inventory files specified with `-i` directly impacts which variables are used. Let’s explore this with enriched examples, incorporating all variable sources discussed previously and explaining their interactions with multiple inventories.

#### Comprehensive Example

**Directory Structure:**
```
.
├── playbook.yml
├── inventory
│   ├── base_inventory.yml
│   ├── staging_inventory.yml
│   └── production_inventory.yml
├── vars
│   ├── vars1.yml
│   └── vars2.yml
└── roles
    └── myrole
        ├── defaults
        │   └── main.yml
        ├── tasks
        │   └── main.yml
        └── vars
            └── main.yml
```

**File Contents:**

**inventory/base_inventory.yml:**
```yaml
all:
  hosts:
    web01:
      ansible_host: 192.168.1.10
      app_status: "base_host_status"
  vars:
    app_status: "base_group_status"
    ntp_server: "pool.ntp.org"
```
**Explanation**: Defines `app_status` at host and group levels, plus a global NTP server. Host variables override group variables within the inventory.

**inventory/staging_inventory.yml:**
```yaml
webservers:
  hosts:
    web01:
      ansible_host: 192.168.1.10
      app_status: "staging_host_status"
  vars:
    app_status: "staging_group_status"
    environment: "staging"
    ansible_group_priority: 10
```
**Explanation**: Defines `app_status` for `web01` and the `webservers` group, with a priority to influence group merging.

**inventory/production_inventory.yml:**
```yaml
webservers:
  hosts:
    web01:
      ansible_host: 10.0.1.10
      app_status: "production_host_status"
  vars:
    app_status: "production_group_status"
    environment: "production"
    ansible_group_priority: 5
```
**Explanation**: Overrides `ansible_host` and `app_status`, with a lower group priority than staging.

**playbook.yml:**
```yaml
---
- name: Test variable precedence
  hosts: web01
  gather_facts: no

  vars:
    app_status: "playbook_defined_status"

  vars_files:
    - vars/vars1.yml
    - vars/vars2.yml

  roles:
    - myrole

  tasks:
    - name: Display final app_status
      debug:
        msg: "Final value of app_status: {{ app_status }}"
      tags: var_priority
```
**Explanation**: Defines `app_status` in playbook `vars`, includes external variable files, and applies a role. The `debug` task outputs the final value.

**vars/vars1.yml:**
```yaml
app_status: "vars1_defined_status"
```
**Explanation**: First external file, overridden by `vars2.yml`.

**vars/vars2.yml:**
```yaml
app_status: "vars2_defined_status"
```
**Explanation**: Second external file, overriding `vars1.yml`.

**roles/myrole/defaults/main.yml:**
```yaml
app_status: "default_defined_status"
```
**Explanation**: Lowest-precedence fallback value.

**roles/myrole/vars/main.yml:**
```yaml
app_status: "role_vars_defined_status"
```
**Explanation**: Role-specific variable, overriding defaults, `vars_files`, and playbook `vars`.

**roles/myrole/tasks/main.yml:**
```yaml
---
- name: Set app_status with set_fact
  set_fact:
    app_status: "set_fact_defined_status"

- name: Display app_status in role
  debug:
    msg: "app_status in role tasks: {{ app_status }}"
  tags: var_priority
```
**Explanation**: Dynamically sets `app_status`, overriding all except command-line extras.

### Testing and Output Analysis

We run the playbook multiple times, modifying configurations to observe precedence, including inventory-specific effects:

1. **Command-Line Extra Variable:**
   ```bash
   ansible-playbook -i inventory/base_inventory.yml -i inventory/staging_inventory.yml -i inventory/production_inventory.yml playbook.yml --tags var_priority -e "app_status=command_line_defined_status"
   ```
   **Output**: `Final value of app_status: command_line_defined_status`
   **Explanation**: The command-line `-e` variable has the highest precedence, overriding all inventory, role, and playbook definitions. This is ideal for temporary overrides, like testing a specific configuration.

2. **Task-Level Variable (`set_fact`):**
   ```bash
   ansible-playbook -i inventory/base_inventory.yml -i inventory/staging_inventory.yml -i inventory/production_inventory.yml playbook.yml --tags var_priority
   ```
   **Output**: `app_status in role tasks: set_fact_defined_status`
   **Explanation**: Without command-line extras, the `set_fact` in `tasks/main.yml` takes precedence, overriding role `vars`, `vars_files`, playbook `vars`, and all inventory variables.

3. **Role Variables (`vars/main.yml`):**
   - Comment out the `set_fact` task in `tasks/main.yml`.
   ```bash
   ansible-playbook -i inventory/base_inventory.yml -i inventory/staging_inventory.yml -i inventory/production_inventory.yml playbook.yml --tags var_priority
   ```
   **Output**: `Final value of app_status: role_vars_defined_status`
   **Explanation**: Role variables override `vars_files`, playbook `vars`, and all inventory variables, as they are specific to the role’s context.

4. **External Variable Files (`vars_files`):**
   - Comment out `vars/main.yml` content.
   ```bash
   ansible-playbook -i inventory/base_inventory.yml -i inventory/staging_inventory.yml -i inventory/production_inventory.yml playbook.yml --tags var_priority
   ```
   **Output**: `Final value of app_status: vars2_defined_status`
   **Explanation**: The last `vars_files` entry (`vars2.yml`) overrides `vars1.yml`, playbook `vars`, and inventory variables, as `vars_files` have higher precedence than inventory and playbook `vars`.

5. **Playbook Variables (`vars`):**
   - Remove `vars_files` from `playbook.yml`.
   ```bash
   ansible-playbook -i inventory/base_inventory.yml -i inventory/staging_inventory.yml -i inventory/production_inventory.yml playbook.yml --tags var_priority
   ```
   **Output**: `Final value of app_status: playbook_defined_status`
   **Explanation**: Playbook `vars` override all inventory variables and role defaults, but are superseded by `vars_files`, role `vars`, and task variables.

6. **Inventory Host Variables:**
   - Remove `vars` from `playbook.yml`.
   ```bash
   ansible-playbook -i inventory/base_inventory.yml -i inventory/staging_inventory.yml -i inventory/production_inventory.yml playbook.yml --tags var_priority
   ```
   **Output**: `Final value of app_status: production_host_status`
   **Explanation**: Host variables from `production_inventory.yml` override those from `staging_inventory.yml` and `base_inventory.yml` because it’s the last inventory specified. Host variables also override group variables within inventories.

7. **Inventory Group Variables:**
   - Remove `app_status` from the host definition in `production_inventory.yml`.
   ```bash
   ansible-playbook -i inventory/base_inventory.yml -i inventory/staging_inventory.yml -i inventory/production_inventory.yml playbook.yml --tags var_priority
   ```
   **Output**: `Final value of app_status: production_group_status`
   **Explanation**: With host variables removed, group variables from `production_inventory.yml` take precedence over `staging_inventory.yml` (due to inventory order) and `base_inventory.yml`. Within `production_inventory.yml`, `webservers` group variables override `all` group variables.

8. **Inventory Group Variables with Priority:**
   - Modify `production_inventory.yml` to remove `app_status` from `webservers:vars`, leaving `staging_inventory.yml`’s `webservers` group with higher `ansible_group_priority`.
   ```bash
   ansible-playbook -i inventory/base_inventory.yml -i inventory/staging_inventory.yml -i inventory/production_inventory.yml playbook.yml --tags var_priority
   ```
   **Output**: `Final value of app_status: staging_group_status`
   **Explanation**: Despite `production_inventory.yml` being last, `staging_inventory.yml`’s `webservers` group has higher `ansible_group_priority` (10 vs. 5), so its `app_status` wins for group variables.

9. **Role Defaults:**
   - Remove `app_status` from all inventory files.
   ```bash
   ansible-playbook -i inventory/base_inventory.yml -i inventory/staging_inventory.yml -i inventory/production_inventory.yml playbook.yml --tags var_priority
   ```
   **Output**: `Final value of app_status: default_defined_status`
   **Explanation**: With no inventory, playbook, or role variables defined, the role default in `defaults/main.yml` is used as the fallback.

### Additional Inventory Examples

#### Example 1: Mixing Static and Dynamic Inventories
```bash
ansible-playbook -i static_inventory.yml -i aws_ec2.py playbook.yml
```
**static_inventory.yml**:
```yaml
all:
  hosts:
    web01:
      ansible_host: 192.168.1.10
  vars:
    app_status: "static_status"
```
**aws_ec2.py (Dynamic Output)**:
```yaml
webservers:
  hosts:
    web01:
      ansible_host: ec2-198-51-100-1.compute-1.amazonaws.com
      app_status: "aws_status"
```
**Output (with no higher-precedence sources)**: `app_status: aws_status`
**Explanation**: The dynamic inventory (`aws_ec2.py`) is last, so its host variable for `web01` overrides the static inventory’s variable.

#### Example 2: Inventory Directory
```bash
ansible-playbook -i inventory_dir/ playbook.yml
```
**inventory_dir/01_base.yml**:
```yaml
all:
  vars:
    app_status: "base_status"
```
**inventory_dir/02_staging.yml**:
```yaml
webservers:
  vars:
    app_status: "staging_status"
```
**Output**: `app_status: staging_status`
**Explanation**: Files in `inventory_dir` are loaded alphabetically (`01_base.yml`, then `02_staging.yml`), so `staging_status` overrides `base_status`.

#### Example 3: Group Merging with Priority
```yaml
# staging_inventory.yml
webservers:
  hosts:
    web01:
  vars:
    app_status: "staging_group_status"
    ansible_group_priority: 20
```
```yaml
# production_inventory.yml
webservers:
  hosts:
    web01:
  vars:
    app_status: "production_group_status"
    ansible_group_priority: 10
```
```bash
ansible-playbook -i production_inventory.yml -i staging_inventory.yml playbook.yml --tags var_priority
```
**Output**: `app_status: staging_group_status`
**Explanation**: `staging_inventory.yml` is last, and its higher `ansible_group_priority` (20 vs. 10) ensures `webservers` group variables take precedence.

### Best Practices for Multiple Inventory Sources

1. **Order Inventories by Specificity**: List general inventories first and specific ones last to ensure overrides work as expected.
   ```bash
   ansible-playbook -i base_inventory.yml -i environment_specific.yml playbook.yml
   ```
2. **Use Clear Naming Conventions**: Prefix inventory files with numbers (e.g., `01_base.yml`, `02_staging.yml`) for explicit ordering.
3. **Minimize Variable Conflicts**: Use unique variable names or scopes to avoid unintended overrides.
   ```yaml
   # base_inventory.yml
   base_app_status: "base_status"
   # production_inventory.yml
   prod_app_status: "production_status"
   ```
4. **Document Inventory Order**: Include comments in playbooks or documentation to explain the purpose and order of inventories.
   ```yaml
   # playbook.yml
   # Loads base config first, then production overrides
   ```
5. **Test Variable Merging**: Use a debug task to inspect merged variables.
   ```yaml
   - name: Display host variables
     debug:
       var: hostvars[inventory_hostname]
   ```
6. **Use Inventory Directories**: Organize multiple inventories in a directory with numbered prefixes for clarity.
   ```bash
   ansible-playbook -i inventories/ playbook.yml
   ```
7. **Leverage ansible_group_priority**: Control group variable precedence explicitly.
   ```yaml
   webservers:
     vars:
       app_status: "critical_status"
       ansible_group_priority: 50
   ```
8. **Secure Sensitive Data**: Use Ansible Vault for sensitive inventory variables.
   ```bash
   ansible-vault create inventory/secrets.yml
   ```
9. **Validate Variables**: Use `assert` to ensure critical variables are defined.
   ```yaml
   - name: Ensure app_status is defined
     assert:
       that: "app_status is defined"
       fail_msg: "app_status must be set"
   ```
10. **Optimize Performance**: Avoid excessive inventory files to reduce parsing overhead. Consolidate where possible.

### Troubleshooting Common Issues

1. **Unexpected Variable Values**: Check inventory order (`-i`) and verify variable names for typos.
   ```bash
   ansible-playbook -i wrong_order.yml -i correct_order.yml playbook.yml  # Fix order
   ```
2. **Missing Hosts**: Ensure hosts are defined correctly in all inventories.
   ```bash
   ansible-inventory --list -i inventory_dir/  # Inspect hosts
   ```
3. **Group Variable Conflicts**: Verify group names and `ansible_group_priority` settings.
4. **Slow Execution**: Reduce the number of inventory files or use dynamic inventories efficiently.

## Conclusion

Using multiple inventory sources in Ansible unlocks powerful flexibility for managing diverse environments, but it demands a clear understanding of variable precedence and merging behavior. The order of inventory specification (`-i`) determines which variables take precedence, with the last inventory overriding earlier ones. By integrating multiple inventories with other variable sources—command-line extras, task variables, role variables, `vars_files`, playbook `vars`, and role defaults—you can create layered, environment-specific configurations. The comprehensive example illustrates how these sources interact, and the best practices ensure your automation remains predictable and maintainable. With this knowledge, you’re ready to orchestrate complex infrastructure with confidence!

## Unified Variable Precedence Table

| Variable Source | Precedence Level (Highest to Lowest) | Description and Override Behavior | Example from Comprehensive Example | Observed/Expected Output |
|-----------------|--------------------------------------|-----------------------------------|------------------------------------|--------------------------|
| Command-line extra vars (`-e`) | Highest | Overrides all other sources; ideal for temporary or runtime-specific changes. | `-e "app_status=command_line_defined_status"` | `command_line_defined_status` |
| Task vars (`set_fact`, registered vars) | High | Defined dynamically in tasks; overrides role vars, vars_files, playbook vars, and all inventory vars. | `set_fact: app_status: "set_fact_defined_status"` | `set_fact_defined_status` |
| Role vars (`vars/main.yml`) | Medium-High | Overrides vars_files, playbook vars, and all inventory vars; specific to the role. | `app_status: "role_vars_defined_status"` | `role_vars_defined_status` |
| Play vars_files | Medium | Loaded files override playbook vars and inventory vars; later files override earlier ones. | `vars2.yml: app_status: "vars2_defined_status"` | `vars2_defined_status` |
| Play vars | Medium-Low | Defined in playbook; overrides all inventory vars and role defaults. | `vars: app_status: "playbook_defined_status"` | `playbook_defined_status` |
| Inventory host vars | Low | Specific to individual hosts; overrides inventory group vars and role defaults; last inventory wins. | `web01: app_status: "production_host_status"` | `production_host_status` |
| Inventory group vars | Lower | Shared across group hosts; overrides role defaults; last inventory wins; within inventory: `all` < parent < child; higher `ansible_group_priority` wins. | `webservers: vars: app_status: "production_group_status"` | `staging_group_status` (due to higher priority) |
| Role defaults (`defaults/main.yml`) | Lowest | Fallback values; overridden by all other sources. | `app_status: "default_defined_status"` | `default_defined_status` |

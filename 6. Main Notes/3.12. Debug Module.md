# 3.12. Debug Module

2025-08-14 04:57
Status: #DONE 
Tags: [[Ansible]]

---
### Understanding the Ansible Debug Module: A Comprehensive Guide
In the domain of DevOps automation, Ansible provides tools to facilitate troubleshooting and visibility during playbook execution. The `ansible.builtin.debug` module serves as a critical utility for printing statements or variable contents, aiding in the debugging process without interrupting the workflow. This document offers a detailed analysis of the module, informed by its official documentation and the provided resource, which includes examples of printing messages and variables under specific conditions. It begins with a simplified overview for foundational understanding, followed by an in-depth examination of its parameters, including all possible values and their effects, best practices, and illustrative examples with expected outputs.
#### Simplified Explanation: Breaking It Down Simply
Imagine the `debug` module as a logbook for your Ansible playbook: it lets you jot down notes or peek at variables (like a server’s gateway or task results) to see what’s happening during execution. You can write a custom message, display a variable’s value, or control when it shows up (e.g., only with extra verbosity). For instance, printing a system’s gateway only if it’s defined helps you verify network settings, while showing task results with higher verbosity (e.g., `-vvv`) assists in troubleshooting. It’s a non-intrusive way to monitor progress, especially useful with conditions like `when:`.
#### In-Depth Analysis: Precise and Comprehensive Coverage
The `ansible.builtin.debug` module, part of `ansible-core`, is designed to output messages or variable values during playbook execution, enhancing debug capabilities across all platforms, including Windows. It supports customization through the `msg` parameter for custom statements, the `var` parameter for variable inspection, and the `verbosity` parameter to control output visibility. The module includes an action plugin for controller-side execution, fully supports `check_mode` for simulation, and offers partial delegation support (e.g., with `register` and `delegate_facts`). It does not modify the target system, making it safe for all environments.
The module is particularly valuable when paired with the `when:` directive to conditionally display information or with `verbosity` to limit output to specific debug levels (e.g., `-v`, `-vvv`). It operates within a Jinja2 context for `var`, requiring careful handling of delimiters to avoid double interpolation. The examples provided illustrate practical applications, such as displaying host-specific facts or task results, underscoring its utility in complex playbooks.
Below, each parameter is analyzed in detail, including its purpose, type, default value, all possible values and their effects, requirements, and interactions. Best practices, tips, and tricks are included, with examples derived from documentation and expanded with reasoning about expected outcomes.
- **msg**: Defines a customized message to print during execution. Type: string. Default: "Hello world!". Possible values: Any string (e.g., "System {{ inventory_hostname }} is up", ["line1", "line2"], effect: prints the specified message(s); supports Jinja2 templating for dynamic content). Required: No. Notes: Mutually exclusive with `var`; accepts lists for multiple lines.
  Best practice: Use clear, informative messages with variables for context. Tip: Leverage Jinja2 for dynamic data; trick: Use lists for multi-line output.
  Example from resource: Conditional message.
  ```yaml
  - name: Print gateway
    ansible.builtin.debug:
      msg: "System {{ inventory_hostname }} has gateway {{ ansible_default_ipv4.gateway }}"
      when: ansible_default_ipv4.gateway is defined
  ```
  Expected output: Prints "System host.example.com has gateway 192.168.1.1" if gateway defined (`changed: false`, no system change); skips if undefined; return: no specific fields, just console output.
  Example: Multi-line message.
  ```yaml
  - name: Print multi-line
    ansible.builtin.debug:
      msg:
      - "Server status: {{ ansible_hostname }}"
      - "Uptime: {{ ansible_uptime_seconds }} seconds"
  ```
  Expected output: Displays two lines (e.g., "Server status: host1", "Uptime: 3600 seconds") (`changed: false`); return: none.
- **var**: Specifies a variable to debug and display its value. Type: string. Default: None. Possible values: Any variable name (e.g., "result", "hostvars[inventory_hostname]", effect: prints the variable’s value with its name; runs in Jinja2 context, so no extra `{{ }}` needed unless intentional double interpolation). Required: No. Notes: Mutually exclusive with `msg`; supports nested variables and facts.
  Best practice: Use for inspecting complex data structures. Tip: Avoid Jinja2 delimiters unless nesting; trick: Combine with `verbosity` for selective display.
  Example from resource: Debug task result.
  ```yaml
  - name: Debug result
    ansible.builtin.debug:
      var: result
      verbosity: 2
  ```
  Expected output: Prints "result: {...}" with task output (e.g., stdout, rc) only with `-vv` or higher (`changed: false`); return: none, output to console.
  Example: Debug hostvars.
  ```yaml
  - name: Debug all hostvars
    ansible.builtin.debug:
      var: hostvars[inventory_hostname]
      verbosity: 4
  ```
  Expected output: Displays full hostvars dictionary (e.g., all facts) with `-vvvv` or higher (`changed: false`); return: none.
- **verbosity**: Controls the debug output level based on Ansible’s verbosity flags. Type: integer. Default: 0. Possible values: 0 (prints at all verbosity levels, effect: always visible with `-v`, `-vv`, `-vvv`, etc.), 1 (visible with `-v` or higher, effect: requires at least basic verbosity), 2 (visible with `-vv` or higher, effect: requires detailed verbosity), 3 (visible with `-vvv` or higher, effect: requires debug verbosity), 4 (visible with `-vvvv` or higher, effect: requires maximum verbosity), and so forth. Required: No. Notes: Higher values restrict output to matching verbosity levels.
  Best practice: Set to match debugging needs (e.g., 2 for task results). Tip: Adjust based on playbook complexity; trick: Use with `when:` for conditional verbosity.
  Example from resource: Verbosity 2.
  Expected output: Shows only with `-vv` or higher.
  Example: Verbosity 3.
  ```yaml
  - name: Debug with high verbosity
    ansible.builtin.debug:
      var: ansible_facts
      verbosity: 3
  ```
  Expected output: Displays `ansible_facts` only with `-vvv` or higher (`changed: false`); return: none.
#### Practical Examples and Expected Outcomes
1. **Basic Message**:
   ```yaml
   - name: Print default message
     ansible.builtin.debug:
       msg: "Task completed successfully"
   ```
   Outcome: Prints "Task completed successfully" at all verbosity levels (`changed: false`); return: none.
2. **Conditional Variable Debug**:
   ```yaml
   - name: Debug variable if set
     ansible.builtin.debug:
       var: my_variable
       when: my_variable is defined
       verbosity: 1
   ```
   Outcome: Prints "my_variable: value" with `-v` or higher if defined (`changed: false`); skips if undefined.
3. **Multi-Line with Environment**:
   ```yaml
   - name: Debug environment
     ansible.builtin.debug:
       msg:
       - "Key: {{ lookup('ansible.builtin.env', 'MY_KEY') }}"
       - "Password: {{ password }}"
       when: lookup('ansible.builtin.env', 'MY_KEY') is defined
   ```
   Outcome: Prints two lines (e.g., "Key: myvalue", "Password: secret") if `MY_KEY` set (`changed: false`); skips otherwise.
#### Best Practices and Considerations
- **Idempotency**: No system changes; always `changed: false`.
- **Security**: Avoid printing sensitive data (e.g., passwords) unless masked; use `no_log: true` if needed.
- **Efficiency**: Use `verbosity` to reduce clutter in production runs; pair with `when:` for targeted debugging.
- **Troubleshooting**: Increase verbosity (`-vvv`) and combine with `register` for task outputs.

## Additional Examples for the Ansible Debug Module

#### Example 1: Using `msg` with Jinja2 Templating and Lists
```yaml
- name: Display system information with templating
  ansible.builtin.debug:
    msg:
      - "Hostname: {{ ansible_hostname }}"
      - "Distribution: {{ ansible_distribution }} {{ ansible_distribution_version }}"
      - "Memory: {{ ansible_memtotal_mb }} MB"
      - "CPU Cores: {{ ansible_processor_vcpus }}"
    verbosity: 1
```
**Explanation**: This example uses the `msg` parameter with a list to display multiple lines of system information. Each line uses Jinja2 templating to insert system facts. The `verbosity: 1` ensures this output only appears when running with at least `-v` flag. Output shows each line as a separate entry in the debug message, displaying the actual values for the target system (e.g., "Hostname: server01", "Distribution: Ubuntu 22.04", etc.).

#### Example 2: Using `var` with Complex Data Structures
```yaml
- name: Debug complex variable structure
  ansible.builtin.debug:
    var: ansible_facts
    verbosity: 2
```
**Explanation**: This example uses the `var` parameter to display the entire `ansible_facts` dictionary, which contains all gathered system information. The `verbosity: 2` ensures this detailed output only appears with `-vv` or higher. Output shows the complete facts dictionary in a structured format, which can be extensive but valuable for troubleshooting system configurations.

#### Example 3: Conditional Debugging with `when` Clause
```yaml
- name: Debug only for specific OS family
  ansible.builtin.debug:
    msg: "This is a RedHat-based system"
  when: ansible_os_family == "RedHat"
```
**Explanation**: This example demonstrates conditional debugging using the `when` clause. The debug message only appears when the target system belongs to the RedHat OS family (RHEL, CentOS, Fedora, etc.). Output shows the message only on matching systems, with no output on non-matching systems. This is useful for environment-specific debugging.

#### Example 4: Using `msg` with Error Handling
```yaml
- name: Display error message if task failed
  ansible.builtin.debug:
    msg: "Task failed with error: {{ task_result.stderr }}"
  when: task_result.failed
```
**Explanation**: This example shows how to use the debug module to display error messages when a task fails. The `when` clause checks if the registered variable `task_result` indicates failure. Output shows the error message only when the condition is met, displaying the actual error from the failed task's stderr. This is valuable for troubleshooting failed operations.

#### Example 5: Using `var` with Nested Variables
```yaml
- name: Debug nested variable
  ansible.builtin.debug:
    var: hostvars[inventory_hostname]['ansible_facts']['network']['interfaces']
    verbosity: 3
```
**Explanation**: This example uses the `var` parameter to display nested variables from the hostvars dictionary, specifically focusing on network interfaces. The `verbosity: 3` ensures this detailed output only appears with `-vvv` or higher. Output shows the network interfaces structure for the target host, including details like IP addresses, MAC addresses, and interface states.

#### Example 6: Using `msg` with Dynamic Content from Lookup
```yaml
- name: Display file content
  ansible.builtin.debug:
    msg: "File content: {{ lookup('ansible.builtin.file', '/etc/motd') }}"
  when: lookup('ansible.builtin.file', '/etc/motd') != ""
```
**Explanation**: This example uses the `msg` parameter with a lookup plugin to read and display the content of the `/etc/motd` file. The `when` clause ensures the message only appears if the file is not empty. Output shows the actual content of the file, which is useful for verifying configuration files or message-of-the-day content.

#### Example 7: Using `var` with Registered Task Output
```yaml
- name: Execute command and debug output
  ansible.builtin.command: "systemctl status nginx"
  register: nginx_status
  ignore_errors: yes

- name: Debug command output
  ansible.builtin.debug:
    var: nginx_status.stdout_lines
    verbosity: 2
```
**Explanation**: This example executes a command to check the Nginx service status, registers the output, and then uses the debug module to display the stdout_lines. The `verbosity: 2` ensures this output only appears with `-vv` or higher. Output shows the status lines from the systemctl command, which is useful for verifying service status without running the playbook in verbose mode.

#### Example 8: Using `msg` with Conditional Formatting
```yaml
- name: Display disk usage warning
  ansible.builtin.debug:
    msg: "WARNING: Low disk space on {{ item.mount }} - {{ item.size_available }} bytes available"
  when: item.size_available < 1073741824  # 1GB
  loop: "{{ ansible_mounts }}"
```
**Explanation**: This example uses the `msg` parameter with a loop to check disk usage on all mounted filesystems. The `when` clause triggers a warning message when available space is less than 1GB. Output shows warning messages only for filesystems that meet the condition, displaying the mount point and available bytes. This is useful for proactive disk space monitoring.

#### Example 9: Using `var` with Host-Specific Variables
```yaml
- name: Debug host-specific variables
  ansible.builtin.debug:
    var: hostvars[inventory_hostname]
    verbosity: 4
```
**Explanation**: This example uses the `var` parameter to display all variables for the current host from the hostvars dictionary. The `verbosity: 4` ensures this highly detailed output only appears with `-vvvv` or higher. Output shows all variables defined for the host, including facts, inventory variables, and variables set during playbook execution. This is comprehensive but potentially overwhelming, so it's reserved for deep troubleshooting.

#### Example 10: Combining `msg` and `var` with Verbosity Control
```yaml
- name: Display both custom message and variable
  ansible.builtin.debug:
    msg: "Current user information:"
    var: ansible_user_id
    verbosity: 1
```
**Explanation**: This example combines both `msg` and `var` parameters to display a custom message followed by the value of a variable. The `verbosity: 1` ensures this output only appears with `-v` or higher. Output shows the custom message "Current user information:" followed by the value of `ansible_user_id` (e.g., "root" or "ubuntu"). This approach provides context along with the variable value, making the output more readable and informative.

### Summary Table of Arguments
| Argument Name | Type    | Default Value  | Possible Values and Effects                                                                                                             | Required | Notes/Deprecations          |
| ------------- | ------- | -------------- | --------------------------------------------------------------------------------------------------------------------------------------- | -------- | --------------------------- |
| msg           | string  | "Hello world!" | Any string or list (effect: prints custom message(s), supports Jinja2)                                                                  | No       | Mutually exclusive with var |
| var           | string  | None           | Any variable name (effect: prints variable value, Jinja2 context)                                                                       | No       | Mutually exclusive with msg |
| verbosity     | integer | 0              | 0 (always visible), 1 (with -v+), 2 (with -vv+), 3 (with -vvv+), 4 (with -vvvv+), etc. (effect: controls visibility by verbosity level) | No       | -                           |
